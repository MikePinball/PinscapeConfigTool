<!DOCTYPE html>
<html>
<head>
   <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
   <link rel="stylesheet" href="main.css"/>
   <link rel="stylesheet" href="jquery-ui/jquery-ui-1.11.4.css"/>
   <title>Pinscape Controller Settings</title>
</head
<body>

<script type="text/javascript" src="jquery-1.12.1.js"></script>
<script type="text/javascript" src="jquery-ui/jquery-ui-1.11.4.js"></script>
<script type="text/javascript" src="util.js"></script>


<script>
// Configuration sources
var ConfigSource = {
    Board: 1,		// loading from the board
    File: 2,		// configuration saved in a local file
    Factory: 3		// pre-set factory configuration
};

// Accessible KL25Z GPIO ports.  These are the ports that can be
// assigned to configurable functions, such as LedWiz outputs, key
// inputs, and outboard chip connections.  The CPU nominally has 160
// GPIO lines (five ports of 32 pins each), but only the subset shown
// below are physically wired to external pins on the Freescale board.
//
// Notes:
//
// - One additional port, PTC1, is connected to an external pin, but can't
//   be connected to anything, because it's reserved by the mbed software
//   as the real-time clock input.  The pin is thus omitted from the list.
//
// - PTD0 is exposed as an external pin, but is also hardwired on the
//   Freescale board to the blue on-board LED.  It *can* be used for an
//   external device, but doing so will give up control over the blue LED
//   for status displays.  The blue LED in this case will still turn
//   on and off according to the electrical state of the pin, since there's
//   no way to physically disconnect the LED.
//
// - PTB18 and PTB19 are included even though they're *not* connected to
//   external pins.  We include them because they're connected to the
//   on-board red and green LEDs, respectively, which makes them usable as
//   LedWiz outputs.  When used this way, the LedWiz output controls the
//   on-board LED.  These outputs can't be wired to any external devices,
//   since the ports aren't connected to header pins, but it could be
//   useful in some cases to connect outputs to the on-board LEDs.  For
//   example, this can be used as a quick way to test software on the PC
//   to see if it's talking to the output controller properly.
//
// A limited subset of pins are capable of being used as PWM outputs,
// ADC inputs, or either.  The PWM-capable pins have a "pwm" property in
// the list below.  Likewise, the ADC-capable pins have an "adc"
// property.
//
// The "pwm" property for PWM-capable pins is in the format
// "TPM.channel", giving the TPM device number and channel tied to 
// the pin.  E.g., "2.0" means TPM #2, channel 0.  The TPMs ("Timer/
// PWM Modules") are the on-board peripherals that actually generate
// the PWM signals.  The CPU doesn't itself generate the PWM signals;
// those come from the TPMs.  Each PWM-capable GPIO pin is wired to
// exactly one TPM channel through the CPU multiplexer (an electrical
// switching network within the CPU).  The multiplexer makes the TPM
// connection optional: a PWM-capable pin can be connected to its
// TPM channel, or it can be connected to something else, such as one
// of the CPU digital in/out registers.  But this configurability only
// goes so far: the MUX connection only allows a particular PWM pin to
// connect to a particular, pre-determined TPM channel.  The association
// between a given GPIO pin and its assigned TPM channel isn't
// configurable.  These fixed pin-to-TPM connections are what's
// shown in the "pwm" properties.  For example, PTA1 can be connected
// through the MUX to TPM2 channel 0.  There are a total of 10
// distinct TPM channels connected to exposed GPIO pins.  However,
// there are more than 10 PWM-capable pins because some exposed TPM
// channels are connected to more than one GPIO pin.  In such cases,
// *only one* of the associated pins may be MUXed as a PWM.  For
// example, TPM2.0 is wired to PTA1, PTB2, PTB18, and PTE22.  Since
// all four pins map to the same TPM channel, and the TPM channel is
// what generates the PWM signal for the pins, these four pins can't
// be controlled as independent PWM outs.  Only *one* of these pins
// may thus be used at any given time as a PWM out - the rest must be
// used for some other purpose.  For example, if we assign PTA1 as a
// PWM out, it means we lose the ability to assign PTB2, PTB18, and
// PTE22 as PWM outs.  This is why we can only have 10 concurrent PWM
// outputs with this chip, even though it appears superficially that
// there are 31 PWM-capable pins.
//
// The ADC-capable pins include an "adc" property in the format
// "module.channel".  E.g., 0.3 means ADC0 channel 3.  There's only
// one ADC module on the KL25Z, so the module number is always 0, but
// we include it for the sake of documentation.  The wiring between
// pins and ADC channels works just like with the PWM channels, so
// only the pins marked with "adc" can be used as ADC inputs at all,
// and each one can only be run through its hardwired ADC channel.
// The ADC setup is simpler than the TPM, though, in that there are
// no duplicate pin assignments for any ADC channels - meaning that
// every ADC-capable pin can be assigned as an ADC concurrently,
// without having to worry about overcommitting module channels.
//
// It's important to understand that the "pwm" and "adc" associations
// in the list below merely *document* the pin-to-channel connections.
// The entries don't determine them or affect what's connected to what.
// The connections are physically hard-wired within the CPU and simply
// can't be changed.  Changing the property values below won't change
// the way the pins are wired; it will only make the entries in the
// table wrong.
//
var gpioPins = [
    { name: "PTA1",  pwm: "2.0" },
    { name: "PTA2",  pwm: "2.1" },
    { name: "PTA4",  pwm: "0.1" },
    { name: "PTA5",  pwm: "0.2" },
    { name: "PTA12", pwm: "1.0" },
    { name: "PTA13", pwm: "1.1" },
    { name: "PTA16"  },
    { name: "PTA17"  },
    { name: "PTB0",  pwm: "1.0", adc: "0.8" },
    { name: "PTB1",  pwm: "1.1", adc: "0.9" },
    { name: "PTB2",  pwm: "2.0", adc: "0.12" },
    { name: "PTB3",  pwm: "2.1", adc: "0.13" },
    { name: "PTB8"   },
    { name: "PTB9"   },
    { name: "PTB10"  },
    { name: "PTB11"  },
    { name: "PTB18", pwm: "2.0", onBoardLED: 1,
                     internal: true, internalName: "Red on-board LED", internalShortName: "Red LED",
		     warning: "This port is hard-wired on the KL25Z to the red on-board LED. "
			      + "Using this port will supersede the red LED's normal status "
			      + "display function." },
    { name: "PTB19", pwm: "2.1", onBoardLED: 2,
                     internal: true, internalName: "Green on-board LED", internalShortName: "Green LED",
		     warning: "This port is hard-wired on the KL25Z to the green on-board LED. "
			      + "Using this port will supersede the green LED's normal status "
			      + "display function." },
    { name: "PTC0",  adc: "0.14" },
    // { name: "PTC1",  pwm: "0.0", adc: "0.15" }, // omitted - reserved by mbed platform for real-time clock input
    { name: "PTC2",  pwm: "0.1", adc: "0.11" },
    { name: "PTC3",  pwm: "0.2" },
    { name: "PTC4",  pwm: "0.3" },
    { name: "PTC5",  spi: "SCLK" },
    { name: "PTC6",  spi: "MOSI" },
    { name: "PTC7",  spi: "MISO" },
    { name: "PTC8",  pwm: "0.4" },
    { name: "PTC9",  pwm: "0.5" },
    { name: "PTC10"  },
    { name: "PTC11"  },
    { name: "PTC12"  },
    { name: "PTC13"  },
    { name: "PTC16"  },
    { name: "PTC17"  },
    { name: "PTD0",  pwm: "0.0" },
    { name: "PTD1",  pwm: "0.1", adc: "0.5b", spi: "SCLK", onBoardLED: 3, remarks: "Blue on-board LED",
		     warning: "This port is hard-wired on the KL25Z to the blue on-board LED. "
		              + "You can use this port for other purposes, but doing so will "
			      + "supersede the blue LED's normal status display function." },
    { name: "PTD2",  pwm: "0.2", spi: "MOSI" },
    { name: "PTD3",  pwm: "0.3", spi: "MISO" },
    { name: "PTD4",  pwm: "0.4" },
    { name: "PTD5",  pwm: "0.5", adc: "0.6b" },
    { name: "PTD6",  adc: "0.7b" },
    { name: "PTD7"   },
    { name: "PTE0"   },
    { name: "PTE1"   },
    { name: "PTE2"   },
    { name: "PTE3"   },
    { name: "PTE4"   },
    { name: "PTE5"   },
    { name: "PTE20", pwm: "1.0", adc: "0.0" },
    { name: "PTE21", pwm: "1.1", adc: "0.4a" },
    { name: "PTE22", pwm: "2.0", adc: "0.3" },
    { name: "PTE23", pwm: "2.1", adc: "0.7a" },
    { name: "PTE29", pwm: "0.2", adc: "0.4b" },
    { name: "PTE30", pwm: "0.3", adc: "0.23" },
    { name: "PTE31", pwm: "0.4" }
];

// build a hash of the pin table indexed by name
var gpioPinsByName = { };
for (var i = 0 ; i < gpioPins.length ; ++i)
    gpioPinsByName[gpioPins[i].name] = gpioPins[i];

// get the jumper location for a given pin
function pinToJumper(pin)
{
    var g = gpioPinsByName[pin] || {};
    return g.internalShortName || (g.pin || {}).name;
}

// build a hash of PWM channels and the associated pins
var pwmChannels = { };
for (var i = 0 ; i < gpioPins.length ; ++i)
{
    var g = gpioPins[i];
    if (g.pwm)
    {
	var t = pwmChannels[g.pwm];
	if (!t)
	    pwmChannels[g.pwm] = t = {
		name: g.pwm,
		orList: function() { return serialComma($.map(this.pins, function(ele) { return ele.name; }), "or"); },
		pins: []
	    };
	t.pins.push(g);
    }
}

// KL25Z pin headers
var kl25z_headers = {
    "J1": {
	pins: [["PTC7", "PTC0", "PTC3", "PTC4",  "PTC5", "PTC6", "PTC10", "PTC11"],
	       ["PTA1", "PTA2", "PTD4", "PTA12", "PTA4", "PTA5", "PTC8",  "PTC9"]],
	type: "pinheader",
	pin1: [26, 88],
	pinN: [14, 174]
    },
    "J2": {
	pins: [["PTC12", "PTC13", "PTC16", "PTC17", "PTA16", "PTA17", "PTE31", "NC",    "PTD6", "PTD7"],
	       ["PTA13", "PTD5",  "PTD0",  "PTD2",  "PTD3",  "PTD1",  "GND",   "VREFH", "PTE0", "PTE1"]],
	type: "pinheader",
	pin1: [26, 194],
	pinN: [14, 306]
    },
    "J9": {
	pins: [["PTB8",    "PTB9", "PTB10", "PTB11", "PTE2",  "PTE3", "PTE4", "PTE5"],
	       ["SDA_PTD", "P3V3", "RESET", "P3V3",  "USB5V", "GND",  "GND",  "VIN"]],
	type:   "pinheader",
	pin1: [238, 262],
	pinN: [250, 175]
    },
    "J10": {
	pins: [["PTE20", "PTE21", "PTE22", "PTE23", "PTE29", "PTE30"],
	       ["PTB0",  "PTB1",  "PTB2",  "PTB3",  "PTC2",  "CLKIN"]],
	type: "pinheader",
	pin1: [238, 150],
	pinN: [250, 88]
    },

    // fake header representing the internal LED connections
    "LED": {
	pins: [["PTB18", "PTB19"]],
	type: "pinheader",
	pin1: [163, 137],
	pinN: [163, 152]
    }
};

// TLC5940 pins
var tlc5940_pins = {
    pins: ["OUT1",  "OUT2", "OUT3", "OUT4",  "OUT5",  "OUT6", "OUT7", "OUT8", "OUT9",  "OUT10", "OUT11", "OUT12", "OUT13", "OUT14",
           "OUT15", "XERR", "SOUT", "GSCLK", "DCPRG", "IREF", "VCC",  "GND",  "BLANK", "XLAT",  "SCLK",  "SIN",   "VPRG",  "OUT0"],
    type: "dip",
    pin1: [73, 46],
    pinN: [197, 368]
};

// 74HC595 pins
var hc595_pins = {
    pins: ["OUT1",  "OUT2", "OUT3", "OUT4",  "OUT5",  "OUT6", "OUT7", "GND",
           "OUT7'", "RST",  "SCLK", "LATCH", "ENA",   "SIN",  "OUT0", "VCC"],
    type: "dip",
    pin1: [85, 99],
    pinN: [188, 337]
};

// Expansion board - main board headers
var mainBoard_headers = {
    "JP12": {
	pins: [["PTC4", "PTC0"],
	       ["PTC3", "PTA2"]],
        type: "pinheader",
	pin1: [217, 76],
	pinN: [226, 67],
	orientation: "horizontal"
    },

    "JP11": {
	pins: [["3.8", "3.9", "3.10", "3.11", "3.12", "3.13", "3.14", "+5V"],
	       ["3.0", "3.1", "3.2",  "3.3",  "3.4",  "3.5",  "3.6",  "3.7"]],
	type: "pinheader",
	pin1: [91, 137],
	pinN: [82, 77]
    },

    "JP8": {
	pins: [["3.16", "3.17", "3.18", "3.19", "3.20", "3.21", "3.28", "3.29", "3.30"],
	       ["3.22", "3.23", "3.24", "3.25", "3.26", "3.27", "3.31", "NC", "+5V"]],
	type: "pinheader",
	pin1: [327, 152],
	pinN: [318, 83]
    },

    "JP3": {
        pins: [["PTE23", "LED+"],   // JP3-3 = LED+ = +5V; JP3-1 = Cal Btn LED- = open collector switched by PTE23
               ["PTE29", "GND"]],   // JP3-2 = Cal Btn = direct connection to PTE29
        type: "pinheader",
        orientation: "horizontal",
        pin1: [239, 336],
        pinN: [231, 345]
    },
    
    "JP2": {
        pins: [["PTB0", "PTE21", "3.3V", "5V"],
               ["NC",   "PTE22", "GND",  "PTE20"]],
        type: "pinheader",
        pin1: [206, 336],
        pinN: [181, 345]
    },
    
    "JP1": {
        pins: [["PTC2", "PTB2", "PTE30", "PTE5", "PTE3", "PTB11", "PTB9", "PTC12", "PTC16", "PTA16", "PTE31", "PTD7", "NC"],
               ["PTB3", "PTB1", "PTC11", "PTE4", "PTE2", "PTB10", "PTB8", "PTC13", "PTC17", "PTA17", "PTD6",  "PTE1", "COMMON"]],
        type: "pinheader",
        pin1: [144, 337],
        pinN: [43, 346]
    },

    "JP9": {
	pins: [["PTC8", "3.15"]],
	type: "pinheader",
	pin1: [190, 71],
	pinN: [199, 71]
    }

    // JP6 - PWM OUT.  For reference only; none of these pins
    // can be assigned as inputs or outputs
    //"JP6": {
    //    pins: [["SOUT", "SCLK", "XLAT", "BLANK", "GSCLK"],
    //           ["GND",  "GND",  "GND",  "GND",   "NC"]],
    //    type: "pinheader",
    //    pin1: [320, 214],
    //    pinN: [328, 249]
    //},

    // JP5 - Chime Out.  For reference only; these pins aren't
    // assignable as inputs or outputs.
    //"JP5": {
    //    pins: [["SOUT", "SCLK", "LATCH", "ENA", "3.3V"],
    //           ["NC",   "GND",  "GND",   "GND", "GND"]],
    //    type: "pinheader",
    //    pin1: [319, 285],
    //    pinN: [328, 320]
    //},

    // JP4 - TV switches.  For reference only; these pins can't
    // be assigned as inputs or outputs.
    //"JP4": {
    //    pins: [["TV1",  "TV2",  "IR+"],      // JP4-5 = IR+ = 5V
    //           ["TV1",  "TV2",  "PTC9"]],    // JP4-6 = IR- = open collector switched by PTC9
    //    type: "pinheader",
    //    pin1: [275, 309],
    //    pinN: [258, 317]
    //},
};

var powerBoard_headers = {
    "JP5": {
	pins: [["3.32", "3.33", "3.34", "3.35", "3.36", "3.37", "3.38", "3.39", "3.40", "3.41", "3.42", "3.43", "3.44", "3.45", "3.46", "3.47"]],
	type: "pinheader",
	pin1: [97, 49],
	pinN: [225, 49]
    },
    
    "JP6": {
	pins: [["3.48", "3.49", "3.50", "3.51", "3.52", "3.53", "3.54", "3.55", "3.56", "3.57", "3.58", "3.59", "3.60", "3.61", "3.62", "3.63"]],
	type: "pinheader",
	pin1: [97, 361],
	pinN: [225, 361]
    }

    // for reference only - these pins aren't assignable
    //"JP2": {
    //    pins: [["SIN",  "SCLK", "XLAT", "BLANK", "GSCLK"],
    //           ["GND",  "GND",  "GND",  "GND",   "GND"]],
    //    type: "pinheader",
    //    pin1: [318, 212],
    //    pinN: [327, 246]
    //},
    //"JP3": {
    //    pins: [["SOUT", "SCLK", "XLAT", "BLANK", "GSCLK"],
    //           ["GND",  "GND",  "GND",  "GND",   "GND"]],
    //    type: "pinheader",
    //    pin1: [318, 292],
    //    pinN: [327, 327]
    //}
};

var chimeBoard_headers = {
    "JP9": {
	pins: [["4.0", "4.1", "4.2", "4.3", "4.4", "4.5", "4.6", "4.7"]],
	type: "pinheader",
	pin1: [113, 68],
	pinN: [174, 68]
    }

    // for reference only - these pins aren't assignable
    //"JP2": {
    //    pins: [["SOUT", "SCLK", "LATCH", "ENA", "3.3V"],
    //           ["NC",   "GND",  "GND",   "GND", "GND"]],
    //    type: "pinheader",
    //    pin1: [319, 224],
    //    pinN: [328, 259]
    //},
    //"JP3": {
    //    pins: [["SIN",  "SCLK", "LATCH", "ENA", "3.3V"],
    //           ["NC",   "GND",  "GND",   "GND", "GND"]],
    //    type: "pinheader",
    //    pin1: [319, 299],
    //    pinN: [328, 334]
    //}
};

// Iterate over a pin header object.  Calls func(name, x, y), where
// 'name' is the pin name, 'n' is the pin number (starting at 1), and
// 'x' and 'y' give the spatial coordinates.
function forEachPin(header, func)
{
    ({ "dip": forEachDIPPin, "pinheader": forEachHeaderPin })[header.type](header, func);
}

// DIP IC chip pins are conventionally arranged clockwise around
// the chip, starting with pin 1 at the lower left:
//
//   n n-1 n-2 ... n/2+1
//   1 2   3   ... n/2
//
// Chips can of course be rotated on the board.  We allow rotations
// in 90 degree increments.  We infer the orientation from the
// positions of the first pin and diametrically opposed pins, given
// by properties pin1=[x,y] and pinN=[x,y].  The pin positions are
// given as image-relative coordinates of the centers of the
// respective pins.  Note that pinN isn't the highest numbered pin:
// it's actually the diametrically opposed pin, so the first pin
// in the second row at pin number n/2+1.
function forEachDIPPin(chip, func)
{
    // get the number of pins, and the number on each side (it's a DIP,
    // so there are exactly two rows of pins)
    var npins = chip.pins.length;
    var oneSidePins = npins/2;

    // get the pin 1 location (pin1=[x,y] position of center of pin 1)
    var x1 = chip.pin1[0];
    var y1 = chip.pin1[1];

    // get the last pin location (pinN=[x,y] position of center of last pin)
    var xN = chip.pinN[0];
    var yN = chip.pinN[1];

    // Infer the orientation.  If pin1 is at the lower left or upper right,
    // it's horizontal, otherwise it's vertical.
    var horizontal = ((x1 < xN && y1 > yN) || (x1 > xN && y1 < yN));

    // figure the iteration increments
    var pindx = 0, pindy = 0, rowdx = 0, rowdy = 0;
    if (horizontal)
    {
	if (oneSidePins > 1) pindx = (xN - x1)/(oneSidePins - 1);
	rowdy = yN - y1;
    }
    else
    {
	if (oneSidePins > 1) pindy = (yN - y1)/(oneSidePins - 1);
	rowdx = xN - x1;
    }

    // go up the first row, starting at pin 1
    var pins = chip.pins;
    var x = x1, y = y1;
    for (var pin = 0 ; pin < oneSidePins ; ++pin, x += pindx, y += pindy)
	func(pins[pin], pin, x, y);

    // go down the second row, reversing direction
    for (x += rowdx, y += rowdy, x -= pindx, y -= pindy ; pin < npins ; ++pin, x -= pindx, y -= pindy)
	func(pins[pin], pin, x, y);
}

// Pin headers are arranged into rows and columns, where the
// row is the long dimension.  E.g., a 2x10 header has 2 rows
// of 10 pins, and a 3x15 has 3 rows of 15 pins.
//
// We use a zig-zag numbering scheme.  Pin 1 is always at
// one corner.  Pin 2 is the next pin in the same column.
// Continue numbering up the column until reaching the last
// pin, then go back to the next pin in the starting row.
// Repeat until done.
//
// This conventional is pretty universal, but the headers
// can of course be rotated, and they can also be mirrored.
// We allow for four rotations, at right angles.
//
// header.pins = [[row1], [row2], [row3]...] - pin name strings
// header.pin1 = [x,y] - center coordinates of pin 1, relative to image
// header.pinN = [x,y] - center coordinates of LAST pin, relative to image
//
// Important: the pin1 and pinN positions are the coordinates
// of the centers of the respective pins, not of the header
// plastic or shroud.  Also, note that the property name pinN
// is literal - the N isn't meant to be replaced with a number,
// it's just a literal N.
//
// For reference, here are the standard numbering layouts in
// the cardinal rotations.  In most cases, we can work out the
// orientation on our own, by noting which dimension (x or y)
// is longer - the long dimension is the row.  The exception
// is when the pin array is square, such as a 2x2.  In this
// case, we need to know whether it's a horizontal or vertical
// orientation.  Set header.orientation to "horizontal" or
// "vertical" in this case to tell us which it is.  (You can
// set that in all cases, and it'll override our inference if
// set, but it's easier to omit it when not necessary.)
//
//            0 deg        90 deg      180 deg     270 deg
//
//                           6 5                     1 2
//            2 4 6          4 3        5 3 1        3 4
//  normal    1 3 5          2 1        6 4 2        5 6
//
//                           2 1                     5 6
//            6 4 2          4 3        1 3 5        3 4
//  mirror    5 3 1          6 5        2 5 6        1 2
//
function forEachHeaderPin(header, func)
{
    // get the number of pin rows in this header, and number of pins in each row
    var nrows = header.pins.length;
    var npins = header.pins[0].length;

    // get the pin 1 location (header.pin1 = [x,y])
    var x1 = header.pin1[0];
    var y1 = header.pin1[1];

    // get the position of the last pin (pinN)
    var xN = header.pinN[0];
    var yN = header.pinN[1];

    // figure the orientation - user the header.orientation setting if provided,
    // of infer it from which dimension is longer
    var wid = Math.abs(x1 - xN);
    var ht = Math.abs(y1 - yN);
    var orientation = header.orientation || (wid > ht ? "horizontal" : "vertical");

    // figure the column (pin) and row increments for the iteration
    var rowdx = 0, rowdy = 0, pindx = 0, pindy = 0;
    if (orientation == "horizontal")
    {
	// horizontal
	if (npins > 1) pindx = (xN - x1)/(npins - 1);
	if (nrows > 1) rowdy = (yN - y1)/(nrows - 1);
    }
    else
    {
	// vertical
	if (npins > 1) pindy = (yN - y1)/(npins - 1);
	if (nrows > 1) rowdx = (xN - x1)/(nrows - 1);
    }

    // start at pin 1
    var xrow = x1, yrow = y1;

    // process each row
    for (var row = 0 ; row < nrows ; ++row, xrow += rowdx, yrow += rowdy)
    {
	// start at the first pin of the row
	var pinno = row+1;
	var x = xrow, y = yrow;
	var pinrow = header.pins[row];
	
	// process each pin in the row
	for (var pin = 0 ; pin < npins ; ++pin, x += pindx, y += pindy, pinno += nrows)
	    func(pinrow[pin], pinno, x, y);
    }
}

</script>


<h1>
   <img src="h1options.png" style="float: right;">
   Settings
   <img src="h1options.png" style="vertical-align: middle; visibility: hidden;">
</h1>

<div>

   <p>
      <b>Configuration settings for KL25Z CPU ID
      <span id="CPUID">unknown</span></b>
   </p>


   <!--  Hardware setup  ----------------------------------------------------->
   <hr>
   <div>
      <div>
	 <img src="hardwareSection.png" class="sectionIcon">
	 <b>Hardware setup.</b>  Are you using this KL25Z on its own,
	 or with a set of expansion boards?  <a href="#" class="shower">Help</a>

	 <div class="hider">
	    If you're using the <a href="http://mjrnet.org/pinscape/expansion-board.html" target="_blank">
	       Pinscape expansion boards</a>, select that option below, and the
	    setup tool will automatically fill in the appropriate GPIO pin assignments
	    throughout the configuration.
	    If you're using external circuitry of your own design (e.g., output channel
	    power booster circuits), select "standalone" so that you can set custom
	    pin assignments to match your wiring.
	 </div>

	 <table class="radio">
	    <tr>
	       <td>
		  <label>
		     <img src="kl25z.png"><br>
		     <input type="radio" name="hardwareType" value="0">
		     Stand-alone KL25Z<br>
		     (or your own custom boards)
		  </label>
	       </td>
	       <td>
		  <label>
		     <img src="expansionStack.png"><br>
		     <input type="radio" name="hardwareType" value="1">
		     Pinscape Expansion Boards<br>
		     &nbsp;
		  </label>
	       </td>
	    </tr>
	 </table>
	 <input type="hidden" id="expBoardVersion">

	 <!-- expansion board options - initially hidden -->
	 <div id="expansionBoardOptions" style="height: 0px; overflow: hidden; margin: 1em 2em;">
	    <b>Expansion board details:</b>
	    <input id="numMainBoards" type="hidden">
	    <table class="inputs">
	       <!--
	       <tr>
		  <td>Number of main interface boards:</td>
		  <td><input type="text" id="numMainBoards" size="4" value="1">
	       </tr>
	       -->
	       <tr>
		  <td>Number of MOSFET power boards:</td>
		  <td><input type="text" id="numPowerBoards" size="4" value="0">
	       </tr>
	       <tr>
		  <td>Number of chime boards:</td>
		  <td><input type="text" id="numChimeBoards" size="4" value="0">
	       </tr>
	    </table>

	    <div>
	       <label><input type="checkbox" id="ckExpBoardShowPins">Show KL25Z pin assignments</label>
	       <br>
	       The KL25Z pin assignments are hidden by default because you've selected the
	       expansion board configuration.  All pin assignments are pre-determined in
	       this configuration.  Check the box above if you want to view the pin assignments
	       anyway, but be aware that any changes to pin assignments will probably cause problems.
	    </div>
	 </div>
      </div>

      <script>

// Factory configuration for the stand-alone KL25Z (no expansion boards)
var standaloneFactoryConfig = {
    expansionBoards: {
	version: "0",
	ext0: "0",
	ext1: "0",
	ext2: "0"
    },
    calButtonPins: {
	enabled: 0x03,
	button: "PTE29",
	led: "PTE23"
    },
    TVon: {
	statusPin: "NC",
	latchPin: "NC",
	relayPin: "NC",
	delay: 0
    },
    TLC5940: {
	nchips: 0,
	SIN: "PTC6",
	SCLK: "PTC5",
	XLAT: "PTC10",
	BLANK: "PTC7",
	GSCLK: "PTA1"
    },
    HC595: {
	nchips: 0,
	SIN: "PTA5",
	SCLK: "PTA4",
	LATCH: "PTA12",
	ENA: "PTD4"
    },
    ZBLaunchBall: {
	port: 0,
	keytype: 2,		// keyboard key
	keycode: 0x28,		// Enter key
	pushDistance: 63	// .063" ~ 1/16"
    },
    buttons: {
	// use the defaults from earlier versions, where everything was mapped to joystick buttons
	1:  { pin: "PTC2",  keytype: 1, keycode: 1, flags: 0 },
	2:  { pin: "PTB3",  keytype: 1, keycode: 2, flags: 0 },
	3:  { pin: "PTB2",  keytype: 1, keycode: 3, flags: 0 },
	4:  { pin: "PTB1",  keytype: 1, keycode: 4, flags: 0 },
	5:  { pin: "PTE30", keytype: 1, keycode: 5, flags: 0 },
	6:  { pin: "PTE22", keytype: 1, keycode: 6, flags: 0 },
	7:  { pin: "PTE5",  keytype: 1, keycode: 7, flags: 0 },
	8:  { pin: "PTE4",  keytype: 1, keycode: 8, flags: 0 },
	9:  { pin: "PTE3",  keytype: 1, keycode: 9, flags: 0 },
	10: { pin: "PTE2",  keytype: 1, keycode: 10, flags: 0 },
	11: { pin: "PTB11", keytype: 1, keycode: 11, flags: 0 },
	12: { pin: "PTB10", keytype: 1, keycode: 12, flags: 0 },
	13: { pin: "PTB9",  keytype: 1, keycode: 13, flags: 0 },
	14: { pin: "PTB8",  keytype: 1, keycode: 14, flags: 0 },
	15: { pin: "PTC12", keytype: 1, keycode: 15, flags: 0 },
	16: { pin: "PTC13", keytype: 1, keycode: 16, flags: 0 },
	17: { pin: "PTC16", keytype: 1, keycode: 17, flags: 0 },
	18: { pin: "PTC17", keytype: 1, keycode: 18, flags: 0 },
	19: { pin: "PTA16", keytype: 1, keycode: 19, flags: 0 },
	20: { pin: "PTA17", keytype: 1, keycode: 20, flags: 0 },
	21: { pin: "PTE31", keytype: 1, keycode: 21, flags: 0 },
	22: { pin: "PTD6",  keytype: 1, keycode: 22, flags: 0 },
	23: { pin: "PTD7",  keytype: 1, keycode: 23, flags: 0 },
	24: { pin: "PTE1",  keytype: 1, keycode: 24, flags: 0 }
    },
    outputs: {
	1: { port: { type: 1, pin: "PTA1" }, flags: 0x00 },     // port 1  = PTA1 (PWM)
	2: { port: { type: 1, pin: "PTA2" }, flags: 0x00 },     // port 2  = PTA2 (PWM)
	3: { port: { type: 1, pin: "PTD4" }, flags: 0x00 },     // port 3  = PTD4 (PWM)
	4: { port: { type: 1, pin: "PTA12" }, flags: 0x00 },    // port 4  = PTA12 (PWM)
	5: { port: { type: 1, pin: "PTA4" }, flags: 0x00 },     // port 5  = PTA4 (PWM)
	6: { port: { type: 1, pin: "PTA5" }, flags: 0x00 },     // port 6  = PTA5 (PWM)
	7: { port: { type: 1, pin: "PTA13" }, flags: 0x00 },    // port 7  = PTA13 (PWM)
	8: { port: { type: 1, pin: "PTD5" }, flags: 0x00 },     // port 8  = PTD5 (PWM)
	9: { port: { type: 1, pin: "PTD0" }, flags: 0x00 },     // port 9  = PTD0 (PWM)
	10: { port: { type: 2, pin: "PTD3" }, flags: 0x00 },    // port 10 = PTD3 (PWM)
	11: { port: { type: 2, pin: "PTD2" }, flags: 0x00 },    // port 11 = PTD2 (Digital)
	12: { port: { type: 2, pin: "PTC8" }, flags: 0x00 },    // port 12 = PTC8 (Digital)
	13: { port: { type: 2, pin: "PTC9" }, flags: 0x00 },    // port 13 = PTC9 (Digital)
	14: { port: { type: 2, pin: "PTC7" }, flags: 0x00 },    // port 14 = PTC7 (Digital)
	15: { port: { type: 2, pin: "PTC0" }, flags: 0x00 },    // port 15 = PTC0 (Digital)
	16: { port: { type: 2, pin: "PTC3" }, flags: 0x00 },    // port 16 = PTC3 (Digital)
	17: { port: { type: 2, pin: "PTC4" }, flags: 0x00 },    // port 17 = PTC4 (Digital)
	18: { port: { type: 2, pin: "PTC5" }, flags: 0x00 },    // port 18 = PTC5 (Digital)
	19: { port: { type: 2, pin: "PTC6" }, flags: 0x00 },    // port 19 = PTC6 (Digital)
	20: { port: { type: 2, pin: "PTC10" }, flags: 0x00 },   // port 20 = PTC10 (Digital)
	21: { port: { type: 2, pin: "PTC11" }, flags: 0x00 },   // port 21 = PTC11 (Digital)
	22: { port: { type: 2, pin: "PTE0" }, flags: 0x00 }     // port 22 = PTE0 (Digital)
    }
};

// Factory configuration for the expansion boards
var expansionBoardFactoryConfig = {
    expansionBoards: {
	version: "0",
	ext0: "1",
	ext1: "1",
	ext2: "0"
    },
    calButtonPins: {
	enabled: 0x03,
	button: "PTE29",
	led: "PTE23"
    },
    TVon: {
	statusPin: "PTD2",
	latchPin: "PTE0",
	relayPin: "PTD3",
	delay: 700
    },
    TLC5940: {
	SIN: "PTC6",
	SCLK: "PTC5",
	XLAT: "PTC10",
	BLANK: "PTC7",
	GSCLK: "PTA1"
    },
    HC595: {
	SIN: "PTA5",
	SCLK: "PTA4",
	LATCH: "PTA12",
	ENA: "PTD4"
    },
    ZBLaunchBall: {
	port: 0,
	keytype: 2,		// keyboard key
	keycode: 0x28,		// Enter key
	pushDistance: 63	// .063" ~ 1/16"
    },
    buttons: {
	// for expansion board mode, use keyboard mappings for the standard VP and VPinMAME keys
	1:  { pin: "PTC2",  keytype: 2, keycode: 0x1E, flags: 0 },  // "1" = start
	2:  { pin: "PTB3",  keytype: 2, keycode: 0x1F, flags: 0 },  // "2" = extra ball
	3:  { pin: "PTB2",  keytype: 2, keycode: 0x22, flags: 0 },  // "5" = coin 1
	4:  { pin: "PTB1",  keytype: 2, keycode: 0x21, flags: 0 },  // "4" = coin 2
	5:  { pin: "PTE30", keytype: 2, keycode: 0x23, flags: 0 },  // "6" = coin 4
	6:  { pin: "PTC11", keytype: 2, keycode: 0x28, flags: 0 },  // Enter = launch ball
	7:  { pin: "PTE5",  keytype: 2, keycode: 0x29, flags: 0 },  // Escape = exit
	8:  { pin: "PTE4",  keytype: 2, keycode: 0x14, flags: 0 },  // "Q" = quit 
	9:  { pin: "PTE3",  keytype: 2, keycode: 0xE1, flags: 0 },  // left shift = left flipper 
	10: { pin: "PTE2",  keytype: 2, keycode: 0xE5, flags: 0 },  // right shift = right flipper
	11: { pin: "PTB11", keytype: 2, keycode: 0xE0, flags: 0 },  // left control = left magna
	12: { pin: "PTB10", keytype: 2, keycode: 0xE4, flags: 0 },  // right control = right magna 
	13: { pin: "PTB9",  keytype: 2, keycode: 0x17, flags: 0 },  // "T" = tilt bob  
	14: { pin: "PTB8",  keytype: 2, keycode: 0x4A, flags: 0 },  // Home = slam tilt switch
	15: { pin: "PTC12", keytype: 2, keycode: 0x2C, flags: 0 },  // Space = keyboard nudge
	16: { pin: "PTC13", keytype: 2, keycode: 0x4D, flags: 0 },  // "End" = coin door
	17: { pin: "PTC16", keytype: 2, keycode: 0x24, flags: 0 },  // "7" = service escape
	18: { pin: "PTC17", keytype: 2, keycode: 0x25, flags: 0 },  // "8" = service down/-
	19: { pin: "PTA16", keytype: 2, keycode: 0x26, flags: 0 },  // "9" = service up/+
	20: { pin: "PTA17", keytype: 2, keycode: 0x27, flags: 0 },  // "0" = service enter
	21: { pin: "PTE31", keytype: 2, keycode: 0x2E, flags: 0 },  // "=" = VP volume down
	22: { pin: "PTD6",  keytype: 2, keycode: 0x2D, flags: 0 },  // "-" = VP volume up
	23: { pin: "PTD7",  keytype: 2, keycode: 0x81, flags: 0 },  // Windows master volume down
	24: { pin: "PTE1",  keytype: 2, keycode: 0x80, flags: 0 }   // Windows master volume up
    },
    outputs: {
	// Map the first 16 ports to the flashers & strobe on TLC5940 #1.
	// These are among the most common devices, so we want to map them
	// into the first 32 logical port numbers for LedWiz compatibility.
	1:  { port: { type: 3, pin: 0  }, flags: 0x04 },
	2:  { port: { type: 3, pin: 1  }, flags: 0x04 },
	3:  { port: { type: 3, pin: 2  }, flags: 0x04 },
	4:  { port: { type: 3, pin: 3  }, flags: 0x04 },
	5:  { port: { type: 3, pin: 4  }, flags: 0x04 },
	6:  { port: { type: 3, pin: 5  }, flags: 0x04 },
	7:  { port: { type: 3, pin: 6  }, flags: 0x04 },
	8:  { port: { type: 3, pin: 7  }, flags: 0x04 },
	9:  { port: { type: 3, pin: 8  }, flags: 0x04 },
	10: { port: { type: 3, pin: 9  }, flags: 0x04 },
	11: { port: { type: 3, pin: 10 }, flags: 0x04 },
	12: { port: { type: 3, pin: 11 }, flags: 0x04 },
	13: { port: { type: 3, pin: 12 }, flags: 0x04 },
	14: { port: { type: 3, pin: 13 }, flags: 0x04 },
	15: { port: { type: 3, pin: 14 }, flags: 0x04 },
	16: { port: { type: 3, pin: 15 }, flags: 0x04 },

	// Map port 17 to the knocker output, since it shares the jumper with the
	// strobe on output 16 - that makes these two physically adjacent outputs
	// logically adjacent in the port mapping.  Knockers are also quite common,
	// so this belongs in the first 32 ports anyway.  Mark it as noisy.
	17: { port: { type: 2, pin: "PTC8"}, flags: 0x02 },

	// Map the next 32 ports to the outputs from the first power board.  These
	// are TLC5940 chips #3 and #4 in the daisy chain (the main board has #1
	// and #2).  This mapping will provide an additional 15 general-purpose 
	// outputs that are accessible through the legacy LedWiz protocol, plus 17
	// more that aren't (because the ports are numbered 33 and up).  Once we
	// get above port 32 (the highest LedWiz-compatible port number), there are
	// no external constraints on port numbering, so we might as well just keep
	// going with contiguous port numbering for the remaining power board outputs.
	// This gives us consecutive DOF numbering for all 32 outputs on the board.
	//
	// These are general-purpose outputs, so don't use gamma.
	18: { port: { type: 3, pin: 32 }, flags: 0x00 },
	19: { port: { type: 3, pin: 33 }, flags: 0x00 },
	20: { port: { type: 3, pin: 34 }, flags: 0x00 },
	21: { port: { type: 3, pin: 35 }, flags: 0x00 },
	22: { port: { type: 3, pin: 36 }, flags: 0x00 },
	23: { port: { type: 3, pin: 37 }, flags: 0x00 },
	24: { port: { type: 3, pin: 38 }, flags: 0x00 },
	25: { port: { type: 3, pin: 39 }, flags: 0x00 },
	26: { port: { type: 3, pin: 40 }, flags: 0x00 },
	27: { port: { type: 3, pin: 41 }, flags: 0x00 },
	28: { port: { type: 3, pin: 42 }, flags: 0x00 },
	29: { port: { type: 3, pin: 43 }, flags: 0x00 },
	30: { port: { type: 3, pin: 44 }, flags: 0x00 },
	31: { port: { type: 3, pin: 45 }, flags: 0x00 },
	32: { port: { type: 3, pin: 46 }, flags: 0x00 },
	33: { port: { type: 3, pin: 47 }, flags: 0x00 },
	34: { port: { type: 3, pin: 48 }, flags: 0x00 },
	35: { port: { type: 3, pin: 49 }, flags: 0x00 },
	36: { port: { type: 3, pin: 50 }, flags: 0x00 },
	37: { port: { type: 3, pin: 51 }, flags: 0x00 },
	38: { port: { type: 3, pin: 52 }, flags: 0x00 },
	39: { port: { type: 3, pin: 53 }, flags: 0x00 },
	40: { port: { type: 3, pin: 54 }, flags: 0x00 },
	41: { port: { type: 3, pin: 55 }, flags: 0x00 },
	42: { port: { type: 3, pin: 56 }, flags: 0x00 },
	43: { port: { type: 3, pin: 57 }, flags: 0x00 },
	44: { port: { type: 3, pin: 58 }, flags: 0x00 },
	45: { port: { type: 3, pin: 59 }, flags: 0x00 },
	46: { port: { type: 3, pin: 60 }, flags: 0x00 },
	47: { port: { type: 3, pin: 61 }, flags: 0x00 },
	48: { port: { type: 3, pin: 62 }, flags: 0x00 },
	49: { port: { type: 3, pin: 63 }, flags: 0x00 },

	// Map the main board flipper button light/small LED outputs next.
	// These are the 16 outputs from the TLC5940 #2.  Flipper button
	// lights aren't among the most common toys, so we deliberately
	// map these in the high number range (where old LedWiz software
	// won't be able to access them) to make room for more common toys
	// in the LedWiz range.
	//
	// These are meant for LEDs, so use gamma by default.
	50: { port: { type: 3, pin: 16 }, flags: 0x04 },
	51: { port: { type: 3, pin: 17 }, flags: 0x04 },
	52: { port: { type: 3, pin: 18 }, flags: 0x04 },
	53: { port: { type: 3, pin: 19 }, flags: 0x04 },
	54: { port: { type: 3, pin: 20 }, flags: 0x04 },
	55: { port: { type: 3, pin: 21 }, flags: 0x04 },
	56: { port: { type: 3, pin: 22 }, flags: 0x04 },
	57: { port: { type: 3, pin: 23 }, flags: 0x04 },
	58: { port: { type: 3, pin: 24 }, flags: 0x04 },
	59: { port: { type: 3, pin: 25 }, flags: 0x04 },
	60: { port: { type: 3, pin: 26 }, flags: 0x04 },
	61: { port: { type: 3, pin: 27 }, flags: 0x04 },
	62: { port: { type: 3, pin: 28 }, flags: 0x04 },
	63: { port: { type: 3, pin: 29 }, flags: 0x04 },
	64: { port: { type: 3, pin: 30 }, flags: 0x04 },
	65: { port: { type: 3, pin: 31 }, flags: 0x04 }
    }
};

// fill out the factory defaults to 128 buttons and 128 outputs
(function() {
    function fill(d) {
	for (var i = 1 ; i <= 128 ; ++i) {
	    if (!(i in d.buttons)) {
		d.buttons[i] = { pin: "NC", keytype: 0, keycode: 0, flags: 0 };
	    }
	}
	for (var i = 1 ; i <= 128 ; ++i) {
	    if (!(i in d.outputs)) {
		d.outputs[i] = { port: { type: 0, pin: 0 } };
	    }
	}
    }
    fill(expansionBoardFactoryConfig);
    fill(standaloneFactoryConfig);
})();
    
// Output Port Aliases.  This is a table of port name aliases for
// expansion boards.  With the base configuration, we show output
// port names in raw hardware terms - i.e., the physical pins on
// the KL25Z or peripheral chips such as TLC5940's.  When an expansion
// board is used, the user does all of the wiring through the board
// headers, so we substitute the header pin locations in our displays.
// This table maps from hardware pins to the alias strings.  The keys
// are strings in the form "type.pin", where 'type' is the pin type
// number used in the USB setup messages (1 for KL25Z PWM GPIO, etc)
// and 'pin' is the internal pin name ("PTxx" for GPIO ports, or a
// port number from 0 to N for peripheral chips).
//
// Format of each entry:
//
//   Descriptive name|Output type description|Board name|JPx-y|xxxxOutputSelector
//
var outPortAlias = { };

// GPIO Port Aliases.  This is similar to the outPortAlias table,
// but covers only GPIO ports (no peripheral ports), and covers all
// GPIO ports used for any purpose, including inputs, outputs, and
// control connections to peripherals.
//
// Format:
//
//   Descriptive name|JPx-y or Internal
//
var gpioPortAlias = { };

// build the expansion board out port alias table
var expOutPortAlias, expGpioPortAlias;
(function()
{
    var o = {
	"3.15":   "Strobe|PWM Mid Power|Main Board|JP9-2|mainBoardPWMOutputSelector",

	"3.0":    "Flasher 1R|PWM Mid Power|Main Board|JP11-2|mainBoardPWMOutputSelector",
	"3.1":    "Flasher 1G|PWM Mid Power|Main Board|JP11-4|mainBoardPWMOutputSelector",
	"3.2":    "Flasher 1B|PWM Mid Power|Main Board|JP11-6|mainBoardPWMOutputSelector",
	"3.3":    "Flasher 2R|PWM Mid Power|Main Board|JP11-8|mainBoardPWMOutputSelector",
	"3.4":    "Flasher 2G|PWM Mid Power|Main Board|JP11-10|mainBoardPWMOutputSelector",
	"3.5":    "Flasher 2B|PWM Mid Power|Main Board|JP11-12|mainBoardPWMOutputSelector",
	"3.6":    "Flasher 3R|PWM Mid Power|Main Board|JP11-14|mainBoardPWMOutputSelector",
	"3.7":    "Flasher 3G|PWM Mid Power|Main Board|JP11-16|mainBoardPWMOutputSelector",
	"3.8":    "Flasher 3B|PWM Mid Power|Main Board|JP11-1|mainBoardPWMOutputSelector",
	"3.9":    "Flasher 4R|PWM Mid Power|Main Board|JP11-3|mainBoardPWMOutputSelector",
	"3.10":   "Flasher 4G|PWM Mid Power|Main Board|JP11-5|mainBoardPWMOutputSelector",
	"3.11":   "Flasher 4B|PWM Mid Power|Main Board|JP11-7|mainBoardPWMOutputSelector",
	"3.12":   "Flasher 5R|PWM Mid Power|Main Board|JP11-9|mainBoardPWMOutputSelector",
	"3.13":   "Flasher 5G|PWM Mid Power|Main Board|JP11-11|mainBoardPWMOutputSelector",
	"3.14":   "Flasher 5B|PWM Mid Power|Main Board|JP11-13|mainBoardPWMOutputSelector",

	"3.16":   "LED 1R|PWM Low Power|Main Board|JP8-1|mainBoardPWMOutputSelector",
	"3.17":   "LED 1G|PWM Low Power|Main Board|JP8-3|mainBoardPWMOutputSelector",
	"3.18":   "LED 1B|PWM Low Power|Main Board|JP8-5|mainBoardPWMOutputSelector",
	"3.19":   "LED 2R|PWM Low Power|Main Board|JP8-7|mainBoardPWMOutputSelector",
	"3.20":   "LED 2G|PWM Low Power|Main Board|JP8-9|mainBoardPWMOutputSelector",
	"3.21":   "LED 2B|PWM Low Power|Main Board|JP8-11|mainBoardPWMOutputSelector",
	"3.22":   "LED 3R|PWM Low Power|Main Board|JP8-2|mainBoardPWMOutputSelector",
	"3.23":   "LED 3G|PWM Low Power|Main Board|JP8-4|mainBoardPWMOutputSelector",
	"3.24":   "LED 3B|PWM Low Power|Main Board|JP8-6|mainBoardPWMOutputSelector",
	"3.25":   "LED 4R|PWM Low Power|Main Board|JP8-8|mainBoardPWMOutputSelector",
	"3.26":   "LED 4G|PWM Low Power|Main Board|JP8-10|mainBoardPWMOutputSelector",
	"3.27":   "LED 4B|PWM Low Power|Main Board|JP8-12|mainBoardPWMOutputSelector",
	"3.28":   "LED 5R|PWM Low Power|Main Board|JP8-13|mainBoardPWMOutputSelector",
	"3.29":   "LED 5G|PWM Low Power|Main Board|JP8-15|mainBoardPWMOutputSelector",
	"3.30":   "LED 5B|PWM Low Power|Main Board|JP8-17|mainBoardPWMOutputSelector",
	"3.31":   "LED 6|PWM Low Power|Main Board|JP8-14|mainBoardPWMOutputSelector"
    };

    // add four power boards worth of outputs
    for (var i = 0 ; i < 128 ; ++i) {
	o["3." + (i+32)] =
	    "Output " + ((i%32) + 1)
	    + "|PWM Hi Power"
	    + "|Power Board " + (Math.floor(i/32) + 1)
	    + "|JP" + (Math.floor((i%32)/16)+5)+ "-" + ((i%16)+1)
	    + "|powerBoardOutputSelector";
    }

    // add four chime boards worth of outputs
    for (i = 0 ; i < 32 ; ++i) {
	o["4." + i] =
	    "Output " + ((i%8) + 1)
	    + "|Timed Digital"
	    + "|Chime Board " + (Math.floor(i/8) + 1)
	    + "|JP9-" + ((i%8)+1)
	    + "|chimeBoardOutputSelector";
    }

    // Table of all internal GPIO connections on the main expansion board.
    // These generally can't be used for any other purpose.
    var gInternal = {
	"PTC10":  "TLC5940 XLAT",
	"PTC6":   "TLC5940 SIN",
	"PTC5":   "TLC5940 SCLK",
	"PTC7":   "TLC5940 BLANK",
	"PTA1":   "TLC5940 GSCLK",
	"PTC9":   "IR OUT",
	"PTA13":  "IR IN",
	"PTD2":   "PSU2 STATUS",
	"PTD3":   "TV RELAY",
	"PTE0":   "PSU2 LATCH"
    };

    // Table of all external GPIO connections on the main expansion
    // board.  These KL25Z pins are connected more or less directly
    // to external headers on the board, so they can be re-purposed
    // (sometimes with restrictions) for other external uses.  For
    // example, if a plunger sensor isn't being used, all of the
    // plunger input pins can be used as button inputs instead.
    var gExternal = {
	"PTB0":   "Plunger 1|JP2-1",
	"PTE23":  "Cal Button|JP3-2",
	"PTE29":  "Cal Button LED|JP3-1",
	"PTE22":  "Plunger 4|JP2-4",
	"PTD5":   "Plunger 4|JP2-4",
	"PTE21":  "Plunger 3|JP2-3",
	"PTD0":   "Plunger 3|JP2-3",
	"PTE20":  "Plunger 2|JP2-8",
	"PTD4":   "74HC595 ENA|JP5-7",
	"PTA4":   "74HC595 SCLK|JP5-3",
	"PTA5":   "74HC595 SOUT|JP5-1",
	"PTA12":  "74HC595 LATCH|JP5-5",
	"PTC8":   "Knocker|JP9-1|Timed Digital",
	"PTC4":   "Extender 1|JP12-1",
	"PTC3":   "Extender 2|JP12-2",
	"PTC0":   "Extender 3|JP12-3",
	"PTA2":   "Extender 4|JP12-4",
    };

    // Build a combined table of the GPIO port aliases for internal and
    // external main board connections.
    var g = { };
    $.each(gInternal, function(k, v) { g[k] = v + "|Internal"; });
    $.each(gExternal, function(k, v) { g[k] = v.split("|").slice(0, 2).join("|"); });

    // Add GPIO aliases for all of the buttons
    $.each(expansionBoardFactoryConfig.buttons, function(k, v) {
	g[v.pin] = "Button " + k + "|Digital In|Main Board|JP1-" + k + "|mainBoardInputSelector";
    });

    // Add all of the external ports as output aliases.
    $.each(gExternal, function(k, v)
    {
	// break v into fields - Descriptive Name, Jumper, [output type description]
	v = v.split("|");

	// if it's a PWM-capable port, add a PWM output type for it
	var gp = gpioPinsByName[k] || { };
	if (gp.pwm)
	    o["1." + k] = [v[0], v[2] || "PWM GPIO", "Main Board", v[1], "mainBoardPWMOutputSelector"].join("|");

	// add a Digital Out type for it
	o["2." + k] = [v[0], v[2] || "Digital GPIO", "Main Board", v[1], "mainBoardDigitalOutputSelector"].join("|");
    });

    // remember these
    expOutPortAlias = o;
    expGpioPortAlias = g;
})();

$("input:radio[name=hardwareType]").change(function(ev)
{
    // check which hardware configuration is now selected
    var d = $("#expansionBoardOptions");
    var v = $("input:radio[name=hardwareType]:checked").val();
    var fromUI = !!ev.originalEvent;

    // show or hide sub-option sections as appropriate
    slideToggle(d, v == 1, 250, fromUI);	// type 1 = expansion boards

    // set up defaults for the new configuration
    switch (+v)
    {
    case 1:
	// Pinscape Expansion Boards, first release

	// use the expansion board output port aliases
	outPortAlias = expOutPortAlias;
	gpioPortAlias = expGpioPortAlias;

	// if the selection was made from the UI, apply the factory defaults
	if (fromUI)
	    configToUI(expansionBoardFactoryConfig, ConfigSource.Factory);

	// hide KL25Z pin assignments by default
	$("#ckExpBoardShowPins").prop("checked", false);
	break;

    default:
	// plain KL25Z or unknown

	// use hardware pin names for the output ports (no board aliases)
	outPortAlias = { };
	gpioPortAlias = { };

	// set factory defaults if the change came from the UI
	if (fromUI)
	    configToUI(standaloneFactoryConfig, ConfigSource.Factory);
	break;
    }

    // show/hide items globally according to the type
    $(".expBoardOnly").css("display", v == 1 ? "" : "none");
    $(".expBoardExclude").css("display", v == 1 ? "none" : "");

    // note the new type
    prvHardwareType = v;

    // update pin displays - this shows the pin selectors in standalone
    // mode, and hides them in expansion board mode, except when the "show
    // pins anyway" box is checked
    updatePinVisibility();

    // If the change came from a UI event, reset plunger pin assignments
    // for the new factory defaults.  Pass -1 for the previous type, since
    // the previous type is irrelevant: it's the pin wiring that's changing,
    // not the plunger type, so we need to reassign the pins no matter what
    // type is selected.
    if (fromUI)
	setPlungerPinFactoryDefaults(-1);

    // update pin warnings
    updatePinWarnings();
    
});

// "Show pin assignments" box - expansion board option.  By default, when
// this box is not checked and the expansion board configuration is active.
// All .expBoardPin elements are hidden - these are elements containing
// selectors for KL25Z pins wired to specific functions on the expansion
// boards.  .expBoardAlt elements are the converse - these show alternative
// text in expansion board mode, which can be used to fill in gaps left
// when the pin selections are missing.
$("#ckExpBoardShowPins").change(function() { updatePinVisibility(); });

function updatePinVisibility()
{
    // get the hardware mode
    switch (+$("input:radio[name=hardwareType]:checked").val())
    {
    case 0:
    default:
	// standalone mode/unknown - show pin selectors, hide special
	// expansion board alternate text
	$(".expBoardPin").show();
	$(".expBoardAlt").hide();
	break;

    case 1:
	// expansion board mode - show the expansion board alternate text,
	// and hide the regular pin selectors, *unless* the "show pins anyway"
	// box is checked
	$(".expBoardPin").toggle(!!$("#ckExpBoardShowPins").prop("checked"));
	$(".expBoardAlt").show();
	break;
    }
}

$("#numMainBoards,#numPowerBoards,#numChimeBoards").change(function()
{
    // make sure we have a valid number
    var v = $(this).val().trim();
    if (!/^\d+$/.test(v))
	$(this).val($(this).data("oldVal"));

    // adjust the peripheral chip configuration
    expBoardAdjustChips();
});

// adjust the number of peripheral chips to match the expansion board setup
function expBoardAdjustChips()
{
    // adjust the TLC5940 count: 2 per main board + 2 per power board
    $("#tlc_nchips").val(2*$("#numMainBoards").val() + 2*$("#numPowerBoards").val()).change();

    // adjust the 74HC595 count: 1 per chime board
    $("#hc595_nchips").val($("#numChimeBoards").val()).change();
}

      </script>

   <!--  USB ID  ------------------------------------------------------------->
   <hr>
   <div>
      <div>
	 <img src="usbident.png" class="sectionIcon">
	 <b>USB Identification.</b>  This is how the KL25Z identifies itself to
	 Windows through the USB port.
      </div>

      <div>
	 <select id="popUsbID" style="margin-right: 2em;">
	    <option value="FAFA00F0">LedWiz Unit 1</option>
	    <option value="FAFA00F1">LedWiz Unit 2</option>
	    <option value="FAFA00F2">LedWiz Unit 3</option>
	    <option value="FAFA00F3">LedWiz Unit 4</option>
	    <option value="FAFA00F4">LedWiz Unit 5</option>
	    <option value="FAFA00F5">LedWiz Unit 6</option>
	    <option value="FAFA00F6">LedWiz Unit 7</option>
	    <option value="FAFA00F7">LedWiz Unit 8</option>
	    <option value="FAFA00F8">LedWiz Unit 9</option>
	    <option value="FAFA00F9">LedWiz Unit 10</option>
	    <option value="FAFA00FA">LedWiz Unit 11</option>
	    <option value="FAFA00FB">LedWiz Unit 12</option>
	    <option value="FAFA00FC">LedWiz Unit 13</option>
	    <option value="FAFA00FD">LedWiz Unit 14</option>
	    <option value="FAFA00FE">LedWiz Unit 15</option>
	    <option value="FAFA00FF">LedWiz Unit 16</option>
	    <option value="1209EAEA">Pinscape ID</option>
	    <option value="00000000">Custom</option>
	 </select>

	 <span id="usbCustomFields">
	    Vendor ID: <input type="text" size=4 id="txtUsbVendor">
	    Product ID: <input type="text" size=4 id="txtUsbProduct">
	 </span>
	 <span id="usbInfoFields">
	 </span>

      </div>

      <div>
	 <ul>
	    <li>If you have a <b>real</b> LedWiz unit in your
	    system, choose <b>LedWiz Unit 8</b> for your first Pinscape
	    unit, 9 for the second, etc.

	    <li>If you <b>don't</b> have any real LedWiz units, choose
	    <b>LedWiz Unit 1</b> for the first unit, 2 for the second, etc.
	 </ul>

	 <a href="#" class="shower">I want more details!</a>
	 <div class="hider">
	    <ul>
	       <li><b>For LedWiz compatibility</b>, choose an LedWiz unit number.
	       LedWiz compatibility lets older programs, like Future Pinball, 
	       control outputs through this Pinscape unit.

	       <li>LedWiz unit numbers <b>must be unique</b>.
	       Be sure to choose an ID that isn't used by your real LedWiz, or by another
	       Pinscape controller.
	       Programs on the PC use the unit number to tell the devices apart, so each
	       device needs a different number.

	       <li>If you have Windows device driver conflicts using the LedWiz IDs,
	       you can try the Pinscape ID.  This is a USB ID registered to
	       Pinscape, so it should be free of conflicts with all other products.
	       However, <b>using this ID will forfeit LedWiz compatibility.</b>  This
	       means that older software like Future Pinball won't be able to access
	       the output controller features.  Newer software based on DOF R3
	       <b>will</b> still be able to take full advantage of the output features.
	       This includes Visual Pinball and PinballX.  And the input features will still
	       work for everyone.

	       <li>The Custom ID option is only there for techies doing something
	       tricky.  Don't use it unless you have a good reason.  Using a
	       custom ID will make the output features unreachable even from DOF.
	       (The input features will still work, though.)
	    </ul>
	 </div>
      </div>
   </div>

   <script>
$("#popUsbID").change(function() {
    var v = $(this).val() || "";
    var vendor = v.substr(0, 4);
    var product = v.substr(4);
    $("#txtUsbVendor").val(vendor);
    $("#txtUsbProduct").val(product);

    // fill in the info fields
    $("#usbInfoFields").text("(USB Vendor ID " + vendor + ", Product " + product + ")");

    // show the custom ID fields if and only if the custom item is selected
    var custom = ($("#popUsbID option:selected").text() == "Custom");
    $("#usbCustomFields").css("display", custom ? "inline" : "none");
    $("#usbInfoFields").css("display", custom ? "none" : "inline");
});
$("#txtUsbVendor, #txtUsbProduct").change(function() {
    // normalize the updated value by parsing it as a hex number and then
    // formatting back into our standard format
    $(this).val(hex4(parseInt($(this).val(), 16)));

    // set the popup value
    var pop = $("#popUsbID");
    var newval = $("#txtUsbVendor").val() + $("#txtUsbProduct").val();
    ensureUsbId(newval);
    pop.val(newval).change();
});

// ensure that a USB ID is in the popup list, setting the "custom" entry if required
function ensureUsbId(val)
{
    // search the list
    var found = false;
    var pop = $("#popUsbID");
    pop.children().each(function() {
	if ($(this).val() == val) {
	    found = true;
	    return false;
	}
    });

    // if we didn't find it, set the custom element to the new value
    if (!found)
	pop.children().last().val(val);
}

   </script>

   <!-- Pinscape ID  ------------------------------------------------------->
   <hr>

   <div>
      <img src="pinscapeID.png" class="sectionIcon">
      <b>Pinscape ID.</b>  This is a <b>separate</b> ID from the LedWiz
      unit number.  DOF R3 and the <a class="dofconfigtool">
	 DOF Config Tool</a> use this ID to identify the unit.
      <b>Set this to 1 for your first unit, 2 for the second</b>, and so on.
      <p>
      This is completely unrelated to the LedWiz unit number, so it doesn't need
      to match that, and by the same token doesn't need to be different.
      </p>

      <div>
	 <select id="popPinscapeID" style="margin-right: 2em;">
	    <option value="1">Pinscape Unit 1</option>
	    <option value="2">Pinscape Unit 2</option>
	    <option value="3">Pinscape Unit 3</option>
	    <option value="4">Pinscape Unit 4</option>
	    <option value="5">Pinscape Unit 5</option>
	    <option value="6">Pinscape Unit 6</option>
	    <option value="7">Pinscape Unit 7</option>
	    <option value="8">Pinscape Unit 8</option>
	    <option value="9">Pinscape Unit 9</option>
	    <option value="10">Pinscape Unit 10</option>
	    <option value="11">Pinscape Unit 11</option>
	    <option value="12">Pinscape Unit 12</option>
	    <option value="13">Pinscape Unit 13</option>
	    <option value="14">Pinscape Unit 14</option>
	    <option value="15">Pinscape Unit 15</option>
	    <option value="16">Pinscape Unit 16</option>
	 </select>
      </div>

   </div>


   <!-- reboot on disconnect ----------------------------------------------->
   <hr>

   <div>
      <img src="disconnect.png" class="sectionIcon">
      <b>Reset on disconnect.</b>  If the USB connection is broken, and
      can't be re-established within a time limit, the KL25Z can
      automatically reset itself as an attempt to fix whatever's wrong.
      Select the time interval (in seconds) before this happens.

      <div>
	 <label><input type="checkbox" id="ckRebootEnable">Enabled</label>
	 <div id="rebootOptions">	
	    Time before reboot (seconds):
	    <input type="text" id="txtRebootTime" size=4 style="margin-left: 1em;">
	 </div>
      </div>

      <div>
	 <a href="#" class="shower">Details</a>
	 <div class="hider">
	    <b>Details</b><br>
	    On some systems, the KL25Z has trouble re-establishing a broken
	    USB connection, such as after rebooting or power-cycling the PC.
	    This can usually be solved by resetting the KL25Z.  If you set
	    this option, the KL25Z will reset itself automatically when it
	    detects a broken connection and can't reconnect within the specified
	    time limit.  The delay is there to avoid unnecessary resets when
	    the connection only glitches momentarily.  The recommended setting
	    is 10 seconds.
	 </div>
      </div>
   </div>

   <script>
$("#ckRebootEnable").change(function(ev) {
    var show = $(this).prop("checked");
    slideToggle($("#rebootOptions"), show, 250, !!ev.originalEvent);
    if (show && $("#txtRebootTime").val() == 0)
	$("#txtRebootTime").val(10);
});

$("#txtRebootTime").change(function() {
    var val = $(this).val().trim();
    if (!/^\d+$/.test(val))
	$(this).val(+config.disconnectRebootTime);
    else if (+val < 1 && $("#ckRebootEnable").prop("checked"))
	$(this).val(1);
    else if (+val < 0)
	$(this).val(0);
    else if (+val > 255)
	$(this).val(255);
    else if (val != +val)
	$(this).val(+val);
});
   </script>


   <!-- TV On button ------------------------------------------------------->
   <hr>
   <div>
      <img src="tvon.png" class="sectionIcon">
      <b>TV ON switch.</b>  If one or more of your monitors needs to be turned
      on manually every time you power up your cabinet, you can use this feature
      to switch them on automatically.  See the Build Guide for wiring instructions.
      <i>Coming soon: Turn TVs on through an IR remote control transmitter.</i>

      <div>
	 <div>
	    <label><input id="tvOnEnabled" type="checkbox">Enabled</label>
	 </div>
	 <div id="tvOnPins">
	    <table class="inputs">
	       <tr class="expBoardPin">
		  <td class="pinlabel">Power status input:</td>
		  <td>
		     <span class="pinselect" id="tvStatus"
		       data-cfg="TVon.statusPin" data-gpiotype="dig-in extern"
		       data-desc="TV ON Power Status Input" data-default="PTD2">
		     </span>
		  </td>
	       </tr>
	       <tr class="expBoardPin">
		  <td class="pinlabel">Status latch output:</td>
		  <td>
		     <span class="pinselect" id="tvLatch"
		       data-cfg="TVon.latchPin" data-gpiotype="dig-out extern"
		       data-desc="TV ON Status Latch" data-default="PTE0">
		     </span>
		  </td>
	       </tr>
	       <tr class="expBoardPin">
		  <td class="pinlabel">Relay output:</td>
		  <td>
		     <span class="pinselect" id="tvRelay"
		       data-cfg="TVon.relayPin" data-gpiotype="dig-out extern"
		       data-desc="TV ON Relay Output" data-default="PTD3">
		     </span>
		  </td>
	       </tr>
	       <tr>
		  <td>Startup delay time (seconds):</td>
		  <td><input type="text" id="tvDelay" size=4></td>
		  <td>This is how long to wait after power-on before pulsing the relay</td>
	       </tr>
	    </table>
	 </div>
      </div>
   </div>

   <script>
$("#tvOnEnabled").change(function(ev) {
    showTvOn($(this).prop("checked"), !!ev.originalEvent);
});
function showTvOn(show, scroll)
{
    // show the pin selectors
    slideToggle($("#tvOnPins"), show, 250, scroll);
    $("#tvOnPins .pinselect").data("active", show);

    // if it's enabled, and we don't have pin selections, set the defaults
    if (show) {
	function def(id, def) {
	    var ctl = $(id);
	    if (ctl.val() == "Not Connected")
		ctl.val(def).change();
	}
	def("#tvStatus .pinval", "PTD2");
	def("#tvLatch .pinval",  "PTE0");
	def("#tvRelay .pinval", "PTD3");
    }

    // update pin warnings
    updatePinWarnings();
}
   </script>


   <!-- joystick enable ---------------------------------------------------->
   <hr>

   <div>
      <img src="joystick.png" class="sectionIcon">
      <b>Joystick input.</b>  The controller acts like a Windows USB Joystick
      in order to send the plunger position, accelerometer readings (for nudging),
      and button inputs to the PC.  You can disable these inputs if desired.

      <div>
	 <label><input id="ckJoystick" type="checkbox"> Enable joystick input</label>
      </div>

      <div>
	 <a href="#" class="shower">Why would I want to disable this?</a>
	 <div class="hider">
	    <b>Why would I want to disable this?</b><br>
	    By default, each Pinscape unit reports its accelerometer readings
	    to the PC via the joystick interface.  If you have more than one
	    unit installed, that means you'll have more than one set of these
	    reports coming in.  The extra reports can confuse some pinball
	    software, and can also affect system performance.  This option
	    lets you disable the extra reports from the secondary units.  If
	    you have a plunger attached to one of the units, you should consider
	    that one to be your primary unit and leave its joystick interface
	    enabled.  You should disable the joystick interface on any other units.
	 </div>
      </div>

   </div>


   <!-- accelerometer orientation ------------------------------------------>
   <hr>

   <div>
      <img src="orientation.png" class="sectionIcon">
      <b>Accelerometer orientation.</b>  If you're using the accelerometer
      (for nudge sensing), the software needs to know how the KL25Z is oriented
      in the cabinet so that it can report motion in the right direction.  Install
      the KL25Z in one of the orientations shown below, level with the floor of
      the cabinet, with the chips and LEDs facing up.

      <div>

	 <table class="radio">
	    <tr style="margin: auto;">
	       <td>
		  <label>
		     <img src="accel-front.png"><br>
		     <input type="radio" name="accel" value="0">
		     Ports facing front
		  </label>
	       </td>
	       <td>
		  <label>
		     <img src="accel-left.png"><br>
		     <input type="radio" name="accel" value="1">
		     Ports facing left
		  </label>
	       </td>
	       <td>
		  <label>
		     <img src="accel-right.png"><br>
		     <input type="radio" name="accel" value="2">
		     Ports facing right
		  </label>
	       </td>
	       <td>
		  <label>
		     <img src="accel-rear.png"><br>
		     <input type="radio" name="accel" value="3">
		     Ports facing rear
		  </label>
	       </td>
	    </tr>
	 </table>

      </div>
   </div>

   <script>
   </script>



   <!-- plunger ------------------------------------------------------------>
   <hr>
   <div>
      <img src="plungerSection.png" class="sectionIcon">
      <b>Plunger sensor setup</b>

      <div>
	 Sensor type:
	 <select id="plungerType" style="margin-left: 1em;">
	    <option value="0">None</option>
	    <option value="1">TSL1410R</option>
	    <option value="3">TSL1412R</option>
	    <option value="5">Potentiometer</option>
	 </select>
	 <span style="margin-left: 2em;" id="plungerSensorButton">
	    <a href="#" id="btnPlungerCal" class="button">Live Sensor View</a>
	 </span>

      </div>

      <div>
	 <div id="plungerPinsTSL">
	    <div class="expBoardPin">
	       <b>TSL1410R/1412R pin assignments:</b>
	       <div class="indented">
		  <table class="inputs">
		     <tr>
			<td class="pinlabel">SI (serial data):</td>
			<td>
			   <span class="pinselect" id="tsl_si"
			      data-cfg="plungerPins.a" data-gpiotype="dig-out extern"
			     data-desc="Plunger Sensor SI" data-default="PTE20">
			   </span>
			</td>
		     </tr>
		     <tr>
			<td class="pinlabel">CLK (serial clock):</td>
			<td>
			   <span class="pinselect" id="tsl_clk"
			     data-cfg="plungerPins.b" data-gpiotype="dig-out extern"
			     data-desc="Plunger Sensor CLK" data-default="PTE21">
			   </span>
			</td>
		     </tr>
		     <tr>
			<td class="pinlabel">AO (analog data):</td>
			<td>
			   <span class="pinselect" id="tsl_ao"
			     data-cfg="plungerPins.c" data-gpiotype="adc"
			     data-desc="Plunger Sensor AO" data-default="PTB0">
			   </span>
			</td>
			<td>Requires an ADC-capable (analog in) pin</td>
		     </tr>
		  </table>
	       </div>
	    </div>
	    <div class="expBoardAlt">
	       Connect the sensor to the PLUNGER connector (JP2) on the main interface board:
	       <ul>
		  <li>Sensor AO1/AO2 to pin 1
		  <li>Sensor CLK to pin 3
		  <li>Sensor VDD to pin 5
		  <li>Sensor VPP (GND) to pin 6
		  <li>Sensor SI to pin 8
	       </ul>
	    </div>
	 </div>

	 <div id="plungerPinsPot">
	    <div class="expBoardPin">
	       <b>Potentiometer pin assignments:</b>
	       <div class="indented">
		  <table class="inputs">
		     <tr>
			<td class="pinlabel">Wiper:</td>
			<td>
			   <span class="pinselect" id="pot_ao"
			      data-cfg="plungerPins.a" data-gpiotype="adc"
			     data-desc="Plunger Sensor AO" data-default="PTB0">
			   </span>
			</td>
			<td>Requires an ADC (analog in) pin</td>
		     </tr>
		  </table>
	       </div>
	    </div>
	    <div class="expBoardAlt">
	       Connect the sensor to the PLUNGER connector (JP2) on the main interface board:
	       <ul>
		  <li>Pot wiper to pin 1
		  <li>One fixed-resistor end to pin 5
		  <li>Other fixed-resistor end to pin 6
	       </ul>
	    </div>
	    <div>
	       Note: this sensor type setting can be used with other sensors
	       that represents the plunger position as an analog voltage level,
	       such as an LVDT or analog IR distance finder.  Connect the sensor's
	       analog output pin to JP2 pin 1.  Connect sensor power to pin 5 and
	       GND to pin 6.
	    </div>
	 </div>
      </div>
   </div>

   <script>
var prvPlungerType = -1;
var plungerTypeValid = false;
$("#plungerType").change(function(ev)
{
    // deactivate all pin groups until we know which ones we're activating
    $("#plungerPinsTSL .pinselect, #plungerPinsPot .pinselect").data("active", false);

    // show or hide the ZB Launch Ball and calibration button sections
    var newvis = ($(this).val() != 0);
    slideToggle($("#zbGroup, #calBtnGroup"), newvis, 250, false);
    slideToggle($("#zbHidden, #calBtnHidden"), !newvis, 250, false);

    // show or hide the sensor viewer button
    $("#plungerSensorButton").css("display", newvis ? "" : "none");

    // presume we have a valid plunger type
    plungerTypeValid = true;

    // show the appropriate section
    var all = $("#plungerPinsTSL, #plungerPinsPot");
    var typ = +$(this).val();
    switch (typ)
    {
    case 0:
    default:
	// no sensor - hide all
	slideClosed(all, 250);
	plungerTypeValid = false;
	break;
    
    case 1:
    case 3:
	// TSL141xR sensors
	slideRadio($("#plungerPinsTSL"), all, 250, false);
	$("#plungerPinsTSL .pinselect").data("active", true);
	break;

    case 5:
	// Potentiometer
	slideRadio($("#plungerPinsPot"), all, 250, false);
	$("#plungerPinsPot .pinselect").data("active", true);
	break;
    }

    // if this was a UI event, reset the factory defaults for the pin configuration
    if (!!ev.originalEvent)
	setPlungerPinFactoryDefaults(prvPlungerType);

    // update the calibration button pin active/inactive status
    updateCalButtonStatus();

    // update pin warning indicators for any active status change
    updatePinWarnings();

    // remember the new type
    prvPlungerType = typ;
});

// set the factory defaults for the plunger pins
function setPlungerPinFactoryDefaults(prvPlungerType)
{
    switch (+$("#plungerType").val())
    {
    case 1:
    case 3:
	// TSL1410R / TSL1412R.  Reset pins only if we're not switching between
	// these two subtypes.  The 1410R and 1412R use identical pin wiring, so
	// switching from one type to the other doesn't require any pin changes.
	if (prvPlungerType != 1 && prvPlungerType != 3) {
	    $("#tsl_si .pinval").val("PTE20");
	    $("#tsl_clk .pinval").val("PTE21");
	    $("#tsl_ao .pinval").val("PTB0");
	}
	break;

    case 5:
	// Potentiometer
	$("#pot_ao .pinval").val("PTB0");
	break;
    }
}

$("#plungerSensorButton").click(function(ev) {
    // don't actually open the link
    ev.preventDefault();
    
    // check for pin changes
    function pinChanges()
    {
	switch ($("#plungerType").val())
	{
	case "1":
	case "3":
	    return $("#tsl_si .pinval").val() != config.plungerPins.a
		|| $("#tsl_clk .pinval").val() != config.plungerPins.b
		|| $("#tsl_ao .pinval").val() != config.plungerPins.c;

	case "5":
	    return $("#pot_ao").text() != config.plungerPins.a;

	default:
	    return false;
	}
    }
    
    // make sure the config values haven't changed
    if ($("#plungerType").val() != config.plungerType || pinChanges())
    {
	if (!window.external.YesNoDialog(
	    "You've made changes to the sensor setup that you haven't "
	    + "programmed into the KL25Z yet. The live viewer will reflect "
	    + "the current device settings, not your new unsaved changes. "
	    + "If you want to view the sensor using the new settings, click "
	    + "\"Program KL25Z\" before proceeding to the sensor viewer."
	    + "\r\n\r\n"
	    + "Do you want to open the sensor viewer anyway?"))
	    return;
    }
	
    // show the sensor dialog
    window.external.ShowPlungerWindow(CPUID);
});
   </script>

   <!-- Plunger calibration button ----------------------------------------->
   <hr>
   <div>
      <img src="calbtn.png" class="sectionIcon">
      <b>Plunger calibration button.</b>  If you wish, you can install a 
      pushbutton in your cabinet to activate plunger calibration mode.
      This is optional, since you can also run the calibration from this
      setup program.  See the Build Guide for wiring instructions.

      <div id="calBtnGroup">
	 <table class="inputs">
	    <tr>
	       <td class="pinlabel">Button input:</td>
	       <td>
		  <span class="pinselect expBoardPin" id="calBtn"
		    data-cfg="calButtonPins.button" data-gpiotype="dig-in extern"
		    data-desc="Plunger Calibration Button" data-default="PTE29">
		  </span>
		  <label><input type="checkbox" id="calBtnEna">Enabled</label>
	       </td>
	    </tr>
	    <tr>
	       <td class="pinlabel">Indicator lamp output:</td>
	       <td>
		  <span class="pinselect expBoardPin" id="calLED"
		    data-cfg="calButtonPins.led" data-gpiotype="dig-out extern"
		    data-desc="Plunger Calibration Lamp" data-default="PTE23">
		  </span>
		  <label><input type="checkbox" id="calLEDEna">Enabled</label>
	       </td>
	    </tr>
	 </table>
      </div>
      <div id="calBtnHidden" style="height: 0px; overflow: hidden;">
	 (The calibration button is only applicable when you have a plunger
	 sensor installed.)
      </div>
      <div class="expBoardAlt">
	 Connect the calibration button to the CAL BTN connector
	 (JP3) on the main interface board.
      </div>
   </div>

   <script>

$("#calBtnEna, #calLEDEna").change(function(ev) {
    updateCalButtonStatus();
    updatePinWarnings();
});
function updateCalButtonStatus()
{
    // the calibration buttons pins are active if there's a valid plunger
    // type and the corresponding feature is enabled
    $("#calBtn").data("active", plungerTypeValid && $("#calBtnEna").prop("checked"));
    $("#calLED").data("active", plungerTypeValid && $("#calLEDEna").prop("checked"));
}


   </script>


   <!-- ZB Launch Ball ----------------------------------------------------->
   <hr>
   <div>
      <a name="zblaunch"></a>
      <img src="ZBLaunch.png" class="sectionIcon">
      <b>ZB Launch Ball setup.</b>  You can set up your mechanical plunger
      to act as a "virtual" Launch Ball button for tables that use a button
      instead of a plunger.
      <a href="#" class="shower">Details</a>

      <div class="hider">
	 This feature lets you use a mechanical plunger in lieu of a Launch Ball button,
	 for tables that need it, in case you don't want to install a separate physical
	 Launch button.  When this is enabled, you treat the plunger knob like a button:
	 push it a little forward to "click" the button.  You can also pull back and
	 release the plunger to simulate a brief button push.

	 <ul>
	    <li>The feature is only activated when a non-plunger table is running
	    on the PC.  We can tell because Visual Pinball turns on the <b>output port</b>
	    selected below when such a table is loaded.

	    <li>The port you designate can be any type, including a "virtual" port that
	    isn't connected to any physical output wiring.

	    <li><b>In the <a class="dofconfigtool">DOF Config Tool</a></b>, be sure to
	    set the port number you designate here as your <b>ZB Launch Ball</b> port.
	    That connects everything on the PC to the right port.

	    <li>Select the keyboard key or joystick button to send to the PC when
	    the plunger triggers a launch.  This is usually the Enter key, because
	    that's what almost all PC pinball software uses.

	    <li>The <b>push distance</b> sets the sensitivity.  When you push the
	    plunger forward by this amount or more (and the feature has been activated by
	    the output port), the controller simulates pressing the Launch Ball button.
	    Set the distance far enough that it doesn't trip randomly, but short enough
	    that you don't have to push too hard.  We recommend about .06 to .08 inches.
	 </ul>
      </div>

      <div id="zbHidden" style="overflow: hidden; height: 0px;">
	 (The ZB Launch Ball feature only applies when you have a
	 plunger sensor installed.)
      </div>

      <div id="zbGroup">
	 <div>
	    <label><input type="checkbox" id="zbEnabled">Enabled</label>
	 </div>
	 
	 <div class="indented" id="zbFields">
	    <table class="inputs">
	       <tr>
		  <td>Output port number:</td>
		  <td><input id="zbPort" size=5></td>
		  <td><b>Important!</b> Set this port to "ZB Launch Ball" in the
		     <a class="dofconfigtool">DOF Config Tool</td>
	       </tr>
	       <tr class="buttonRow">
		  <td class="keylabel">Key/button:</td>
		  <td>
		     <span class="keymapping" id="keymapZB" idx="1000">
			<span class="keyname"></span>
			<span class="keycode"></span>
			<span class="keytype"></span>
		     </span>
		  </td>
		  <td>Most PC pinball software uses the Enter key for ball launch</td>
	       </tr>
	       <tr>
		  <td>Push distance (inches):</td>
		  <td><input id="zbDistance" size=5></td>
		  <td>Recommended value is 0.063 (about 1/16")
	       </tr>
	    </table>
	 </div>
      </div>
	 
   </div>

   <script>

// show/hide the section on changing the Enable checkbox
$("#zbEnabled").change(function() {
    var ena = $(this).prop("checked");
    slideToggle($("#zbFields"), ena, 250, false);
    if (!ena)
	$("#zbPort").val("0").change();
    else if (+$("#zbPort").val() == 0)
	$("#zbPort").val("1").change();
});

$("#zbPort").change(function(ev) {
    $("#outputTab .zbRemark").remove();
    var row = +$(this).val();
    if ($("#zbEnabled").prop("checked") && row != 0) {
	var oprow = $("#outputTab .outPortRow").eq(row-1);
	if (oprow.find(".pintype").val() == 0 && !loadingConfig) {
	    if (window.external.YesNoDialog(
		"The port you selected isn't currently configured. Would "
		+ "you like to add it as a \"virtual\" port?  This will "
		+ "ensure that the PC will be able to address it properly."))
		appendOutputs(row);
	    else
		window.external.ShowAdviceDialog(
		    "InvalidZBPortWarning",
		    "Okay, no port was added. Note that the PC won't be able to "
		    + "activate the ZB Launch feature unless you assign this to a "
		    + "valid port that exists in the output list. Please be sure "
		    + "to add the port or change the number here before finalizing "
		    + "your settings.");
	}
	oprow.find(".outPortRemarks").append(
	    "<span class=\"zbRemark\" title=\"This is the ZB Launch Ball output port\">"
	    + "<a href=\"#zblaunch\">"
	    + "<img src=\"zbLaunchSmall.png\">"
	    + "</a>"
	    + "</span>");
    }
});

   </script>


   <!-- Button input setup ---------------------------------------------->
   <hr>
   <div>
      <a name="buttonSection"></a>
      <img src="buttonSection.png" class="sectionIcon">
      <b>Button inputs.</b>  You can use the KL25Z as a key encoder to
      connect pinball-style buttons on your cabinet to the PC.  Set up
      the wiring connections and key assignments below.  Each input can
      be mapped as a joystick button or keyboard key.  Click an input
      pin or key assignment to change a setting.

      <div>
	 <img src="ShiftButton.png" style="vertical-align: middle;">
	 <b>Shift button number:</b> <input type="text" id="shiftButton" size="4">
	 <a href="#" class="shower">What's this?</a>
	 <div class="hider">You can designate one button as the <b>local
	    Shift button</b>.  When you hold down this button, pressing any other
	    button will use the "shifted" key assignment for the other
	    button.  (If the other button <i>doesn't</i> have a shifted
	    meaning assigned, its ordinary un-shifted meaning is used.)
	    This lets you give every button a second meaning,
	    expanding the number of controls without adding more physical
	    buttons.  Select the button number to use as the Shift button
	    if desired, or set it to zero to disable this feature.
	    This is unrelated to the PC keyboard Left Shift and Right Shift
	    keys, which you can assign to buttons of your choice like any
	    other keyboard keys.  Note that the shift button itself can't
	    have a shifted meaning assigned, as there'd be no way to activate it.
	 </div>
      </div>

      <div>
	 <a href="#" id="setAllJoystick">Set standard joystick buttons</a>
	 | <a href="#" id="setAllKB">Set standard keyboard keys</a>
	 | <a href="#" class="btnHelp">View standard key assignments</a>
      </div>

      <div>
	 <table id="buttonTab">
	 </table>
      </div>
      <div id="buttonTabStretchNote">
	 <i><b>Note:</b> the firmware currently installed supports up to
	    <span id="buttonTabMaxNote">0</span> physical buttons.  New rows
	    will be added to the table above as you fill in more values, up
	    to the limit.</i>
      </div>
   </div>

   <script type="text/javascript" src="keycaps.js"></script>

   <script>

// Button row updater.  We group updates to avoid updating
// the same row repeatedly when performing a task that affects
// multiple rows (config loading, changing the night mode
// button, changing the shift button).
var ButtonTabUpdate = {
    touch: function(item) {  // item can be a button row element (TR) or any element within a row
	if (!item.is("tr"))
	    item = item.parents("tr.buttonRow");
	this.pending[item.find(".keymapping").data("idx")] = item;
	if (!this.queued) {
	    var self = this;
	    setTimeout(function() { self.go(); }, 1);
	    this.queued = true;
	}
    },
    pending: { },
    queued: false,
    go: function() {
	$.each(this.pending, function(key, val) {
	    updateButtonRow(val);
	});
	stretchButtonTable();
	this.queued = false;
	this.pending = { };
    }
};

$("#shiftButton").change(function(ev)
{
    var n = $(this).val()
    $("#buttonTab tr").removeClass("shiftRow")
	 .find(".shiftCol span").attr("title", "Click here to make this the Local Shift Button");
    $("#buttonRow" + n).addClass("shiftRow")
	.find(".shiftCol span").attr("title", "This input is the Local Shift Button. Other "
			   + "buttons pushed while the Shift Button is held down use "
			   + "their shifted key codes.");

    ButtonTabUpdate.touch($("#buttonRow1"));
    showHideNightModeButtonShift();
    updateNightModeButton();
});

$("#setAllJoystick").click(function(ev)
{
    if (window.external.YesNoDialog(
	"This will replace your current key assignments in "
	+ "slots 1-24 with joystick buttons 1-24, respectively. "
	+ "Are you sure you want to replace all of these settings?"))
    {
	$("#buttonTab tr").each(function()
	{
	    var tr = $(this);
	    var keymapping = tr.find(".keymapping");
	    var idx = keymapping.data("idx");
	    if (idx >= 1 && idx <= 24)
	    {
		keymapping.children(".keytype").val(1).change();
		keymapping.children(".keycode").val(idx).change();
	    }
	});
    }
    ev.preventDefault();
    ev.stopPropagation();
});
$("#setAllKB").click(function(ev)
{
    if (window.external.YesNoDialog(
	"This will replace your current key assignments "
	+ "with the standard keyboard mappings for Visual "
	+ "Pinball.  Are you sure you want to proceed?"))
    {
	$("#buttonTab tr").each(function()
	{
	    var tr = $(this);
	    var keymapping = tr.find(".keymapping");
	    var idx = keymapping.data("idx");
	    var defs = expansionBoardFactoryConfig.buttons;
	    if (defs[idx])
	    {
		keymapping.children(".keytype").val(defs[idx].keytype).change();
		keymapping.children(".keycode").val(defs[idx].keycode).change();
	    }
	});
    }
    ev.preventDefault();
    ev.stopPropagation();
});

// Map from the modifier key codes to keycaps entries.  The modifier
// keys are encoded with a bit mask, per the usual USB keyboard
// conventions.  Each modifier is represented by one bit in the mask.
// This maps from the individual bits to the corresponding keycaps
// indices.
var shiftKeyMap = {
    0x01: 0xE0,		// left control
    0x02: 0xE1,		// left shift
    0x04: 0xE2,		// left alt
    0x08: 0xE3,		// left GUI
    0x10: 0xE4,		// right control
    0x20: 0xE5,		// right shift
    0x40: 0xE6,		// right alt
    0x80: 0xE7		// right GUI
};

// Standard VP key usage, indexed by "type.keyCodeInHex" (e.g., 2.1E = keyboard "1").
// We rebuild this during initialization to index in decimal (2.30 = "1").  Hex is
// more convenient for typing in the entries, while decimal is more convenient for
// looking them up.  We could probably just as well dispense with the "2." and 
// assume that only keyboard keys have standard VP usages, which is currently the
// case.  But we include the type code anyway for the sake of future-proofing, just
// in case VP ever adopts standard usages for other input methods (e.g., joystick
// buttons).
var vpUsage = {
    "2.1E": "Start Game",
    "2.1F": "Extra Ball (Buy-In)",
    "2.22": "Coin In",
    "2.21": "Coin In (second coin slot)",
    "2.23": "Coin In (fourth coin slot)",
    "2.28": "Plunger/Launch Ball",
    "2.29": "Exit to menu (PinballX/HyperPin front ends)",
    "2.14": "Quit to editor (within VP)",
    "2.E1": "Left Flipper",
    "2.E5": "Right Flipper",
    "2.E0": "Left MagnaSave",
    "2.E4": "Right MagnaSave",
    "2.17": "Mechanical Tilt Bob",
    "2.4A": "Slam Tilt",
    "2.2C": "Forward Nudge",
    "2.1D": "Left Nudge",
    "2.38": "Right Nudge",
    "2.4D": "Open/Close Coin Door",
    "2.24": "Service Button \"Cancel/Exit\"",
    "2.25": "Service Button \"Down/-\"",
    "2.26": "Service Button \"Up/+\"",
    "2.27": "Service Button \"Enter\"",
    "2.2E": "VP Volume Down",
    "2.2D": "VP Volume Up"
};

function updateButtonRow(tr)
{
    // update the key caps
    var km = tr.find(".keymapping");
    if (km.length)
    {
	// update the displayed key caps
	km.each(function() { updateKeyCap($(this)); });

	// update the displayed usage 
	var usage = [];
	tr.find(".keymapping").each(function() {
	    var m = $(this);
	    usage.push(vpUsage[m.find(".keytype").val() + "." + (+m.find(".keycode").val())] || "-");
	});
	if ($("#shiftButton").val() == 0) usage.pop();	// remove the shifted key display if the shift button is disabled
	tr.find(".keyusage").text(usage.join("/"));

	// update the displayed flag icons
	var flags = +tr.find("input.keyflags").val();
	tr.find("td.keyflags img").each(function() {
	    var img = $(this);
	    var f = !!(flags & img.data("mask"));
	    img.attr("src", img.attr("src").replace(/On|Off/, f ? "On" : "Off"));
	});
    }
}

function updateKeyCap(km)
{
    km.removeClass("asNone asKey asShiftKey asMediaKey asJoystickButton");
    km.css("background-position", "");
    var typ = +km.children(".keytype").val();
    var code = +km.children(".keycode").val();
    var typemap = { 0: "asNone", 1: "asJoystickButton", 2: "asKey", 3: "asMediaKey" };
    km.addClass(typemap[typ] || "asNone");
    var wid = "auto", ht = "32px", lht = "32px";
    var txt = "", title = "";
    switch (typ)
    {
    case 0:
    default:
	title = "Pushing this button won't send any key press to the PC";
	wid = ht = "32px";
	break;

    case 1:
	txt = code;
	title = "Joystick Button " + code;
	wid = ht = "32px";
	lht = "28px";
	break;

    case 2:
    case 3:
	// get the key name
	var k = (typ == 2 ? keycaps[code] : mediaKeycaps[code]);
	title = k.name;

	// show the "alternate" image if defined, otherwise just use the name
	if (k.cx)
	{
	    wid = (k.cwid || 30) + "px";
	    ht = (k.cht || 31) + "px";
	    km.css("background-position", (-k.cx) + "px " + (-k.cy) + "px");
	}
	else if (k.x)
	{
	    wid = (k.wid || 30) + "px";
	    ht = (k.ht || 31) + "px";
	    km.css("background-position", (-k.x) + "px " + (-k.y) + "px");
	}
	else
	{
	    txt = k.name;
	    km.removeClass("asKey asMediaKey").addClass("asKeyName");
	}
	break;
    }
    km.attr("title", title).css({ width: wid, height: ht, lineHeight: lht }); // set lineHeight for vertical centering of .keyname label
    km.children(".keyname").text(txt);
}

// size the button table to display the number of buttons the firmware
// supports
var buttonTabMax = 0;
function sizeButtonTable(config)
{
    var count = 0;
    $.each(config.buttons, function(key) { if (/\d+/.test(key)) ++count; });
    $("#shiftButton, #nightModeButtonNo").spinner("option", "max", count);
    $("#buttonTabMaxNote").text(count);
    buttonTabMax = count;
    $("#buttonTab tr.buttonRow").each(function() {
	var tr = $(this);
	var keymapping = tr.find(".keymapping");
	var idx = keymapping.data("idx");
	var active = (idx <= count);
	tr.toggle(active);
	keymapping.data("outOfService", !active);
	tr.find(".pinselect").data("outOfService", !active);
    });
}

// Adjust the visibility of button table rows at the bottom.  We hide
// rows after the last completely unused row.
function stretchButtonTable()
{
    var last = 0;
    $("#buttonTab tr.buttonRow").each(function() {
	var tr = $(this);
	var km = tr.find(".keymapping");
	var idx = +km.data("idx");
	if (idx > buttonTabMax) return false;
	if (idx >= last)
	{
	    if (tr.find(".pinval").val() != "Not Connected")
		last = idx;
	    else if ($("#nightModeButtonNo").val() == idx)
		last = idx;
	    else
	    {
		km.each(function() {
		    if ($(this).find(".keytype").val() != 0) {
			last = idx;
			return false;
		    }
		});
	    }
	}
    });

    var sb = +$("#shiftButton").val();
    if (sb > last)
	last = sb;

    // show one blank row if we haven't maxed out the table
    if (last < buttonTabMax) ++last;

    $("#buttonTab tr.buttonRow").each(function() {
	$(this).toggle(+$(this).find(".keymapping").data("idx") <= last);
    });

    $("#buttonTabStretchNote").toggle(last < buttonTabMax);
}

// build the button table rows
$(function() {

    // reindex the vpUsage table by decimal key code
    var u = vpUsage;
    vpUsage = { };
    $.each(u, function(key, val) {
	if (/(\d+)\.(.+)/.test(key)) {
	    vpUsage[RegExp.$1 + "." + parseInt(RegExp.$2, 16)] = val;
	}
    });

    // Set the modifier key mapping for each modifier key in the key caps
    $.each(shiftKeyMap, function(k, v) { keycaps[v].modkey = k; });

    // Build the button table header
    var rows = [];
    rows.push("<tr>"
	      + "<th>No.</th>"
	      + "<th>Port</th>"
	      + "<th></th>"
	      + "<th>PC Input</th>"
	      + "<th>Shifted</th>"
	      + "<th style=\"padding: 0px; white-space: nowrap;\">Options [<a href=\"#\" id=\"pulseKeyHelp\">?</a>]</th>"
	      + "<th class=\"keyusage\" title=\"The standard meaning of the assigned key in Visual Pinball\">VP Usage</th>"
	      + "</tr>");

    // Build a <TR> for each button table row.  Start with more than we
    // need in the firmware - we'll hide extra rows after loading the
    // configuration, at which point we'll know how many rows we really
    // need.  It would be better if we populated the table dynamically
    // upon loading the config, but that would require a bunch of rework
    // thanks to early assumptions that we had a fixed number of rows
    // (versions of the firmware up until 11/2016 had a fixed size of
    // 32 keys in the firmware).  That rework is a bit tricky because
    // initialization is scattered, mostly thanks to to entanglements
    // with the pin selector dialogs.  Right now it seems cleaner to
    // just create "more than enough" rows and hide the ones we don't
    // need.  (This is never a good strategy in the long run; it's
    // the classic "who'd every need more than 640K?" fallacy all
    // over again.  But as long as we're on the KL25Z, we really
    // can't add infinite buttons anyway, since memory is already
    // very tight.)
    for (var i = 1 ; i <= 128 ; ++i)
    {
	rows.push("<tr class=\"buttonRow\" id=\"buttonRow" + i + "\" data-idx=\"" + i + "\">"
		  + "<td class=\"pinlabel keylabel\">" + i + "</td>"		   // button number			
		  + "<td>"
		  +   "<span class=\"pinselect withExpBoardAlias\" id=\"button" + i + "\" "    // input pin
		  +      "data-gpiotype=\"dig-in extern\" "
		  +      "data-cfg=\"buttons." + i + ".pin\" "
		  +      "data-desc=\"Button " + i + "\">"
		  +   "</span>"
		  + "</td>"
		  + "<td class=\"shiftCol\">"
		  +    "<span>"
		  +    "</span>"
		  + "</td>"
		  + "<td class=\"buttonCol primary\">"
		  +   "<span class=\"keymapping\" id=\"keymap" + i + "\" data-idx=\"" + i + "\">" // key mapping
		  +     "<span class=\"keyname\"></span>"
		  +     "<input class=\"keycode\" type=\"hidden\">"
		  +     "<input class=\"keytype\" type=\"hidden\">"
		  +     "<input class=\"keyflags\" type=\"hidden\">"
		  +   "</span>"
		  +   "<span class=\"keyNightMode\" title=\"This input activates Night mode\"></span>"
		  + "</td>"
		  + "<td class=\"buttonCol shifted\">"
		  +   "<span class=\"keymapping\" id=\"xkeymap" + i + "\" data-xidx=\"" + i + "\">" // shift key mapping
		  +     "<span class=\"keyname\"></span>"
		  +     "<input class=\"keycode\" type=\"hidden\">"
		  +     "<input class=\"keytype\" type=\"hidden\">"
		  +   "</span>"
		  +   "<span class=\"keyNightMode\" title=\"This input activates Night mode\"></span>"
		  + "</td>"
		  + "<td class=\"keyflags\">"
		  +   "<img src=\"PulseOff.png\" id=\"keyPulse" + i + "\" data-mask=\"1\" "   // pulse mode flag
		  +      "title=\"Pulse mode: the button sends one key press when pushed, a second when released\">"
		  + "</td>"
		  + "<td class=\"keyusage\" id=\"keyusage" + i + "\" title=\"The standard meaning of this key in Visual Pinball\">"
		  + "</td>"
		  + "</tr>");
    }

    // inject the HTML
    $("#buttonTab").html(rows);

    // pulse key help
    $("#pulseKeyHelp").click(function(ev) {
	window.external.ShowHelp("HelpPulseKey.htm");
	ev.preventDefault();
    });

    // set the shift key to a given row
    $("#buttonTab .shiftCol span").click(function(ev) {
	$("#shiftButton").val($(this).parents("tr.buttonRow").data("idx")).change();
    });
    
    // on changing the pin selection, update the expansion board alias, if applicable
    $("#buttonTab .pinselect").change(function()
    {
	var port = $(this).children(".pinval").val();
	var alias = (gpioPortAlias[port] || "").split("|");
	$(this).find("input.expBoardAlt").val("$1 ($2)".formatOrUndef(alias[0], alias[1]) || port);
	ButtonTabUpdate.touch($(this));
    });

    // pulse mode
    $("#buttonTab td.keyflags img").click(function(ev)
    {
	var keyflags = $(this).parents("tr.buttonRow").find("input.keyflags");
	keyflags.val(keyflags.val() ^ $(this).data("mask")).change();
    });

    // on changing any of the key sub-fields, update the displayed value
    $(".keymapping .keycode, .keymapping .keytype, .keymapping input.keyflags").change(function(ev) {
	ButtonTabUpdate.touch($(this));
    });

    // get the key selector dialog element so we can set it up
    var dlg = $("#keySelector");

    // build the clickable buttons on the key cap image for the dialog, and a
    // table mapping javascript key codes to keycaps and mediaKeyCaps entries
    var btns = [];
    var jsKeyCaps = { };
    var makeKey = function(k, v, typ) {
	// if this key has a clickable image, add it
	if (v.x)
	{
	    var usage = vpUsage[typ + "." + (+k)];
	    usage = usage ? "\nTypical VP use: " + usage : "";
	    btns.push("<span id=\"keycapBtn" + typ + "_" + k + "\" "
		      + "data-keytype=\"" + typ + "\" "
		      + "class=\"keycapBtn\" data-scancode=\"" + k + "\" "
		      + "title=\"" + (v.name + usage).replace(/"/, "&#34;") + "\" "
		      + "style=\""
		      +   "left: " + (v.x+4) + "px;"
		      +   "top: " + (v.y+4) + "px;"
		      +   "width: " + (v.wid || 30) + "px;"
		      +   "height: " + (v.ht || 31) + "px;"
		      + "\"></span>");
	}

	// if it has a javascript key code, add it to the js key map
	if (v.jskey)
	    (jsKeyCaps[v.jskey] = jsKeyCaps[v.jskey] || []).push({keytype: typ, keycode: k, jsloc: v.jsloc});
    };
    $.each(keycaps, function(k, v) { makeKey(k, v, 2); });
    $.each(mediaKeycaps, function(k, v) { makeKey(k, v, 3); });
    $("#oskeyboard").html(btns.join(""));

    // build the clickable buttons for the joystick button selector dialog page
    btns = [];
    for (var i = 1, row = [] ; i <= 32 ; ++i)
    {
	row.push("<span id=\"jsBtn" + i + "\" "
		 +   "class=\"jsBtn\" "
		 +   "data-button=\"" + i + "\">"
		 +  i
		 + "</span>");
	if (row.length == 8)
	{
	    btns.push("<div class=\"jsBtnRow\">" + row.join("") + "</div>");
	    row = [];
	}
    }
    $("#osjoystick .jsBtnBox").html(btns.join(""));

    // set up the page selection buttons
    $("#keytype").children().click(function() {
	var page;
	$("#keytype > img").removeClass("selected");
	$("#osunused, #oskeyboard, #osjoystick, #osspecial").css("display", "none");
	(page = $($(this).data("page"))).css("display", "");
	$("#keySelector > div").css("width", page.outerWidth() + "px");
	$(this).addClass("selected");
    });

    // row that opened the dialog, and its label item
    var dlgkey, dlgkeylbl;

    // handle events on the on-screen keyboard buttons
    $(".keycapBtn").click(function(ev) {
	// click a key - select the key (keyboard is type 2) and close the dialog
	selectButton($(this).data("keytype"), +$(this).data("scancode"), true);
	ev.preventDefault();
    }).hover(redisp, redisp);

    function redisp() {
	// Hack to work around a WebBrowser (IE) bug.  This workaround is a pretty
	// egregious hack, but the bug is annoying.  The bug comes from using CSS
	// :hover to alter a transparent overlay (the button div).  This causes a
	// weird little shift in the background rendering below the div.  It makes
	// it look blurry.  The root of the bug seems to be a rounding error when IE
	// calculates the repainting region; the rounding error comes from the
	// "margin: auto" centering, which presumably comes up with a fractional
	// pixel position that gets rounded one way when the background is rendered
	// and the other way when the overlay is rendered.  The fix here forces a
	// redraw of the underlying background by changing its width.  That full
	// background refresh has the effect of painting over our bug-damaged region,
	// and IE's double buffering of the graphics rendering ensures that the
	// correction happens before the damaged pixels ever hit the screen, so the
	// damage is never visible.  To force the redraw, we simply add a pixel to
	// the underlying div width, then set a timeout to take the pixel back out
	// a millisecond later.  We have to break the two steps across a timeout so
	// that IE can't combine the two changes into one event cycle, which would
	// skip the resize and thus skip the refresh.  Neither width change has any
	// visible effect on the actual layout, so even if the timeout happens to
	// cross a physical video refresh cycle boundary, there's no change in
	// what's displayed and therefore the redraw is invisible.  This whole
	// process is horribly inefficient, but it's the only thing I've found
	// that fixes the glitch.  It's obviously tied to the peculiarities of 
	// the IE rendering engine, but I don't think it'll do any harm if this
	// particular bug is fixed in a future version, apart from the little bit
	// of added overhead.
	$("#oskeyboard").css("width", ($("#oskeyboard").outerWidth() + 1) + "px");
	setTimeout(function() {
	    $("#oskeyboard").css("width", ($("#oskeyboard").outerWidth() - 1) + "px");
	}, 1);
    }

    // click a joystick button
    $(".jsBtn").click(function(ev) {
	// select the joystick button (joystick = type 1)
	selectButton("1", $(this).data("button"), true);
	ev.preventDefault();
    });

    // click the "unused" button
    $("#unusedBtn").click(function(ev) {
	// make the button unused (type 0)
	selectButton("0", 0, true);
	ev.preventDefault();
    });

    // click the "night mode" button in the key selector dialog
    $("#nightModeBtn").click(function(ev) {
	var idx = dlgkey.data("idx"), xidx = dlgkey.data("xidx");
	var btn = idx || xidx;
	var shift = !!xidx;
	var fld = $("#nightModeButtonNo");
	var ck = $("#nightModeButtonShift input");
	if (fld.val() == btn && ck.prop("checked") == shift) {
	    ck.prop("checked", shift);
	    fld.val(0).change();
	    $(this).removeClass("selected");
	}
	else {
	    ck.prop("checked", shift);
	    fld.val(btn).change();
	    $(this).addClass("selected");
	}
	ev.preventDefault();
    });
    
    // on clicking any key mapping, display the key selector popup
    $(".keymapping, .keyNightMode").click(function(ev) {

	// remember who opened the dialog
	dlgkey = $(this);
	if (dlgkey.hasClass("keyNightMode"))
	    dlgkey = dlgkey.parents(".buttonCol").children(".keymapping");

	// mark the label as active
	dlgkeylbl = dlgkey.parents("tr.buttonRow");
	dlgkeylbl.addClass("openDlgRow");

	// we'll fully handle the event here - skip any default action
	ev.preventDefault();

	// reset the dialog
	$(".keycapBtn, .jsBtn, #unusedBtn, #nightModeBtn").removeClass("hover selected");
	$("#keytype > img").removeClass("selected");

	// show the dialog
	dlg.parent().css("display", "block");

	// position it below the field
	var ofs = dlgkeylbl.offset();
	var dlght = dlg.outerHeight() + 24;
	var winht = window.innerHeight - $("#nav").outerHeight();
	var scrolly = $("html,body").scrollTop();
	var y = ofs.top + dlgkeylbl.height();
	dlg.css("top", y + "px");

	// make sure the bottom of the dialog is in view
	if (y + dlght > scrolly + winht)
	    scrolly = y + dlght - winht;

	// but limit this so that the top stays in view
	if (scrolly > y)
	    scrolly = y;

	// scroll here
	$("html,body").animate({ scrollTop: scrolly });

	// presume the key has no special meaning
	var isSpecial = false;

	// select the night mode button if applicable
	var nightRow = $("#nightModeButtonNo").val();
	var nightShift = $("#nightModeButtonShift input").prop("checked");
	if ((dlgkey.data("idx") == nightRow && !nightShift)
	    || (dlgkey.data("xidx") == nightRow && nightShift)) {
	    $("#nightModeBtn").addClass("selected");
	    isSpecial = true;
	}

	// show the appropriate panel
	$("#osunused, #oskeyboard, #osjoystick, #osspecial").css("display", "none");
	var typ = +dlgkey.children(".keytype").val();
	var code = +dlgkey.children(".keycode").val();
	var page;
	switch (typ)
	{
	default:
	    // No PC input (or an unknown type).  If the key has a special
	    // function (e.g., Night Mode), show the "special" page, otherwise
	    // show the "unused" page.
	    if (isSpecial) {
		page = $("#osspecial").css("display", "");
		$("#keytypeSpecial").addClass("selected");
	    }
	    else {
		page = $("#osunused").css("display", "");
		$("#keytypeUnused").addClass("selected");
	    }

	    // in any case, mark the "unused" button as selected - even if we
	    // don't start out in this page, it's still the selected input type
	    $("#unusedBtn").addClass("selected");
	    break;
	    
	case 1:  // joystick
	    (page = $("#osjoystick")).css("display", "");
	    $("#jsBtn" + code).addClass("selected");
	    $("#keytypeJS").addClass("selected");
	    break;

	case 2: // keyboard
	case 3: // media key
	    (page = $("#oskeyboard")).css("display", "");
	    $("#keycapBtn" + typ + "_" + code).addClass("selected");
	    $("#keytypeKB").addClass("selected");
	    break;
	}
	$("#keySelector > div").css("width", page.outerWidth() + "px");
    });

    // select a joystick button
    function selectButton(type, code, dismiss)
    {
	// set the key type and code
	dlgkey.children(".keytype").val(type);
	dlgkey.children(".keycode").val("" + code).change();

	// dismiss the dialog if desired
	if (dismiss)
	    dismissKeyDlg();
    }

    // handle keystrokes while the key dialog is showing
    $("html").on("keydown keyup", function(ev) {
	if (dlgkey && $("#keytypeKB").hasClass("selected"))
	{
	    // If the key maps to one of our keycaps entries, select the key.
	    // In order to match, the keycap entry has to have the same javascript
	    // key code, and must either have no "jsloc" (key location) property,
	    // or has a jsloc that matches the event location.  The location 
	    // distinguishes among keys where the javascript code is shared by
	    // multiple physical keys, such as keys on the numeric keypad and the
	    // modifier keys that are mirrored on the left and right sides.
	    var k = $.grep(jsKeyCaps[ev.which] || [], function(ele) {
		var eleloc = ele.jsloc;
		return typeof eleloc == "undefined" || eleloc == ev.originalEvent.location;
	    });

	    // if we found a key, select it
	    if (k.length == 1)
	    {
		// we found exactly one matching key - select it
		selectButton(k[0].keytype, k[0].keycode, true);
		ev.preventDefault();
		ev.stopPropagation();
	    }
	}
	else
	{
	    switch (ev.which)
	    {
	    case 32:
	    case 13:
	    case 27:
		// close the dialog on escape, space, or enter
		dismissKeyDlg();
		break;
	    }
	}
    });

    // close the key dialog
    function dismissKeyDlg()
    {
	dlg.parent().css("display", "none");
	if (dlgkeylbl) dlgkeylbl.removeClass("openDlgRow");
	dlgkey = dlgkeylbl = null;
    }

    // dismiss the dialog on clicking outside it, but not on clicking within
    $("#keySelector > div").click(function() { event.stopPropagation(); });
    dlg.parent().click(function() { dismissKeyDlg(); });
});
    
   </script>
      
   <!-- TLC5940 setup --------------------------------------------------->
   <hr>
   <div>
      <img src="tlc5940.png" class="sectionIcon">
      <b>TLC5940 (external PWM controller chip) setup</b>
      <a class="shower" href="#">What's this?</a>
      <div class="hider">
	    The TLC5940 is an integrated circuit chip that you can connect
	    to the KL25Z to add extra outputs for more feedback devices (lights,
	    solenoids, motors, etc).  The TLC5940 outputs have full PWM (Pulse
	    Width Modulation) capabilities, allowing the software to control
	    the brightness of an attached light or the speed of a motor.
	 <p>
	    These chips let you go beyond the KL25Z's limited PWM capabilities.
	    The KL25Z only has 10 PWM channels of its own, which isn't enough
	    for most virtual pinball machines.  Each TLC5940 chip provides 16 PWM
	    outputs, and you can connect two or more of the chips in a daisy chain
	    to add almost unlimited outputs.
	 </p>
	 <p>
	    The Pinscape Expansion Boards use these chips to provide extra PWM
	    outputs. You can also install them with your own custom wiring. The
	    circuitry needed is outlined in the Build Guide.  The settings below
	    configure the data signal connections between the KL25Z and the TLC5940's.
	 </p>
      </div>

      <div class="expBoardAlt">
	 The TLC5940 configuration is automatically set up for your expansion boards.
      </div>
      <div class="expBoardPin">
	 <table class="inputs">
	    <tr>
	       <!-- the fixed width is a hack to get the two table column sets to line up -->
	       <td style="width: 32ex;">Number of TLC5940 chips:</td>
	       <td>
		  <input type="text" size=4 id="tlc_nchips">
	       </td>
	    </tr>
	 </table>
	 <table id="tlcPins" class="inputs" style="display: block;">
	    <tr>
	       <!-- the fixed width is a hack to get the two table column sets to line up -->
	       <td td style="width: 32ex;" class="pinlabel">SI (serial data) output:</td>
	       <td>
		  <span class="pinselect" id="tlc_si"
		    data-cfg="TLC5940.SIN" data-gpiotype="spi-mosi extern"
		    data-desc="TLC5940 SI" data-default="PTC6">
		  </span>
	       </td>
	       <td>Requires an <a href="#" class="spiHelp">SPI MOSI</a> output pin</td>
	    </tr>
	    <tr>
	       <td class="pinlabel">SCLK (serial clock) output:</td>
	       <td>
		  <span class="pinselect" id="tlc_si"
		    data-cfg="TLC5940.SCLK" data-gpiotype="spi-sclk extern"
		    data-desc="TLC5940 SCLK" data-default="PTC5">
		  </span>
	       </td>
	       <td>Requires an <a href="#" class="spiHelp">SPI SCLK</a> output pin</td>
	    </tr>
	    <tr>
	       <td class="pinlabel">XLAT output:</td>
	       <td>
		  <span class="pinselect" id="tlc_xlat"
		    data-cfg="TLC5940.XLAT" data-gpiotype="dig-out extern"
		    data-desc="TLC5940 XLAT" data-default="PTC10">
		  </span>
	       </td>
	    </tr>
	    <tr>
	       <td class="pinlabel">BLANK output:</td>
	       <td>
		  <span class="pinselect" id="tlc_blank"
		    data-cfg="TLC5940.BLANK" data-gpiotype="dig-out extern"
		    data-desc="TLC5940 BLANK" data-default="PTC7">
		  </span>
	       </td>
	    </tr>
	    <tr>
	       <td class="pinlabel">GSCLK output:</td>
	       <td>
		  <span class="pinselect" id="tlc_gsclk"
		    data-cfg="TLC5940.GSCLK" data-gpiotype="pwm extern"
		    data-desc="TLC5940 GSCLK" data-default="PTA1">
		  </span>
	       </td>
	       <td>Requires a <a href="#" class="pwmHelp">PWM-capable output pin</a></td>
	    </tr>
	 </table>
      </div>
   </div>

   <script>
$("#tlc_nchips").change(function(ev)
{
    // show or hide the section as needed
    var active = +$(this).val() != 0;
    slideToggle($("#tlcPins"), active, loadingConfig ? 0 : 250, false);

    // Adjust the output ports, unless we're loading a config.  Don't
    // make any changes when loading, since we simply want to restore
    // the exact output port list in the config in this case.
    if (!loadingConfig)
	adjustOutputPorts(3);
});
   </script>

   <!-- 74HC595 setup --------------------------------------------------->
   <hr>
   <div>
      <img src="74hc595.png" class="sectionIcon">
      <b>74HC595 (external digital out chip) setup</b>
      <a class="shower" href="#">What's this?</a>
      <div class="hider">
	 The 74HC595 is an integrated circuit chip that can be connected
	 to the KL25Z to add more digital outputs for feedback devices like
	 solenoids and replay knockers.  "Digital" means that the outputs
	 are strictly on/off: the software can't modulate intensity or brightness.
	 Digital outputs are ideal for feedback devices that inherently need only
	 on/off control, such as solenoids.

	 <p>
	    The Pinscape "Chime Board" uses this
	    chip to add outputs for replay knockers and chime units.  You can also
	    add these chips with your own custom wiring; the circuitry is described
	    in the Build Guide.  The settings below let you configure the data
	    connections between the KL25Z and the 74HC595's.
	 </p>
      </div>

      <div class="expBoardAlt">
	 The 74HC595 configuration is automatically set up for your chime boards.
      </div>
      <div class="expBoardPin">
	 <table class="inputs">
	    <tr>
	       <!-- the fixed width is a hack to get the two table column sets to line up -->
	       <td style="width: 32ex;">Number of 74HC595 chips:</td>
	       <td>
		  <input type="text" size=4 id="hc595_nchips">
	       </td>
	    </tr>
	 </table>
	 <table id="hcPins" class="inputs" style="display: block;">
	    <tr>
	       <!-- the fixed width is a hack to get the two table column sets to line up -->
	       <td td style="width: 32ex;" class="pinlabel">SI (serial data) output:</td>
	       <td>
		  <span class="pinselect" id="hc595_si"
		    data-cfg="HC595.SIN" data-gpiotype="dig-out extern"
		    data-desc="74HC595 SI" data-default="PTA5">
		  </span>
	       </td>
	    </tr>
	    <tr>
	       <td class="pinlabel">SCLK (serial clock) output:</td>
	       <td>
		  <span class="pinselect" id="hc595_si"
		    data-cfg="HC595.SCLK" data-gpiotype="dig-out extern"
		    data-desc="74HC595 SCLK" data-default="PTA4">
		  </span>
	       </td>
	    </tr>
	    <tr>
	       <td class="pinlabel">LATCH output:</td>
	       <td>
		  <span class="pinselect" id="hc595_latch"
		    data-cfg="HC595.LATCH" data-gpiotype="dig-out extern"
		    data-desc="74HC595 LATCH" data-default="PTA12">
		  </span>
	       </td>
	    </tr>
	    <tr>
	       <td class="pinlabel">ENA output:</td>
	       <td>
		  <span class="pinselect" id="hc595_ena"
		    data-cfg="HC595.ENA" data-gpiotype="dig-out extern"
		    data-desc="74HC595 ENA" data-default="PTD4">
		  </span>
	       </td>
	    </tr>
	 </table>
      </div>
   </div>

   <script>
$("#hc595_nchips").change(function(ev)
{
    // show or hide our pin setup section as appropriate
    var active = +$(this).val() != 0;
    slideToggle($("#hcPins"), active, loadingConfig ? 0 : 250, false);

    // Add or remove output ports for the 74HC595 chips (type 4).  Skip
    // this when loading a config, since we want to simply restore the
    // exact output list from the saved config in this case.
    if (!loadingConfig)
	adjustOutputPorts(4);
});
   </script>

   <!-- Night Mode ------------------------------------------------------>
   <hr>
   <div>
      <a name="nightmode"></a>
      <img src="nightModeSection.png" class="sectionIcon">
      <b>Pinscape After Dark.</b>  You can set up a button or switch to
      activate <b>Night Mode</b>, which disables the feedback device outputs
      that you designate as noise-makers.  This lets you play during late-night
      hours without disturbing your party-pooper housemates and neighbors.
      <a href="#" class="shower">Details</a>

      <div class="hider">
	 <ul>
	    <li>Select an <a href="#buttonSection">input button</a> to turn
	    Night Mode on and off.  Wire this like any other button.
	    
	    <li>You'll probably want to configure the button you select
	    for "No PC Input" in the <a href="#buttonSection">button setup</a>,
	    but you can have it send a keystroke if that's useful to you for
	    some reason.
	    
	    <li>If you don't want to wire a physical button for this, just
	    set the button number to 0 (zero).  You can still control Night
	    Mode with the NightMode.exe program on the PC (it's in your
	    Pinscape Setup Tool folder).

	    <li>You can also optionally select an output port to serve as an
	    indicator light, so that you can tell when night mode is turned on.
	    If you don't need an indicator, just set this to 0.  If you do assign
	    a port, you should leave it unassigned in your DOF port layout.
	 </ul>
      </div>

      <div id="nightModeOptions" style="margin: 1em 4em;">
	 <table class="inputs">
	    <tr>
	       <td>
		  Button input number:
	       </td>
	       <td>
		  <input id="nightModeButtonNo" size="4" style="margin: 0px 1em;">
		  <span style="padding-left: 2em; font-style: italic;">0 = no input button assigned</span>
	       </td>
	    </tr>
	    <tr id="nightModeButtonShift">
	       <td></td>
	       <td>
		  <label><input type="checkbox"> Use shifted button</label> (see <a href="#buttonSection">Button Setup</a>)
	       </td>
	    </tr>
	    <tr>
	       <td>
		  Button type:
	       </td>
	       <td>
		  <table class="radio" style="display: inline-block; vertical-align: middle; margin: 1em 0px;">
		     <tr id="nightModeButtonTypeRow">
			<td>
			   <label>
			      <img src="pushButton.png"><br>
			      <input type="radio" name="nightModeButtonType" value="1">
			      Momentary button
			      <br>(Toggles mode when pushed)
			   </label>
			</td>
			<td>
			   <label>
			      <img src="toggleSwitch.png"><br>
			      <input type="radio" name="nightModeButtonType" value="2">
			      On/off switch
			      <br>&nbsp;
			   </label>
			</td>
		     </tr>
		  </table>
	       </td>
	    </tr>
	    <tr>
	       <td>
		  Indicator lamp output port:
	       </td>
	       <td>
		  <input id="nightModeOutputNo" size="4" style="margin: 0px 1em;">
		  <span style="padding-left: 2em; font-style: italic;">0 = no indicator output</span>
	       </td>
	    </tr>
	 </table>
      </div>
      
   </div>

   <script>

// on changing the button number, update the icon display in the button setup section
$("#nightModeButtonShift input").change(function() { updateNightModeButton(); });
$("#nightModeButtonNo").change(function() { updateNightModeButton(); });
function updateNightModeButton()
{
    var n = +$("#nightModeButtonNo").val();
    $("#buttonTab .buttonCol").removeClass("nightMode");
    if (n)
    {
	var shifted = $("#shiftButton").val() != 0 && $("#nightModeButtonShift input").prop("checked");
	$("#buttonRow" + n + " .buttonCol." + (shifted ? "shifted" : "primary")).addClass("nightMode");
	ButtonTabUpdate.touch($("#buttonRow" + n));
    }
}

$("#nightModeButtonTypeRow input").change(function() {
    showHideNightModeButtonShift();
    updateNightModeButton();
});
$("#nightModeOutputNo").change(function()
{
    var n = +$(this).val();
    $("#outputTab .nightModeRemark").remove();
    if (n != 0) {
	$("#outputTab tr .outPortRemarks").eq(n-1).append(
	    "<span class=\"nightModeRemark\" title=\"This is the Night Mode indicator lamp port\">"
	    + "<a href=\"#nightmode\">"
	    + "<img src=\"nightModeSmall.png\">"
	    + "</a>"
	    + "</span>");
    }
});

function showHideNightModeButtonShift()
{
    // the night mode button can only be on a shifted button if the shift
    // button is enabled AND the night mode button is in toggle mode
    $("#nightModeButtonShift").toggle(
	$("#shiftButton").val() != 0
	&& $("#nightModeOptions input:radio[name=nightModeButtonType]:checked").val() == 1);
}
      
   </script>


   <!-- Output controller setup ----------------------------------------->
   <hr>
   <div>
      <a name="outputSection"></a>
      <img src="outputSection.png" class="sectionIcon">
      <b>Feedback device outputs.</b>  Pinball software on the PC can control
      output devices connected to the KL25Z to create special effects during play,
      such as tactile feedback and lighting displays.  The PC software uses the
      <b>port numbers</b> in the list below to address the outputs.  Use these
      port numbers when you set up your <a class="dofconfigtool">DOF configuration</a>.
      For each port, you can select the physical output pin that the port is wired to.

      <div>
	 <table id="outputTab">
	    <tr>
	       <th></th>
	       <th>Port No.</th>
	       <th>Type</th>
	       <th>Location</th>
	       <th>Pin</th>
	       <th>Port</th>
	       <td></th>  <!-- pin warnings -->
	       <th></th>  <!-- pin remarks -->
	       <th>Options [<a href="#" class="outPortOptionsHelp">?</a>]</th>
	 </table>
      </div>

   </div>

   <script>

// Set up the output port table
$(function() {
    var rows = [];
    for (var i = 1 ; i <= 128 ; ++i)
    {
	// In each row:
	//   - dispPinType is a derived display name describing the pin type
	//   - dispPinName is a derived display name describing the pin name
	//   - pinval is the internal pin value.  For GPIO pins, this uses the
	//     standard PTxn notation.  For external chip pins, it's simply
	//     the port number, numbering from 0 for the first chip's first
	//     output.
	//   - pintype is the internal pin type, per the USB config messages
	//     (0=disabled, 1=PWM, etc)
	rows.push("<tr id=\"outPortRow" + i + "\" class=\"outPortRow\" data-idx=\"" + i + "\" "
		  +  "data-desc=\"Output Port " + i + "\">"
		  +   "<td class=\"rowControls\">"
		  +      "<span class=\"addRow\" title=\"Insert a new output port here\"></span>"
		  +      "<span class=\"delRow\" title=\"Delete this output port\"></span>"
		  +      "<span class=\"moveRow\" title=\"Move this output port\"></span>"

// select - disable for now: still working out the details, but might add later
//		  +      "<span class=\"selectRow\" title=\"Select this output port (use SHIFT or CTRL "
//		  +           "to select multiple ports to move or delete)\"></span>"

		  +   "</td>"
		  +   "<td class=\"pinlabel\">" + i + "</td>"
		  +   "<td><span class=\"dispPinType\"></span></td>"
		  +   "<td class=\"dispPinLoc\"></td>"
		  +   "<td class=\"dispPinHeader\"></td>"
		  +   "<td class=\"outPortPin\">"
		  +      "<input class=\"dispPinName\" type=\"text\" size=\"14\" readonly>"
		  +      "<input class=\"pintype\" type=\"hidden\">"
		  +      "<input class=\"pinval\" type=\"hidden\">"
		  +   "</td>"
		  +   "<td>"
		  +      "<span class=\"pinwarn\"><img src=\"pinwarn.png\"></span>"
		  +   "</td>"
		  +   "<td class=\"outPortRemarks\"></td>"
		  +   "<td class=\"outPortOptions\">"
		  +      "<input class=\"pinflags\" type=\"hidden\">"
		  +      "<img src=\"NoisyOff.png\" class=\"outPortNoisy\" data-mask=\"2\" "
		  +         "title=\"Noisy device: disable this port when Night Mode is engaged\">"
		  +      "<img src=\"GammaOff.png\" class=\"outPortGamma\" data-mask=\"4\" "
		  +         "title=\"Use gamma correction on this port (suitable for lamps and LEDs)\">"
		  +      "<img src=\"ActiveLowOff.png\" class=\"outPortLow\" data-mask=\"1\" "
		  +         "title=\"Active low port: port connects to ground (0V) when ON\">"
		  +   "</td>"
		  + "</tr>");
    }

    // add a last row with just a "+" control to add a row at the end
    rows.push("<tr class=\"outPortRow\" data-idx=\"end\" id=\"lastOutPortRow\">"
	      +   "<td class=\"rowControls\">"
	      +      "<span class=\"addRow\" title=\"Add a new output port\"></span>"
	      +   "</td>"
	      +   "<td></td>"
	      +   "<td></td>"
	      +   "<td></td>"
	      + "</tr>");

    // insert the rows
    $("#outputTab").append(rows);

    // add change handlers for the pin type and value
    var typeNames = ["Disabled", "PWM", "Digital", "PWM", "Digital", "Virtual"];
    $(".outPortRow .pintype, .outPortRow .pinval").change(function()
    {
	// get the row (the .outPortRow parent)
	var row = $(this).parents(".outPortRow");

	// get the internal pin type value and corresponding display name
	var typ = row.find(".pintype");
	var typval = boundsCheck(+typ.val(), typeNames);
	var typeDisp = typeNames[typval];
	
	// get the internal pin value
	var pin = row.find(".pinval").val();

	// presume the row pin type will empty
	row.data("pintype", "");

	// update the displayed pin name
	var pinDisp = "";
	var locDisp = "";
	var hdrDisp = "";
	var opts = 0xff;
	switch(typval)
	{
	case 1: // PWM Out (GPIO)
	    locDisp = "KL25Z";
	    hdrDisp =  pinToJumper(pin);
	    pinDisp = pin;
	    row.data("pintype", "pwm");
	    break;
    
	case 2: // Digital Out (GPIO)
	    locDisp = "KL25Z";
	    hdrDisp = pinToJumper(pin);
	    pinDisp = pin;
	    row.data("gpiotype", "dig-out");
	    opts &= ~4;  // alpha isn't applicable to digital outs
	    break;

	case 3: // TLC5940
	    locDisp = "TLC5940 #" + (Math.floor(pin/16)+1);
	    hdrDisp = [28, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15][pin % 16];
	    pinDisp = "Out " + (pin % 16);
	    opts &= ~1;   // active low isn't applicable to TLC outputs
	    break;

	case 4: // 7HC595
	    locDisp = "74HC595 #" + (Math.floor(pin/8)+1);
	    hdrDisp = [15, 1, 2, 3, 4, 5, 6, 7][pin % 8];
	    pinDisp = "Out " + (pin % 8);
	    opts &= ~(1 | 4);  // active low and gamma aren't applicable to 74HC595 outputs
			       // (gamma is disabled because these are inherently digital outs)
	    break;

	case 5: // Virtual
	    locDisp = "None";
	    hdrDisp = "";
	    pinDisp = "";
	    opts &= ~(1 | 2 | 4);  // gamma, active low, noisy aren't applicable to virtual outputs
	    break;
	}

	// if there's an expansion board alias, apply it
	var alias = outPortAlias[typval + "." + pin];
	if (alias)
	{
	    // set the alias name
	    alias = alias.split("|");
	    pinDisp = alias[0];
	    typeDisp = alias[1];
	    locDisp = alias[2];
	    hdrDisp = alias[3];
	}

	// set the name and type strings
	row.find(".dispPinLoc").text(locDisp);
	row.find(".dispPinName").val(pinDisp);
	row.find(".dispPinHeader").text(hdrDisp);
	row.find(".dispPinType").text(typeDisp);

	// enable/disable option checkboxes
	row.find(".outPortOptions img").each(function() {
	    var img = $(this);
	    var mask = img.data("mask");
	    var vis = !!(mask & opts);
	    img.toggle(vis);
	    if (!vis)
		img.attr("src", img.attr("src").replace(/On|Off/, "Off"));
	});
    });

    // change handler for the port options internal data field
    $(".outPortRow .pinflags").change(function() {
	var self = $(this);
	var flags = +self.val();
        self.parent().find("img").each(function() {
	    var img = $(this);
	    var state = (flags & img.data("mask")) != 0 ? "On" : "Off";
	    img.attr("src", img.attr("src").replace(/(On|Off)/, state));
	});
    });

    // change handlers for the port options icons
    $(".outPortRow .outPortOptions img").click(function(ev) {
	var img = $(this);
	var mask = +img.data("mask");
	var flagfield = img.parents(".outPortOptions").children(".pinflags");
	flagfield.val(+flagfield.val() ^ mask).change();
    });

    // insert a row
    $("#outputTab .addRow").click(function(ev) {
	ev.stopPropagation();
	insertOutputs($(this).parents(".outPortRow"), 1);
    });

    // delete a row
    $("#outputTab .delRow").click(function(ev)
    {
	// ask for confirmation, and delete the row if confirmed
	ev.stopPropagation();
	if (window.external.YesNoDialog(
	    "Are you sure you want to delete this output port?"))
	    deleteOutputs($(this).parents(".outPortRow"), 1);
    });

    // select a row
    $("#outputTab .selectRow").click(function(ev)
    {
	var self = $(this);
	var row = self.parents(".outPortRow");
	if (ev.shiftKey)
	{
	    // shift key - extend selection to include all rows from here to
	    // first and last selected rows
	    var allsel = row.parent().children(".selected");
	    var first = allsel.first(), firstidx = first.data("idx");
	    var last = allsel.last(), lastidx = last.data("idx");
	    var idx = +row.data("idx");

	    // if the first selected row is before us, extend from first to here
	    if (firstidx && +firstidx < idx)
		row.parent().children().slice(+firstidx, idx).addClass("selected");

	    // if the last selected row is after us, extend from here to last
	    if (lastidx && +lastidx > idx)
		row.parent().children().slice(idx, +lastidx).addClass("selected");

	    // in any case, definitely select this row
	    row.addClass("selected");
	}
	else if (ev.ctrlKey)
	{
	    // toggle this row only
	    row.toggleClass("selected");
	}
	else
	{
	    // toggle this row and deselect all other rows
	    var sel = row.hasClass("selected");
	    $(".outPortRow").removeClass("selected");
	    row.toggleClass("selected", !sel);
	}
	return false;
    }).mousedown(function(ev) {
	// prevent text selection when clicking in this control
	ev.preventDefault();
    });

    // move a row
    $("#outputTab .moveRow").mousedown(function(ev)
    {
	// get the row and table
	var row = $(this).parents(".outPortRow");
	var tab = $("#outputTab");

	// set up a copy of the row to show during the move, wrapped in a
	// position:absolute div so that we can have it track the mouse
	var mover = $("<div class=\"rowMover\"></div>");
	$("body").append(mover);
	mover.append("<td><span class=\"moveIcon\"></span></td>");
	mover.append(row.children().slice(1).clone());
	var left = tab.offset().left;

	// copy widths and text alignments
	for (var dst = mover.children().first(), src = row.children().first(), i = 0 ;
	     src.length ;
	     src = src.next(), dst = dst.next(), ++i)
	{
	    // copy the width, padding, and alignment
	    dst.css("width", src.outerWidth() + "px");
	    dst.css(src.css(["padding-left", "padding-right", "text-align"]));

	    // ... except for the first column, where we force right alignment, since
	    // we substitute our own "moving" icon in place of the normal row controls
	    if (i == 0)
		dst.css("text-align", "right"); // add if "select row" icon is present: .css("padding-right", "22px");
	}

	var td = $(row).children("td").eq(1);
	var ofs = row.offset();
	mover.css({
	    "left": left + "px",
	    "top": td.offset().top + "px"
	});

	var strut = $(
	    "<tr data-idx=\"strut\">"
	    +   "<td style=\"height:" + mover.outerHeight() + "px;\">"
	    +   "</td>"
	    + "</tr>");
	strut.insertBefore(row);

	// hide the original row while dragging it
	row.css("display", "none");

	// monitor entering and leaving rows as the mouse moves to show
	// where the drop will go
	var target = $();
	$("#outputTab .outPortRow").on("mousemove.outputRowMover", function(ev)
	{
	    // ignore any events in the row being dragged
	    if (this == row[0]) return;

	    // Figure which side of the row we're on.  If we're in the top half,
	    // move the dragged row before the target row; otherwise move it after
	    // the target row.  Exception: we can't go past the last row.
	    var self = $(this);
	    var ofs = self.offset();
	    var newTarget = (ev.pageY < ofs.top + self.outerHeight()/2)
			    || self.data("idx") == "end" ? self : self.next();

	    // skip the fake "strut" row and the original row
	    while (newTarget[0] == row[0] || newTarget.data("idx") == "strut")
		newTarget = newTarget.next();

	    if (newTarget[0] != target[0])
	    {
		// remove any previous target highlighting and highlight the new target row
		target = newTarget;
		strut.insertBefore(target);
		var top = strut.offset().top;

		// move the on-screen drag row to track the mouse
		mover.css({"left": left + "px", "top": top + "px"});
	    }
	});

	// trigger an immediate enter on the next row if it's visible
	if (row.next().css("display") != "none")
	    row.next().mouseover();
	else
	    $("#outputTab .outPortRow").last().mouseover();

	var mousex, mousey;
	$(":root").on("mousemove.outputRowMover", function(ev) {
	    mousex = ev.pageX;
	    mousey = ev.pageY;
	});
	var scrollTimer = setInterval(function() {
	    var doc = $("html,body");
	    var sy = doc.scrollTop();
	    var ht = window.innerHeight - $("#nav").outerHeight();
	    var adj = 16;
	    if (mousey < sy + adj) {
		doc.scrollTop(sy - 16);
		mousey = 0;
	    }
	    else if (mousey > sy + ht - adj) {
		mousey = 100000;
		doc.scrollTop(sy + 16);
	    }
	}, 100);

	// monitor mouse-button-up anywhere on the document to end the drag
	$(":root").on("mouseup.outputRowMover", function(ev)
	{
	    // remove all target highlighting
	    strut.remove();

	    // remove the on-screen drag row
	    mover.remove();

	    // restore visibility to the original row
	    row.css("display", "");

	    // move the row
	    if (target.length)
		moveOutputs(row, target, 1);

	    // remove the drag monitor events
	    $(":root, #outputTab .outPortRow").off(".outputRowMover");

	    // remove the scroll timer
	    clearInterval(scrollTimer);
	});

	ev.preventDefault();
	ev.stopPropagation();
	return false;
    });
});



// Adjust the output ports for a change in peripheral chips.  This is
// for peripheral chips that provide output ports (TLC5940, 74HC595).
// We'll adjust the output array by adding new ports if chips have
// been added, or removing existing ports for chips that are no longer
// present.
//
// If 'pintype' is provided, we'll only apply changes for that type.
// The type is the USB port setup message type: 3=TLC5940, 4=74HC595.
// If 'pintype' is omitted, we'll update all types.
var adjustOutputPorts = (function()
{
    // Set up an internal table of the factory ports, so that we can
    // find the flags for a given factory port
    var factoryOutputs = { };
    $.each(expansionBoardFactoryConfig.output, function(k, v) {
	factoryOutputs[v.port.type + "." + v.port.pin] = v;
    });

    // list of pending updates
    var pending;

    // main handler - queue a deferred update
    return function(pintype)
    {
	// If we don't already have a pending operation, queue one up.
	// Set it to run in a couple of seconds, to allow for grouping
	// multiple UI changes.
	if (!pending) {
	    pending = { };
	    setTimeout(go, 1000);
	}

	// Add this pintype to the pending list.  If no pintype was
	// provided, add them all.
	if (pintype)
	    pending[pintype] = true;
	else
	    pending[3] = pending[4] = true;
    };

    // perform pending updates
    function go()
    {
	// mark for deletion ports for a given chip that are no longer accessible 
	function markDelPorts(pintype, nports)
	{
	    // mark for deletion each row that refers to a non-existent port on this chip
	    var ports = { };
	    for (var row = $("#outputTab .outPortRow").first() ; row.data("idx") != "end" ; row = row.next())
	    {
		// if this row is for a non-existent port, delete it
		var del = false;
		if (row.find(".pintype").val() == pintype)
		{
		    // note the existing port
		    var portno = +row.find(".pinval").val();
		    ports[portno] = true;
		    
		    // delete it if it's no longer present
		    if (portno >= nports)
			row.data("delete", true);
		}
	    }
	
	    // return the port list
	    return ports;
	}
	
	// insert new ports as needed
	function insPorts(ports, pintype, nports, flags)
	{
	    // Insert ports that aren't already present
	    for (var i = 0 ; i < nports ; ++i)
	    {
		// insert an output row in the UI if it's not already there
		if (!ports[i])
		    newPortList.push({pintype: pintype, pinval: i, pinflags: flags});
	    }
	}

	// get the number of each chip
	var ntlc = +$("#tlc_nchips").val();
	var nhc = +$("#hc595_nchips").val();
	
	// delete outputs for each chip that are no longer needed
	var tlcPorts = pending[3] ? markDelPorts(3, ntlc*16) : null;
	var hcPorts = pending[4] ? markDelPorts(4, nhc*8) : null;
	
	// apply deletions
	deleteOutputs();
	
	// HACK: If the expansion board configuration is selected, mark
	// any new 74HC595 ports as "noisy".  The expansion boards use
	// these ports only on the chime boards, and these boards are
	// specialized for driving solenoids, and solenoids are pretty
	// much only used in virtual pinball machines for tactile feedback
	// devices that make noise... therefore it's safe to assume that
	// these outputs will be noisy.  It would be nicer to have an
	// abstract and extensible way of handling default flags for new
	// ports, but so far this is the only situation where we need any
	// flags at all, so for the sake of simplicity, I'm treating it
	// as a special-case hack for now.
	var hcFlags = 0;
	if ($("input:radio[name=hardwareType]:checked").val() == 1)
	    hcFlags = 0x02;  // noisy

	// generate the list of new ports we need
	var newPortList = [];
	if (pending[3]) insPorts(tlcPorts, 3, ntlc*16, 0);
	if (pending[4]) insPorts(hcPorts, 4, nhc*8, hcFlags);

	// insert the batch of new outputs into the table
	if (!insertOutputs($("#lastOutPortRow"), newPortList))
	    alert("You've reached the maximum number of output ports. There aren't "
		  + "enough slots to add all of the ports for the new device(s) you "
		  + "just added, so none have been added.  You might still be able "
		  + "to add some of the new ports manually, and you can also reassign "
		  + "any unused ports on other devices to the new device(s).");

	// adjust the active/inactive status for the peripheral chip connections
	adjustPeripheralPins(pending[3], pending[4]);

	// update pin warnings
	updatePinWarnings();

	// we no longer have work pending
	pending = undefined;
    }
})();

function adjustPeripheralPins(tlc5940, hc595)
{
    // activate or deactivate the TLC5940 pins, if desired
    if (tlc5940)
	$("#tlcPins .pinselect").data("active", $("#tlc_nchips").val() != 0);

    // likewise the 74HC595 pins
    if (hc595)
	$("#hcPins .pinselect").data("active", $("#hc595_nchips").val() != 0);

}

// Insert/delete output ports
var insertOutputs, deleteOutputs, moveOutputs, appendOutputs;
(function() {

    // Insert one or more output port rows before the given row.  Returns
    // true on success, false if there's not room for the added rows.  We
    // check for room before adding any rows, so no changes are made if
    // the insertion fails.
    insertOutputs = function(before, numOrVals)
    {
	// Determine if the caller provided a number of rows or an array of values
	// to insert.  If no value array was provided, the default is
	// type 5 (virtual).
	var num = 1, val = [];
	var virtual = { pintype: 5 };
	if (typeof numOrVals == "number") {
	    num = numOrVals;
	}
	else if ($.isArray(numOrVals)) {
	    val = numOrVals;
	    num = val.length;
	}
	else if (typeof numOrVals == "object") {
	    val = [numOrVals];
	}

	// make sure the last 'num' rows are free
	var rows = $("#outputTab .outPortRow");
	for (var i = 0, cur = rows.last().prev() ; i < num ; ++i, cur = cur.prev())
	{
	    // if this row is in use, we don't have room for the insertion
	    if (cur.find(".pintype").val() != 0)
		return false;
	}

	// note the insertion point
	var idx = before.data("idx");

	// if we're inserting after the last row, the true insertion point
	// is the first unused row
	if (idx == "end")
	{
	    // find the first free row
	    before = findFreeRow();
	}
	else
	{
	    // Set up pointers for moving rows.  We've already backed up
	    // 'cur' by 'num' rows from the end, so it's our source pointer;
	    // our destination pointer is the last row (actually the second
	    // to last, since the last is the fake row for the "add a row at
	    // the end" control).
	    var src = cur;
	    var dst = rows.last().prev();

	    // Move rows until we reach the 'before' row
	    for ( ; ; src = src.prev(), dst = dst.prev())
	    {
		// if this row is in use, move it
		copyRow(src, dst);
		
		// if we just copied the 'before' row, we're done
		if (src.data("idx") == idx)
		    break;
	    }
	}
	
	// populate the new rows
	for (var i = 0 ; i < num ; ++i, before = before.next())
	    setRow(before, i < val.length ? val[i] : virtual);
	
	// fix up the table for the insertion
	fixUpTable();

	// success
	return true;
    };

    // Append outputs to the end of the table, up to and including
    // the given row number.  Sets each new output to a virtual port.
    appendOutputs = function(row)
    {
	// go through rows starting at row 1, and set each
	// unused output through the given row to "virtual"
	var rows = $("#outputTab .outPortRow");
	for (var i = 0 ; i < row ; ++i)
	{
	    // get the row
	    var cur = rows.eq(i);

	    // if it's the special last row, we're done
	    if (cur.data("idx") == "end")
		break;

	    // if the pin type is zero, change this to a virtual row
	    if (cur.find(".pintype").val() == 0)
	    {
		cur.find(".pintype").val(5).change();
		cur.find(".pinval").val(0);
		cur.find(".pinflags").val(0);
	    }
	}

	// fix up for the deletion
	fixUpTable();
    };

    // Delete one or more output rows starting with the given row.
    //
    // If called with no arguments, we'll instead delete all rows
    // with data("delete") in the TR element.  This is much more
    // efficient for deleting a batch of rows, since we only have
    // make one pass through the table.
    deleteOutputs = function(row, num)
    {
	var rows = $("#outputTab .outPortRow");
	var src, dst;

	// check if we're deleting a given block of rows or rows
	// marked with data("delete")
	if (row)
	{
	    // deleting a block - note the starting row index
	    var delidx = row.data("idx");
	    
	    // set up pointers to move items down by 'num' rows
	    src = rows.eq(delidx - 1 + num);
	    dst = rows.eq(delidx - 1);
	    
	    // move items down
	    for ( ; src.data("idx") != "end" && src.find(".pintype").val() != 0 ;
		  src = src.next(), dst = dst.next())
		copyRow(src, dst);
	    
	    // set the newly unused rows at the end to 'disabled'
	    for (var i = 0 ; i < num ; ++i, dst = dst.next())
		setRow(dst, {pintype: 0});

	}
	else
	{
	    // Delete all rows marked with data("delete").
	    // Scan the rows, stopping when we reach the end or the first unused row.
	    src = dst = rows.first();
	    for (src = dst = rows.first() ; src.data("idx") != "end" ; src = src.next())
	    {
		// if this row isn't marked for deletion, copy it
		if (src.data("delete"))
		{
		    // marked for deletion - don't copy, just remove the marker
		    src.removeData("delete");
		}
		else
		{
		    // this row is to be kept - copy it
		    copyRow(src, dst);
		    dst = dst.next();
		}
	    }

	    // clear remaining rows
	    for ( ; dst.data("idx") != "end" ; dst = dst.next())
		setRow(dst, {pintype: 0});
	}
	
	// fix up for the deletion
	fixUpTable();
    }

    // Move one or more output rows
    moveOutputs = function(fromRow, toRow, num)
    {
	// figure the 'from' index
	var fromIdx = fromRow.data("idx") - 1;

	// figure the 'to' index - if moving to the end, use the first free row
	var toIdx = toRow.data("idx");
	if (toIdx == "end")
	    toIdx = findFreeRow().data("idx");
	toIdx -= 1;

	// If we're inserting at the same point, or the insertion point
	// overlaps the deleted area, there's nothing to do
	if (toIdx >= fromIdx && toIdx < fromIdx + num)
	    return;

	// make an internal copy of the rows we're moving
	var vals = [];
	var rows = $("#outputTab .outPortRow");
	var cur = rows.eq(fromIdx);
	for (var i = 0 ; i < num ; ++i, cur = cur.next())
	{
	    vals.push({
		pintype:  cur.find(".pintype").val(),
		pinval:   cur.find(".pinval").val(),
		pinflags: cur.find(".pinflags").val()
	    });
	}

	// delete the rows being moved
	deleteOutputs(fromRow, num);

	// Figure the insertion point.  If this is higher than the
	// 'from' point, adjust it for the deletion we just did.
	if (toIdx > fromIdx)
	    toIdx -= num;

	// insert the rows
	insertOutputs(rows.eq(toIdx), vals);
    }
	
    function copyRow(src, dst)
    {
	// copy the row only if the src and dst rows are distinct
	if (src.data("idx") != dst.data("idx"))
	{
	    // copy the pin type, pin value, and flags
	    dst.find(".pintype").val(src.find(".pintype").val());
	    dst.find(".pinval").val(src.find(".pinval").val()).change();
	    dst.find(".pinflags").val(src.find(".pinflags").val()).change();

	    // fix up any special fields that reference the affected rows
	    function update(fld, disable)
	    {
		// if we just overwrite the referenced row, disable the reference
		var i = fld.val();
		if (i == dst.data("idx"))
		    disable();
		else if (i == src.data("idx"))
		    fld.val(dst.data("idx")).change();
	    }
	    update($("#zbPort"), function() {
		$("#zbPort").val(0);
		$("#zbEnabled").prop("checked", false).change();
	    });
	}
    }

    function setRow(dst, val)
    {
	dst.find(".pintype").val(val.pintype || 0);
	dst.find(".pinval").val(val.pinval || 0).change();
	dst.find(".pinflags").val(val.pinflags || 0).change();
    }

    // Find the first free row.  This is the first row of type 'disabled'.
    function findFreeRow()
    {
	// filter for disabled rows, then return the first one
	return $("#outputTab .outPortRow").filter(function() {
	    return $(this).find(".pintype").val() == 0;
	}).first();
    }

    // fix up the table for an insertion (+1) or deletion (-1)
    function fixUpTable()
    {
	// reset pin warnings
	updatePinWarnings();

	// adjust the table size
	sizeOutputsTable();
    }
})();

// Adjust the display size of the table so that we only show the active
// outputs.  This hides outputs from the first disabled one onward.
function sizeOutputsTable()
{
    // start with items visible
    var disp = "";

    // visit each row
    $(".outPortRow").each(function() {
	// If this is the special last row with the "add row at end" control,
	// show it only if the previous row was hidden - once all real rows
	// are shown, we can't add more rows.
	//
	// For all normal rows, if this one is disabled, hide items from here
	// to the end.
	var self = $(this);
	if (self.data("idx") == "end")
	    disp = (disp == "none" ? "" : "none");
	else if (self.find(".pintype").val() == 0)
	    disp = "none";

	// show or hide this item according to the current status
	self.css("display", disp);
	
	// make sure all hidden rows have pin type 0
	if (disp == "none")
	    self.find(".pintype").val(0);
    });

    // show or hide the "+" buttons throughout the table according to whether
    // the last "+" button in the last fake row was available
    $("#outputTab .addRow").css("display", disp);
}

   </script>

<!-- end of main config options section --------------------------------->
</div>

<!-- display raw configuration data for testing purposes -->
<!-- 
<hr>
<div id="rawconfig">
</div>
-->


<!-- navigation footer -------------------------------------------------->
<div id="navproxy"></div>
<div id="nav">
   <div>
      <div class="left">
	 <a class="iconButton" href="top.htm" id="mainMenuButton" title="Return to the main menu"><img src="homeIcon.png"></a>
      </div>
      <a class="button" href="#" id="programButton" title="Program these new settings into the KL25Z">Program KL25Z</a>
      <a class="button" href="#" id="revertButton" title="Discard changes and revert to current device settings">Revert</a>
      <div class="right">
	 <a class="iconButton" href="#" id="fileOpsButton" title="Save/restore settings to/from a disk file"><img src="saveIcon.png"></a>
	 <div id="fileOpsMenu" class="popupMenu" style="bottom: 1em; right: 1ex;">
	    <div title="Save these in-memory settings to a file" id="fileSaveButton">Save to file</div>
	    <div title="Load new in-memory settings from a file" id="fileLoadButton">Load file</div>
	    <hr>
	    <div title="Print this page" id="printButton">Print...</div>
	 </div>
      </div>
   </div>
</div>


<script>

$("#fileOpsButton").click(function(ev) {
    ev.preventDefault();
    ev.stopPropagation();
    var menu = $("#fileOpsMenu");
    menu.css({"display": "inline-block", "bottom": ($(this).outerHeight()/2)  + "px"});
    $("html,body").on("click.fileOpsButton", function() { hide(); });
    function hide() {
	$("html,body").off(".fileOpsButton");
	menu.css("display", "none");
    }
});

$("#mainMenuButton").click(function(ev) {
    if (uiDirty() && !window.external.DiscardCancelDialog(
	"You've made changes to the configuration that haven't been "
	+ "programmed into the device or saved to a backup file. If you "
	+ "leave now, you'll abandon this work.  Are you sure you want to "
	+ "discard your changes?"))
    {
	ev.preventDefault();
	return false;
    }
});
$("#revertButton").click(function(ev) {
    ev.preventDefault();
    if (window.external.DiscardCancelDialog(
	"This will discard all unsaved changes and return to the settings "
	+ "currently stored on the KL25Z. Are you sure you want to proceed?",
	"&Revert|Cancel"))
	configToUI(config, ConfigSource.Board);
});
$("#programButton").click(function(ev) {
    ev.preventDefault();
    programKL25Z();
});

$("#fileSaveButton").click(function(ev) {
    ev.preventDefault();

    // save the configuration and show the result message
    var uic = configFromUI();
    var result = eval(window.external.WriteConfigFile(
	CPUID, "Note: this is an in-memory working configuration", "browse",
	configToUSB(uic).join(";")));
    showCallResult(result);

    // if we were successful, remember this as the last saved configuration,
    // so that we don't bug the user about saving again if they leave without
    // making any further changes
    if (result.status == "ok")
	fileConfig = uic;
});

$("#fileLoadButton").click(function(ev) {
    ev.preventDefault();

    // read a config file
    var result = eval(window.external.ReadConfigFile(CPUID, "browse"));
    if (result.status == "ok")
    {
	// got it - make it active
	configToUI(result.config, ConfigSource.File);
	window.external.ShowAdviceDialog(
	    "RestoreSettings",
	    "The file settings have been loaded.  Note that the new settings "
	    + "are only in memory - nothing has been changed on the KL25Z yet. "
	    + "If you want to make these settings active on the device, click "
	    + "the \"Program KL25Z\" button.");

	// Remember this as the last saved configuration.  If the user
	// quits without making any changes, there's no need to bug them
	// about saving, since they can just load this same file again.
	fileConfig = result.config;
    }
    else
    {
	// error reading the file - show the message
	showCallResult(result);
    }
});

$("#printButton").click(function(ev) {
    ev.preventDefault();
    window.external.PrintPage();
});

</script>


<!-- Pin and output selector popup -------------------------------------->
<div class="windowCover">
   <div id="pinSelector">
      <div id="gpioSelector" class="pinSelectorPage">
	 <div id="lstKL25ZPins" class="pinlist"></div>
	 <div id="kl25zPinImg" class="pinimage">
	    <img src="kl25zPins.png">
	    <div id="kl25zOnBoardLED"></div>
	 </div>
      </div>
      <div id="tlc5940Selector" class="pinSelectorPage" data-pagetype="chip">
	 <div class="chipNo header" data-chip="0">Chip 1</div>
	 <div class="pinlist"></div>
	 <div class="pinimage">
	    <div class="chipIndexer background"></div>
	    <div class="chipIndexer foreground"></div>
	    <img src="tlc5940Pins.png">
	 </div>
      </div>
      <div id="hc595Selector" class="pinSelectorPage" data-pagetype="chip">
	 <div class="chipNo header" data-chip="0">Chip 1</div>
	 <div class="pinlist"></div>
	 <div class="pinimage">
	    <div class="chipIndexer background"></div>
	    <div class="chipIndexer foreground"></div>
	    <img src="74hc595Pins.png">
	 </div>
      </div>
      <div id="mainBoardDigitalOutputSelector" class="pinSelectorPage expBoardPinSelector" data-pagetype="board">
	 <div class="chipNo header" data-chip="0">JP9</div>
	 <div class="pinlist"></div>
	 <div class="pinimage">
	    <img src="mainBoardPins.png">
	 </div>
      </div>
      <div id="mainBoardPWMOutputSelector" class="pinSelectorPage expBoardPinSelector" data-pwm="true" data-pagetype="board">
	 <div class="chipNo header" data-chip="0">Flashers</div>
	 <div class="pinlist"></div>
	 <div class="pinimage">
	    <img src="mainBoardPins.png">
	 </div>
      </div>
      <div id="mainBoardInputSelector" class="pinSelectorPage expBoardPinSelector" data-pagetype="board">
	 <div class="chipNo header" data-chip="0">N/C</div>
	 <div class="pinlist"></div>
	 <div class="pinimage">
	    <img src="mainBoardPins.png">
	 </div>
      </div>
      <div id="powerBoardOutputSelector" class="pinSelectorPage expBoardPinSelector" data-pagetype="board">
	 <div class="chipNo header" data-chip="0">Board 1</div>
	 <div class="pinlist"></div>
	 <div class="pinimage">
	    <div class="chipIndexer background"></div>
	    <div class="chipIndexer foreground"></div>
	    <img src="powerBoardPins.png">
	 </div>
      </div>
      <div id="chimeBoardOutputSelector" class="pinSelectorPage expBoardPinSelector" data-pagetype="board">
	 <div class="chipNo header" data-chip="0">Board 1</div>
	 <div class="pinlist"></div>
	 <div class="pinimage">
	    <div class="chipIndexer background"></div>
	    <div class="chipIndexer foreground"></div>
	    <img src="chimeBoardPins.png">
	 </div>
      </div>
      <div id="virtualOutputSelector" class="pinSelectorPage">
	 <div>
	    A "virtual" output is a software port that isn't connected to
	    a physical output.  This can be used as a placeholder in your
	    DOF setup, or for a special function, such as the ZB Launch Ball
	    control port.
	 </div>
	 <div>
	    <div class="iconWithTitle button available" data-pin="NC "id="btnMakeVirtualPort">
	       <img src="virtualOutSmall.png">
	       <br>Virtual
	    </div>
	    <div class="iconWithTitle button available" data-pin="NC" id="btnMakeZBPort">
	       <img src="zbLaunch32.png">
	       <br>ZB Launch Port
	    </div>
	 </div>
      </div>
      <div id="pinTypeSelector">
	 <div id="pinTypePwmOut" data-page="gpioSelector" data-filter="pwm" data-pintype="1">
	    <img src="pwmout.png"><br>
	    GPIO<br>
	    PWM Out
	 </div>
	 <div id="pinTypeDigOut" data-page="gpioSelector" data-filter="dig-out" data-pintype="2">
	    <img src="digitalout.png"><br>
	    GPIO<br>
	    Digital Out
	 </div>
	 <div id="pinTypeSpiMosi" data-page="gpioSelector" data-filter="spi-mosi">
	    <img src="spiout.png"><br>
	    SPI (MOSI)
	 </div>
	 <div id="pinTypeSpiSclk" data-page="gpioSelector" data-filter="spi-sclk">
	    <img src="spiout.png"><br>
	    SPI (SCLK)
	 </div>
	 <div id="pinTypeAnalogIn" data-page="gpioSelector" data-filter="adc">
	    <img src="analogin.png"><br>
	    Analog In
	 </div>
	 <div id="pinTypeDigIn" data-page="gpioSelector" data-filter="dig-in">
	    <img src="digitalin.png"><br>
	    Digital In
	 </div>
	 <div id="pinType5940Out" data-page="tlc5940Selector" data-pintype="3">
	    <img src="tlc5940out.png"><br>
	    TLC5940 Out
	 </div>
	 <div id="pinType595Out" data-page="hc595Selector" data-pintype="4">
	    <img src="74hc595out.png"><br>
	    74HC595 Out
	 </div>
	 <div id="pinTypeMainBoardPWMOut" data-page="mainBoardPWMOutputSelector" data-pintype="1">
	    <img src="mainBoardOut.png"><br>
	    Main Board<br>PWM Out
	 </div>
	 <div id="pinTypeMainBoardDigitalOut" data-page="mainBoardDigitalOutputSelector" data-pintype="2">
	    <img src="mainBoardOut.png"><br>
	    Main Board<br>Digital Out
	 </div>
	 <div id="pinTypeMainBoardIn" data-page="mainBoardInputSelector">
	    <img src="mainBoardIn.png"><br>
	    Main Board
	 </div>
	 <div id="pinTypePowerBoardOut" data-page="powerBoardOutputSelector">
	    <img src="powerBoardOut.png"><br>
	    Power Board
	 </div>
	 <div id="pinTypeChimeBoardOut" data-page="chimeBoardOutputSelector">
	    <img src="chimeBoardOut.png"><br>
	    Chime Board
	 </div>
	 <div id="pinTypeVirtOut" data-page="virtualOutputSelector" data-pintype="5">
	    <img src="virtualout.png"><br>
	    Virtual Out
	 </div>
      </div>
   </div>
</div>



<!-- key selector popup ------------------------------------------------->
<div class="windowCover">
   <div id="keySelector">
      <div>
	 <div>
	    <div id="oskeyboard">
	    </div>
	    <div id="osunused">
	       <div>
		  Select this option if you don't want the button to send
		  any input to the PC when pressed.
	       </div>
	       <div id="unusedBtn" class="iconWithTitle">
		  <img src="unusedButton.png">
		  <br>No PC Input
	       </div>
	    </div>
	    <div id="osspecial">
	       <div>
		  Select special functions for the key, separate from
		  any PC input.
	       </div>
	       <div id="nightModeBtn" class="iconWithTitle"
		 title="Use this button to turn Night Mode on and off">
		  <img src="nightModeSmall.png">
		  <br>Night Mode
	       </div>
	    </div>
	    <div id="osjoystick">
	       <div class="topfill">
		  Joystick Buttons
	       </div>
	       <div class="jsBtnBox">
	       </div>
	    </div>
	 </div>
	 <div id="keytype">
	    <img id="keytypeJS" data-page="#osjoystick" title="Joystick Buttons" src="joystickicon.png">
	    <img id="keytypeKB" data-page="#oskeyboard" title="Keyboard Keys" src="keyboardicon.png">
	    <img id="keytypeUnused" data-page="#osunused" title="No PC Input" src="unusedButton.png">
	    <img id="keytypeSpecial" data-page="#osspecial" title="Special Function" src="specialicon.png">
	 </div>
      </div>
   </div>
</div>


<!-- main scripts ------------------------------------------------------->

<script>

// CPUID for the device - obtained from the URL parameters
var CPUID;

// Current device source configuration.  This is the last configuration
// we loaded from the device.
var config = { };

// Current saved file configuration.  This is the last configuration
// we saved to a file or loaded from a file.
var fileConfig = { };

// Program the current UI settings into the KL25Z
function programKL25Z()
{
    // check for pin assignment conflicts
    var w = getPinWarnings();
    if (w.length && !window.external.YesNoDialog(
	"The following items have conflicting pin assignments:\r\n\r\n"
	+ $.map(w, function(ele) { return ele.data("desc"); }).join("; ")
	+ "\r\n\r\n"
	+ "The controller might not work correctly if you program it with "
	+ "these conflicts unresolved.  Are you sure you wish to proceed?"))
	return;

    // now warn about overwriting the settings
    if (!window.external.YesNoDialog(
	"This will program the KL25Z with the new settings you've selected. "
	+ "The previous settings will be permanently overwritten. Are you "
	+ "sure you wish to proceed?"))
	return;

    // get the current UI configuration, and convert it to USB format
    var usb = configToUSB(configFromUI()).join(";");

    // save a backup copy first
    var res = eval(window.external.WriteConfigFile(
	CPUID, "Note: this is an in-memory working configuration", "backup",
	usb));

    // if that failed, show an error; say nothing if it succeeded
    if (res.status != "ok")
	showCallResult(result);

    // send the configuration to the KL25Z and display the result
    res = showCallResult(window.external.PutDeviceConfig(CPUID, usb));

    // if successful, the device is rebooting
    if (res.status == "ok")
	waitForReboot(CPUID);
}

// On closing the window, the C# container calls this custom method.
// We can return the string "cancel" to stop the event.
function OnCloseWindow()
{
    if (uiDirty() && !window.external.DiscardCancelDialog(
	"You've made changes to the configuration that haven't been "
	+ "programmed into the device or saved to a backup file. "
	+ "Quitting now will abandon this work.  Do you really want "
	+ "to discard these changes?"))
	return "cancel";
}

// Check for changes between the UI and device configuration
function uiDirty()
{
    // get the current UI configuration, normalized for comparison purposes
    var uic = normalizeConfig(configFromUI());

    // if it matches the device configuration or the last configuration
    // saved or loaded from a file, it's not dirty
    return !(valEq(uic, normalizeConfig(config)) || valEq(uic, normalizeConfig(fileConfig)));
}

// Compare two values, doing a deep comparison of properties of objects
function valEq(a, b)
{
    // NaN == NaN requires a special test
    if (isNaN(a) && isNaN(b) && typeof a == "number" && typeof b == "number")
	return true;
    
    // if they're identical primitives, they're equal
    if (a === b)
	return true;
    
    // compare certain non-primitive object types by string value
    if ((typeof a == "function" && typeof b == "function")
	|| (a instanceof Date && b instanceof Date)
	|| (a instanceof RegExp && b instanceof RegExp)
	|| (a instanceof String && b instanceof String)
	|| (a instanceof Number && b instanceof Number))
    {
	return a.toString() === b.toString();
    }
    
    // if they're objects, check them recursively
    if (typeof a == "object" && typeof b == "object")
    {
	// check that all properties of a are in b
	for (var p in a) {
	    if (!(p in b)) {
		//alert("p not in b: " + p); // debug
		return false;
	    }
	}

	// all a.p are in b; now check that all b.p equal a.p
	for (var p in b) {
	    if (!(p in a) || !valEq(a[p], b[p])) {
		//alert((p in a) ? "vals differ: " + p : "p not in a: " + p); // debug
		return false;
	    }
	}

	// no differences found
	return true;
    }
    
    // consider anything else unequal
    return false;
}

// page initialization
$(function() {

    // note the browser scrollbar width
    var sbwid = getScrollBarWidth();

    // set up DOF Config Tool links
    $("a.dofconfigtool")
	.attr("href", "http://configtool.vpuniverse.com/")
	.attr("target", "_blank");

    // Initialize the pin selector dialog
    pinSelectorSetup();

    // initialize the config functions
    configFunctionSetup();

    // set up number input "spinner" controls
    $("#numMainBoards,#numPowerBoards,#numChimeBoards").spinner({min: 0, max: 8});
    $("#txtRebootTime").spinner({min: 1, max: 255});
    $("#zbPort").spinner({min: 1, max: 128});
    $("#tlc_nchips").spinner({min: 0, max: 8});
    $("#hc595_nchips").spinner({min: 0, max: 8});
    $("#nightModeOutputNo").spinner({min: 0, max: 128});
    $("#shiftButton, #nightModeButtonNo").spinner({min: 0, max: 128});

    // set spinner change listeners
    $("#numMainBoards, #numPowerBoards, #numChimeBoards, #zbPort, #tlc_nchips, "
      + "#hc595_nchips, #nightModeButtonNo, #nightModeOutputNo, #shiftButton").on(
	"spinstop", function() { $(this).change(); });

    // Retrieve the device ID from the URL.  The ID= parameter encodes
    // the KL25Z CPU ID, which we use as the primary key to identify
    // the device through the C# callback API.  This is effectively a
    // GUID for the device - it's permanently fixed in the device (in
    // ROM set at the factory), and it's guaranteed to be unique among
    // all Freescale devices.
    if (/[?&]ID=([\da-f\-]+)/i.test(window.location.href))
    {
	// set the CPU ID
	CPUID = RegExp.$1;
	$("#CPUID").text(CPUID);

	// loop until we get the configuration or the user cancels
	for (;;)
	{
	    // retrieve the current device configuration
	    var c = window.external.GetDeviceConfig(CPUID);

	    // if we got it, we're done
	    if (c)
		break;

	    // failed - ask if they want to try again
	    if (window.external.RetryCancelDialog(
		"An error occurred loading the device settings. Do you want to "
		+ "try again?"))
	    {
		// cancel - set a timeout to navigate back to the main menu
		setTimeout(function() { window.navigate("top.htm"); }, 1);

		// no need to do any more page initialization, as we're not staying
	        return;
	    }
	}
	
	// parse the config data
	config = eval(c);
	
	// display the raw configuration in the debugging section, if present
	$("#rawconfig").text(c);
	
	// load the config into the UI
	configToUI(config, ConfigSource.Board);
	
	$("#loadingOverlay").parent().hide();
    }

    function pinSelectorSetup()
    {
	// get the dialog
	var pindlg = $("#pinSelector");

	// Set up button objects on top of the KL25Z popup image.  This
	// allows selecting pins by pointing to them on the picture.
	var btndiv = $("#kl25zPinImg");
	var xpad = parseInt($("#kl25zPinImg img").css("padding-left"));
	var ypad = parseInt($("#kl25zPinImg img").css("padding-top"));
	$.each(kl25z_headers, function(k, v) {
	    forEachPin(v, function(pin, n, x, y) {
		// find the gpioPin entry for the pin
		var g = (gpioPinsByName[pin] || { });
		var jumper = g.internalShortName || k + "-" + n;
		var hover = pin + " (" + jumper + ")";
		
		// Build the pin button.  Note the 8-pixel adjustment to the top and left
		// position: this is because the coordinates in the header descriptor are
		// for the CENTER of the pin on the image.  Our button divs are 16px wide,
		// so we center them by subtracting 8px from each coordinate.
		var posname = k + "-" + n;
		btndiv.append(
		    "<div class=\"pinButton\" "
		    + "data-pin=\"" + pin + "\" "
		    + "data-hovername=\"" + hover + "\" "
		    + "title=\"" + pin + (posname != "N/A" ? " (" + posname + ")\" " : "")
		    + "style=\"left: " + (x + xpad - 8) + "px; top: " + (y + ypad - 8) + "px;\">"
		    + "</div>");

		// set the header reference in the GPIO pin entry
		if (g)
		    g.pin = { name: posname, x: x, y: y };
	    })
	});

	// Build the KL25Z pin selection list
	var pinlst = $("#lstKL25ZPins");
	var options = [];
	options.push("<div data-pin=\"Not Connected\">Not Connected</div>");
	for (var i = 0 ; i < gpioPins.length ; ++i)
	{
	    var g = gpioPins[i];
	    var hovername = g && (g.internalShortName || g.pin && g.pin.name);
	    hovername = hovername && "data-hovername=\"" + hovername + "\"";

	    options.push(
		"<div data-pin=\"" + g.name + "\" " + hovername + "\">"
		+ g.name + "</div>");
	}
	pinlst.html(options);

	// move the on-board LED display according to the padding
	var obl = $("#kl25zOnBoardLED");
	obl.css("left", (parseInt(obl.css("left")) + xpad) + "px")
	    .css("top", (parseInt(obl.css("top")) + ypad) + "px");

	// add event handlers the KL25Z GPIO pin list elements and image buttons
	addPinEvents(pinlst, $("#kl25zPinImg"), $("#kl25zPinImg .pinButton, #lstKL25ZPins > div"));

	// Add hover and click handlers to pin list items or gpio pins.
	// 'container' is a jquery set with the list container.
	// 'picdiv' is a jquery set with the graphical pin container.
	// 'items' is a jquery set with the list items and/or pins to
	//    set up with event handlers.
	function addPinEvents(list, picdiv, items)
	{
	    // add hover handlers to the list items
	    items.off("mouseenter mouseleave").hover(
	        function() {
		    // remove 'hover' status from all pins and list items
		    list.children().removeClass("hover");
		    picdiv.children(".pinButton").removeClass("hover");

		    // sync the list and pin pad image if the pin is available
		    var self = $(this);
		    if (self.hasClass("available"))
		    {
			// get this pin name
			var pin = self.data("pin");
			var finder = function() { return $(this).data("pin") == pin; }
			
			// set hover state on the matching list item and pin button
			picdiv.children().filter(finder).addClass("hover");
			var listele = list.children().filter(finder);
			listele.addClass("hover");

			// if this is one of the on-board LED pins, turn on the LED
			// display to the appropriate color while hovering
			var g = gpioPinsByName[pin];
			if (g && g.onBoardLED) {
			    $("#kl25zOnBoardLED").css(
				"background-position", "0px " + (-g.onBoardLED*40) + "px");
			}
			
			// If the event is from an image button, scroll the list item
			// into view after a brief delay.  The delay is to avoid making
			// the list jump around when the mouse sweeps over the pin image
			// on its way somewhere else - we only scroll the list when the
			// mouse is at least briefly stationary over a pin.
			if (self.hasClass("pinButton") && self.hasClass("available"))
			{
			    // set a sequence number to compare when the timeout expires
			    var seqno = 1 + (self.data("hoverseq") || 0);
			    self.data("hoverseq", seqno);
			    
			    // Set a timeout for the delay.  When it expires, it we're
			    // still hovering over the same item and the sequence number
			    // is the same, do the scrolling.  If we're not still hovering,
			    // it means that the mouse has left since we started the timer,
			    // so don't do the scrolling after all.  If the sequence number
			    // has changed, it means that the mouse has left and come back,
			    // in which case the mouse hasn't been stationary for the whole
			    // interval and hence we don't want to do the scrolling.
			    setTimeout(function() {
				if (self.hasClass("hover") && self.data("hoverseq") == seqno)
				    scrollIntoView(listele, 100, { top: list.prev(".header").outerHeight() });
			    }, 250);
			}
		    }
	        },
		function() {
		    // get the pin name
		    var pin = $(this).data("pin");
		    var finder = function() { return $(this).data("pin") == pin; };

		    // turn off the on-board LED if it was on
		    var g = gpioPinsByName[pin];
		    if (g && g.onBoardLED)
			$("#kl25zOnBoardLED").css("background-position", "0px 0px");

		    // remove hover state from the list item and image button
		    picdiv.children().filter(finder).removeClass("hover");
		    list.children().filter(finder).removeClass("hover");
	        }

	    ).click(function() {
		// on click, select the item and dismiss the dialog
		pinselect($(this), false, true);
	    });
	}

	// click the "Mark Virtual" button on the virtual output type page
	$("#btnMakeVirtualPort").click(function(ev) {
	    ev.preventDefault();
	    pinselect($(this), false, true);
	});

	// click the "Make ZB port" button on the virtual output type page
	$("#btnMakeZBPort").click(function(ev) {
	    ev.preventDefault();
	    $("#zbEnabled").prop("checked", true).change();
	    $("#zbPort").val(curpin.parents(".outPortRow").data("idx")).change();
	    pinselect($(this), false, true);
	});

	// table of pin adjustor functions for the various pages
	var chipPinPageAdjustor = { };

	// set up the TLC5940 selection list and image buttons
	initChipPinPageAdjustor("tlc5940Selector", "3", $("#tlc_nchips"), 16);
	buildChipPinButtons($("#tlc5940Selector"), tlc5940_pins, "3", 10, 16);
	
	// Build the 74HC595 selection list and image buttons
	initChipPinPageAdjustor("hc595Selector", "4", $("#hc595_nchips"), 8);
	buildChipPinButtons($("#hc595Selector"), hc595_pins, "4", 20, 20);

	// Get an adjustor function for a chip pin list.  Call the function
	// on opening the dialog page to populate the list with new pins
	// as needed.
	function initChipPinPageAdjustor(pageName, pintype, numChipsField, pinsPerChip)
	{
	    // we haven't built any of these yet
	    var numChips = 0;

	    // set up the adjustor function, and store it in the table so
	    // that showChipPinPage() can automatically call it
	    chipPinPageAdjustor[pageName] = function()
	    {
		// if the number of chips is different from last time, update it
		var newNumChips = +numChipsField.val();
		if (newNumChips != numChips)
		{
		    // add new pins as needed
		    var page = $("#" + pageName);
		    buildChipPinList(page, pintype, numChips, newNumChips, pinsPerChip);
		    
		    // hide chips and pins that aren't currently available
		    page.find(".chipNo, .chipPin").each(function() {
			var self = $(this);
			self.toggle(+self.data("chip") < newNumChips);
		    });
		}

		// remember the new chip count
		numChips = newNumChips;
	    };
	}

	// Build the pin image buttons for a chip layout
	function buildChipPinButtons(page, pins, pintype, wid, ht)
	{
	    // get the image padding
	    var picdiv = page.find(".pinimage");
	    var img = picdiv.find("img");
	    var xpad = parseInt(img.css("padding-left"));
	    var ypad = parseInt(img.css("padding-top"));

	    // add each pin
	    forEachPin(pins, function(pin, n, x, y)
	    {
		// only the OUTn pins are available as outputs
		var available = /^OUT(\d+)$/i.test(pin);
		var pinno = (available ? RegExp.$1 : "");
		
		// add the button
		picdiv.append(
		    "<div class=\"pinButton " + (available ? "available" : "") + "\" "
		    + (available ?
		       "data-pin=\"" + pinno + "\" data-basepin=\"" + pinno + "\" "
		       + "data-pintype=\"" + pintype + "\" data-hovername=\"" + pin + "\" "  :
		       "")
		    + "title=\"" + pin + "\" "
		    + "style=\"left: " + (x + xpad - wid/2) + "px; top: " + (y + ypad - ht/2) + "px;\">"
		    + "</div>");
	    });

	    // add hover and click handlers
	    addPinEvents(page.find(".pinlist"), picdiv, picdiv.find(".pinButton"));
	}

	// Build one of the chip pin lists (TLC5940, 74HC595)
	function buildChipPinList(page, pintype, nchipsOld, nchipsNew, pinsPerChip)
	{
	    // Build a section for each copy of the chip.  Internally, the
	    // pins are numbered consecutively across chips starting at 0 for
	    // the first pin on the first chip.
	    buildGroupedPinList(
		page,
		[{ oldcopies: nchipsOld, copies: nchipsNew, pins: pinsPerChip,
		  header: "Chip 1", pinname: "OUT0", pintype: pintype }
	        ]);

	    // build the chip indexer
	    buildChipIndexer(page, nchipsNew, pinsPerChip);
	}

	// Build a chip/board indexer for an output selector page that can have
	// multiple copies of the chip/board.
	function buildChipIndexer(page, nChips, pinsPerChip)
	{
	    // build the list of chip index buttons
	    var idxlst = [];
	    for (var i = 0 ; i < nChips ; ++i)
		idxlst.push("<div data-idx=\"" + i + "\">" + (i+1) + "</div>");
				       
	    // Build the chip index buttons.  This allows selecting among
	    // multiple copies of the chip in the graphical pin layout view.
	    var picdiv = page.find(".pinimage");
	    picdiv.find(".chipIndexer.foreground").html(idxlst);
	    
	    // Add click handlers for the indexer buttons
	    picdiv.find(".chipIndexer.foreground div").click(function(ev) {
		switchChip(page, $(this).data("idx"), pinsPerChip);
	    });
	}
		
	// Build a grouped pin list.
	//
	// 'page' is the selector page element.
	//
	// 'sections' is a list of pin sections descriptor objects:
	//
	//     .copies = number of copies of this section to build
	//     .oldcopies = pre-existing number of copies; we'll add new pins only
	//     .pins = number of pins in each copy of the section
	//     .header = function(copyIndex) returning header name string
	//     .pinname = function(pinIndex, copyIndex) returning pin name string
	//     .pinid = function(pinIndex, copyIndex) returning the data-pin value
	//     .pintype = default pin type code for the pins in this group, used if
	//         the .pinid value doesn't have a type prefix
	//     .hovername = function(pinName, pinIndex, copyIndex) returning the hover
	//         name for the list item; pinName is the name returned by .pinname
	//
	// header, pinname, and pinid can be simple strings instead of functions.
	// In this case, '0' and '1' are replaced with the 0-based or 1-based index
	// for (respectively) the item (copy number in the case of the header, pin
	// number in the case of the pin name or ID).
	//
	// If pinid isn't specified, the default is the current *overall* pin
	// number, starting at 0 for the first pin on the first copy, and incrementing
	// on every pin, continuously across copies.  E.g., if there are 8 pins per
	// copy, the first chip's pins are numbered 0-7, the second 8-15, etc.
	//
	// The pinid value can be specified with or without an output type prefix.
	// If provided, the type prefix follows our normal convention: USB type code
	// + "." + pin name.  E.g., GPIO Digital Out PTC8 is "2.PTC8".  If the type
	// isn't provided, we simply use the type code from the page for all pins.
	function buildGroupedPinList(page, sections)
	{
	    var html = [];
	    $.each(sections, function(sectionIdx, section)
	    {
		// Get the header function.  If it's specified as a string, set up
		// a function that replaces 0 or 1 in the string with the copy index.
		var header = section.header;
		if (typeof header == "string") {
		    header = function(copyIndex) {
			return section.header.replace(/[01]/, function(m) { return (+m) + copyIndex; });
		    };
		}

		// Get the pin name function, providing a string substitution function
		// if needed.
		var pinname = section.pinname;
		if (typeof pinname == "string") {
		    pinname = function(pinIndex, copyIndex) {
			return section.pinname.replace(/[01]/, function(m) { return (+m) + pinIndex; });
		    };
		}

		// Get the pin ID function, providing a substitution function
		var pinid = section.pinid;
		if (typeof pinid == "undefined") {
		    pinid = function(pinIndex, copyIndex) { return pin; };
		}
		else if (typeof pinid == "string") {
		    pinid = function(pinIndex, copyIndex) {
			return section.pinid.replace(/[01]/, function(m) { return (+m) + pinIndex; });
		    };
		}

		// note the number of existing copies
		var oldcopies = section.oldcopies || 0;

		// run through the copies
		for (var i = oldcopies, pin = oldcopies * section.pins ; i < section.copies ; ++i)
		{
		    // add the section header
		    html.push("<div class=\"chipNo\" data-chip=\"" + i + "\">" + header(i) + "</div>");

		    // add each pin in the section
		    for (var j = 0 ; j < section.pins ; ++j, ++pin)
		    {
			// Get the pin ID
			var curPinId = pinid(j, i);

			// get the hover name, if any
			var hover = section.hovername && section.hovername(curPinId, j, i);

			// If the pin ID has a type prefix ("number."), pull it out
			// for a data-pintype attribute
			var curPinType = section.pintype;
			if (/^(\d+)\.(.*)$/.test(curPinId)) {
			    curPinType = RegExp.$1;
			    curPinId = RegExp.$2;
			}

			// generate the list entry
			html.push("<div class=\"chipPin available\" "
				  +   "data-pin=\"" + curPinId + "\" "
				  +   "data-pintype=\"$1\" ".formatOrEmpty(curPinType)
				  +   "data-hovername=\"$1 \" ".formatOrEmpty(hover)
				  +   "data-chip=\"" + i + "\">"
				  +   pinname(j, i)
				  + "</div>");
		    }
		}
	    });
		
	    // add the new list to the container
	    var list = page.find(".pinlist");
	    list.append(html);
	    
	    // initialize scrolling headers
	    initScrollHeader(list, list.find(".chipNo"));
	    
	    // Attach hover and click handlers to the pins
	    var picdiv = page.find(".pinimage");
	    addPinEvents(list, picdiv, list.find(".chipPin"));
	}

	// figure the hover name for a main board pin list item
	function mainBoardHoverName(pin)
	{
	    // if there's an out port alias, return the jumper entry
	    var alias = expOutPortAlias[pin];
	    return alias ? alias.split("|")[3] : undefined;
	}

	// Build the main board digital output list
	buildGroupedPinList($("#mainBoardDigitalOutputSelector"), [
	    { copies: 1, pins: 1, header: "Knocker",
	      pinname: function(pin) { return ["Knocker"][pin]; },
	      pinid: function(pin) { return ["2.PTC8"][pin] },
	      hovername: mainBoardHoverName
	    },
	    { copies: 1, pins: 4, header: "Extender", pinname: "Extender 1",
	      pinid: function (pin) { return ["2.PTC4", "2.PTC3", "2.PTC0", "2.PTA2"][pin]; },
	      hovername: mainBoardHoverName
	    },
	    { copies: 1, pins: 6, header: "Plunger",
	      pinname: function(pin) { return ["Plunger 1", "Plunger 2", "Plunger 3", "Plunger 4", "Cal Button", "Cal LED"][pin]; },
	      pinid: function(pin) { return ["PTB0", "PTE20", "PTE21", "PTE22", "PTE29", "PTE23"][pin]; },
	      hovername: mainBoardHoverName
	    },
	]);
	buildBoardPinButtons($("#mainBoardDigitalOutputSelector"), mainBoard_headers, true);
	    
	// Build the main board PWM output list
	buildGroupedPinList($("#mainBoardPWMOutputSelector"), [
	    { copies: 1, pins: 15, header: "Flashers",
	      pinname: function(pin) { return (Math.floor(pin/3)+1) + "RGB".substr(pin % 3, 1) },
	      pinid: function(pin) { return "3." + pin; },
	      hovername: mainBoardHoverName
	    },
	    { copies: 1, pins: 1, header: "Strobe",
	      pinname: function(pin) { return ["Strobe"][pin]; },
	      pinid: function(pin) { return ["3.15"][pin] },
	      hovername: mainBoardHoverName
	    },
	    { copies: 1, pins: 16, header: "RGB Flippers",
	      pinname: function(pin) { return (pin < 15 ? (Math.floor(pin/3)+1) + "RGB".substr(pin %3, 1) : "6"); },
	      pinid: function(pin) { return "3." + (16 + pin); },
	      hovername: mainBoardHoverName
	    },
	    { copies: 1, pins: 3, header: "Extender",  // extender port JP12 - only pins 1, 2, and 4 are PWM capable
	      pinname: function(pin) { return "Extender " + [1, 2, 4][pin]; },
	      pinid: function (pin) { return ["1.PTC4", "1.PTC3", "1.PTA2"][pin]; },
	      hovername: mainBoardHoverName
	    },
	    { copies: 1, pins: 6, header: "Plunger",
	      pinname: function(pin) { return ["Plunger 1", "Plunger 2", "Plunger 3", "Plunger 4", "Cal Button", "Cal LED"][pin]; },
	      pinid: function(pin) { return ["PTB0", "PTE20", "PTE21", "PTE22", "PTE29", "PTE23"][pin]; },
	      hovername: mainBoardHoverName
	    },
	]);
	buildBoardPinButtons($("#mainBoardPWMOutputSelector"), mainBoard_headers, true);
	    
	// Build the main board input list
	buildGroupedPinList($("#mainBoardInputSelector"), [
	    { copies: 1, pins: 1, header: "N/C", pinname: "Not Conn", pinid: "Not Connected",
	      hovername: function() { return "Not Connected"; }
	    },
	    { copies: 1, pins: 24, header: "Buttons", pinname: "Button 1",
	      pinid: function(pin) { return expansionBoardFactoryConfig.buttons[pin+1].pin; },
	      hovername: mainBoardHoverName
	    },
	    { copies: 1, pins: 4, header: "Extender", pinname: "Extender 1",
	      pinid: function(pin) { return ["PTC4", "PTC3", "PTC0", "PTA2"][pin]; },
	      hovername: mainBoardHoverName
	    },
	    { copies: 1, pins: 5, header: "Plunger",
	      pinname: function(pin) { return ["Plunger 1", "Plunger 2", "Plunger 3", "Plunger 4", "Cal Button"][pin]; },
	      pinid: function(pin) { return ["PTB0", "PTE20", "PTE21", "PTE22", "PTE29"][pin]; },
	      hovername: mainBoardHoverName
	    },
	]);
	buildBoardPinButtons($("#mainBoardInputSelector"), mainBoard_headers, true);

	// Build the power board pin list
	buildBoardPinButtons($("#powerBoardOutputSelector"), powerBoard_headers, false);
	initBoardPinPageAdjustor(
	    "powerBoardOutputSelector", $("#numPowerBoards"), "3.", 32, 32);

	// Build the chime board pin list when we add or remove board
	buildBoardPinButtons($("#chimeBoardOutputSelector"), chimeBoard_headers, false);
	initBoardPinPageAdjustor(
	    "chimeBoardOutputSelector", $("#numChimeBoards"), "4.", 8, 0);

	// Initialize the page adjustor for one of the output boards
	function initBoardPinPageAdjustor(
	    pageName, numBoardsField, typePrefix, outputsPerBoard, startingOutput)
	{
	    // we haven't built any of these yet
	    var numBoards = 0;

	    // set up the adjustor function, and store it in the table so
	    // that showChipPinPage() can automatically call it
	    chipPinPageAdjustor[pageName] = function()
	    {
		// if the number of chips is different from last time, update it
		var newNumBoards = +numBoardsField.val();
		if (newNumBoards != numBoards)
		{
		    // add new pins as needed
		    var page = $("#" + pageName);
		    buildGroupedPinList(page, [
		        { copies: newNumBoards, oldcopies: numBoards,
			  pins: outputsPerBoard, header: "Board 1", pinname: "Output 1",
			  pinid: function(pin, board) {
			      return typePrefix + (board*outputsPerBoard + startingOutput + pin);
		          },
			  hovername: function(pinName, pinNo) { 
			      return "JP" + (Math.floor(pinNo/16)+5) + "-" + ((pinNo%16)+1);
			  }
			}
		    ]);
		    
		    // hide boards and pins that aren't currently available
		    page.find(".chipNo, .chipPin").each(function() {
			var self = $(this);
			self.toggle(+self.data("chip") < newNumBoards);
		    });

		    // rebuild the board indexer
		    buildChipIndexer(page, newNumBoards, outputsPerBoard);
		}

		// remember the new chip count
		numBoards = newNumBoards;
	    };
	}

	// Build the pin buttons for an expansion board pin selector.
	//
	// Header pins can be specified as GPIO port names or our usual
	// "n.m" output port codes (e.g., "3.7" for TLC5940 output port 7).
	// GPIO ports are untyped because they take their type from the
	// page context.  All other outputs must be typed.
	//
	// For a repeatable board, such as the power board or chime board,
	// the port number specified in a typed output will serve as the
	// base port number.  On second and subsequent instances of the
	// board, we'll bump up the actual port numbers by the number of
	// such ports on the board.
	//
	// If filterToList is true, we'll only make buttons available if
	// they appear in the page's list.
	function buildBoardPinButtons(page, headers, filterToList)
	{
	    // get the image padding
	    var picdiv = page.find(".pinimage");
	    var img = picdiv.find("img");
	    var xpad = parseInt(img.css("padding-left"));
	    var ypad = parseInt(img.css("padding-top"));

	    // if filtering to the list, build a table of the pins in list
	    var listPins = { };
	    if (filterToList) {
		page.find(".pinlist .chipPin").each(function()
		{
		    var self = $(this);
		    var t = self.data("pintype");
		    var p = self.data("pin");
		    listPins[(t && t != 1 && t != 2 ? t + "." + p : p)] = true;
		});
	    }

	    // add each pin
	    $.each(headers, function(jpName, header) {
		forEachPin(header, function(pin, n, x, y)
		{
		    // Our headers are populated with all pin names, but
		    // we can only assign pins tied to GPIO ports (PTxx names)
		    // or peripheral outputs (3.xx = TLC5940 output, 4.xx =
		    // 74HC595 output).
		    var dataPin = "", available = " available";
		    if (/^PT[A-E]\d+$/i.test(pin)) {
			dataPin = "data-pin=\"" + pin + "\"";
			var g = (expGpioPortAlias[pin] || "").split("|");
			dataHover = "data-hovername=\"" + g[0] + " (" + g[1] + ")\"";
			if (filterToList && !listPins[pin])
			    available = "";
		    }
		    else if (/^([34])\.(\d+)$/.test(pin)) {
			dataPin = "data-pin=\"" + RegExp.$2 + "\" "
				  + "data-pintype=\"" + RegExp.$1 + "\" "
				  + "data-basepin=\"" + RegExp.$2 + "\" ";
			var g = expOutPortAlias[pin].split("|");
			dataHover = "data-hovername=\"" + g[0] + " (" + g[1] + ")\"";
			if (filterToList && !listPins[pin])
			    available = "";
		    }
		    else {
			available = "";
		    }

		    // add the item
		    picdiv.append(
			"<div class=\"pinButton" + available + "\" "
			+ dataPin + dataHover
			+ "style=\"left: " + (x + xpad - 6) + "px; top: " + (y + ypad - 6) + "px;\">"
			+ "</div>");
		})
	    });

	    // add hover and click handlers
	    addPinEvents(page.find(".pinlist"), picdiv, picdiv.find(".pinButton"));
	}

	// Initialize a scrolling list with a section header.  The list
	// is structured into sections with header elements, given by
	// the jQuery set 'sections'.  As we scroll through the list, we
	// "pin" the current section's header at the top of the list,
	// so that the current section header is always visible.
	//
	// There's no native way to do this with browser objects, so we
	// use some special effects.  To make this work, the list needs
	// a special position:absolute item just *before* the container
	// element.  This is the fixed-in-place header.  It has to be
	// absolutely positioned at the top of the list, and it has to
	// be sized to match the list interior width and header element
	// height.  It should also use the same class as the 'sections'
	// elements so that it looks the same.
	//
	// On each scroll event, we look to see if a section header in
	// the list overlaps the position:absolute fixed header element.
	// If so, we move the header element up so that it looks like
	// the next section header is pushing it off the screen as it
	// scrolls up.  When the next section header is at the very
	// top, we restore the fixed header to its normal pinned
	// position and change its text to match the new current
	// section.
	//
	// The result is that it *looks* like each section header
	// scrolls to the top and then sticks there.  What's really
	// happening is that we have just the one sticky element that
	// we relabel to match the current section.
	//
	// NB: to make the "nudge" effect work, the container has to
	// be wrapped in another container of the same size with
	// overflow:hidden.
	function initScrollHeader(container, sections)
	{
	    var hdr = container.prev().filter(".header");
	    container.off("scroll.scrollHeader").on("scroll.scrollHeader", function()
	    {
		// assume that the first section is current
		var ele = sections.first();

		// scan the section headers to find the first one still in view
		sections.each(function(idx)
		{
		    // get this section header's position and height
		    var self = $(this);
		    var y = self.position().top;
		    var ht = self.outerHeight();

		    // Check to see if it's in view, out of view, or overlapping
		    // the fixed header area.
		    if (y < 0 && idx+1 == sections.length)
		    {
			// This is the last item, and it's going out of view.  It's
			// now the fixed header item.
			hdr.css("top", "").text(self.text());
		    }
		    else if (y > 0 && y < ht)
		    {
			// It overlaps the fixed header area.  This means that we're
			// in a transition between sections.  Create the special effect
			// that makes it look like the next and previous headers are
			// moving together, by positioning the fixed element so that
			// it abuts this header above.  This will make it look like
			// it's scrolling along with the list, even though it's really
			// the position:absolute foreground element.
			hdr.css("top", (y-ht) + "px").text(ele.text());
			return false;
		    }
		    else if (y >= ht)
		    {
			// This header is completely in view.  Set the fixed header
			// so that it's at its normal position - this looks like a
			// regular section header that's sticking at the top of the
			// list.  Set the fixed header text to the *previous* section
			// text - the first item in view within the scrolling area
			// is part of the previous section, since the current section
			// is the first one that's in view.
			hdr.css("top", "").text(ele.text());
			return false;
		    }
		    else
		    {
			// The current element is completely out of view.  Remember
			// this as the previous element and keep going.
			ele = self;
		    }
		});
	    });
	}

	// initialize all pin selector controls
	$(".pinselect").data("active", true).each(function()
	{
	    // set up the current value and warning icon spans
	    $(this).html("<input class=\"pinval\" readonly>"
			 + "<span class=\"pinwarn\"><img src=\"pinwarn.png\"></span>");

	    // add an expansion board alias field, if requested
	    if ($(this).hasClass("withExpBoardAlias"))
	    {
		// mark the input as an expansion board pin (to be hidden in
		// expansion board mode), and add the alias field
		$(this).children("input").addClass("expBoardPin").after(
		    "<input class=\"expBoardAlt\" readonly>");
	    }
	});

	// Handle clicks in GPIO pin selectors.  These selectors all select
	// a GPIO pins with one specific function (PWM out, digital in,
	// ADC in, etc), show we show only the page for that function.  All
	// other page buttons are hidden, since it's not possible to change
	// the pin type for a specific functional assignment.
	$(".pinselect").click(function(ev)
	{
	    // remove focus from the field, so that the text cursor isn't
	    // flashing while the dialog is visible
	    var self = $(this);
	    self.children(".pinval").blur();

	    // show the pin selector dialog with the KL25Z page
	    showPinSelector(self);

	    // Show only the appropriate KL25Z page select button.  A .pinselect
	    // field is tied to a particular pin type, so we only need to show
	    // the one button that's appropriate to the type.  For all .pinselect
	    // fields, include a Not Connected option in the pin list.
	    var gpiotype = (self.data("gpiotype") + " nc").split(" ");
	    $("#pinTypeSelector > div").each(function() {
		var vis = $(this).data("page") == "gpioSelector" && $(this).data("filter") == gpiotype[0];
		$(this).toggle(vis).toggleClass("selected", vis);
		if (vis)
		    selectPage($(this), true, gpiotype);
	    });
	});

	// On clicking a button input selector expansion board alias field,
	// show a pin selector.  Show the main expansion board page, and also
	// show the direct KL25Z input selector as an alternative.
	$("#buttonTab input.expBoardAlt").click(function(ev)
	{
	    // don't propagate the event to the parent, since it would reopen
	    // the dialog in plain KL25Z mode
	    ev.preventDefault();
	    ev.stopPropagation();
	    
	    // remove focus from the field, to prevent flashing cursors in the dialog
	    var self = $(this);
	    self.blur();
	    
	    // Show the pin selector
	    showPinSelector(self.parents(".pinselect"));
	    
	    // Make the KL25Z digital input page and expansion board input
	    // pages visible, and start with the expansion board page active.
	    $("#pinTypeSelector > div").each(function() {
		var btn = $(this);
		var pageName = btn.data("page");
		var sel = (pageName == "mainBoardInputSelector");
		var vis = sel;
		if (pageName == "gpioSelector" && btn.data("filter") == "dig-in") {
		    btn.data("curfilter", ["dig-in", "extern", "nc"]);
		    vis = true;
		}
		btn.toggle(vis).toggleClass("selected", sel);
		if (sel)
		    selectPage(btn, true, null);
	    });
	});

	// Handle clicks in the output controller pin selectors.  These
	// selectors can choose any type of output pin (PWM out, digital out,
	// virtual out, TLC5940 out, 74HC595 out).  In expansion board mode,
	// we add pages for the expansion boards.
	$("#outputTab .pinlabel, #outputTab .dispPinFunc, "
	  + "#outputTab .dispPinType, #outputTab .dispPinLoc,"
	  + "#outputTab .dispPinHeader, #outputTab .dispPinName").click(function(ev)
	{
	    // remove focus from the field
	    var self = $(this);
	    var row = self.parents(".outPortRow");
	    row.find(".dispPinName").blur();

	    // show the dialog
	    showPinSelector(row.find(".dispPinName").parent());

	    // note the hardware mode (0=standalone, 1=expansion boards)
	    var hwType = +$("input:radio[name=hardwareType]:checked").val();

	    // get the selected row's pin and type, and the out port alias string
	    var pintype = row.find(".pintype").val();
	    var pinid = row.find(".pinval").val();
	    var alias = (outPortAlias[pintype + "." + pinid] || "").split("|");

	    // Show only the page select buttons for output pin types.
	    var page;
	    var foundSelected = false;
	    $("#pinTypeSelector > div").each(function()
	    {
		// get this button's dialog page name and the output type
		var pageName = $(this).data("page");
		var outtype = $(this).data("pintype");

		// figure out if this button is visible
		var vis = false;
		switch (pageName)
		{
		case "gpioSelector":
		    // KL2Z GPIO pages - enable for the PWM and Digital Out pins
		    vis = (outtype == 1 || outtype == 2);
		    break;

		case "tlc5940Selector":
		    // TLC5940.  This type is visible in standalone mode if we
		    // have any TLC5940 chips in the current configuration.
		    // In expansion board mode, we do have 5940 outputs, but we
		    // select these through the expansion board pages instead.
		    vis = (hwType == 0 && +$("#tlc_nchips").val() > 0);
		    break;

		case "hc595Selector":
		    // 74HC595.  Visible in standalone mode if we have any of
		    // these chips.
		    vis = (hwType == 0 && +$("#hc595_nchips").val() > 0);
		    break;

		case "virtualOutputSelector":
		    // Virtual out - always visible
		    vis = true;
		    break;

		case "mainBoardDigitalOutputSelector":
		    // Main expansion board digital outputs.  Enable in expansion
		    // board mode.
		    vis = (hwType == 1);
		    break;

		case "mainBoardPWMOutputSelector":
		    // Main expansion board PWM outputs.  Enable in expansion
		    // board mode.
		    vis = (hwType == 1);
		    break;

		case "powerBoardOutputSelector":
		    // Power board outputs.  Enable in expansion board mode if we
		    // have at least one power board.
		    vis = (hwType == 1 && +$("#numPowerBoards").val() > 0);
		    break;

		case "chimeBoardOutputSelector":
		    // Chime board outputs.  Enable in expansion board mode if we
		    // have at least one chime board.
		    vis = (hwType == 1 && +$("#numChimeBoards").val() > 0);
		    break;
		}

		// Determine if this page is selected.  Use only the first
		// selected page we find.
		var selected = false;
		if (!foundSelected)
		{
		    switch (hwType)
		    {
		    case 0:
		    default:
			// Standalone mode.  Each page in this mode selects a single
			// output pin type, so we can match page to pin by type.
			selected = (outtype == pintype);
			break;

		    case 1:
			// Pinscape Expansion Board mode.  In this mode, each page
			// can show a mix of types, and each type can appear on more
			// than one page, so we can't match by type.  Instead, use
			// the port alias - field [4] gives the board type.  If
			// there's no port alias, fall back on the type-specific page.
			selected = (alias[4] ? alias[4] == pageName : outtype == pintype);
			break;
		    }
		}

		// If the page is selected, make it visible even if we wouldn't
		// have otherwise done so.
		if (selected) {
		    vis = true;
		    foundSelected = true;
		}
		
		// if the button is visible, show it
		$(this).toggle(vis);
		if (vis)
		{
		    // show the button's current selection status
		    $(this).toggleClass("selected", selected);

		    // if the button is selected, activate its page
		    if (selected)
			selectPage($(this), true, null);
		}
	    });
	});

	// handle clicks in the pin selector page buttons
	$("#pinTypeSelector > div").click(function() {
	    selectPage($(this), false, null);
	});

	function selectPage(button, initial, pinFilter)
	{
	    // remember the new active page button
	    curpagebtn = button;

	    // hide all pages
	    $("#pinSelector .pinSelectorPage").css("display", "none");

	    // show the selected page
	    var pagename = button.data("page");
	    var page = $("#" + pagename);
	    page.css("display", "");

	    // get its pin list
	    curpinlst = page.find(".pinlist");

	    // we don't have a selection on the new page yet
	    curSelItem = null;

	    // highlight the appropriate button
	    $("#pinTypeSelector > div").removeClass("selected");
	    button.addClass("selected");

	    // set up the new page
	    switch (pagename)
	    {
	    case "gpioSelector":
		// if the caller specified a filter, remember it
		if (pinFilter)
		    button.data("curfilter", pinFilter);

		// Show the KL25Z pin selector.  Use the caller's filter if provided,
		// otherwise use the button's current filter, otherwise use the
		// button's default filter.
		showKL25ZPinPage(pinFilter || button.data("curfilter") || button.data("filter").split(" "), initial);
		break;

	    case "tlc5940Selector":
	    case "hc595Selector":
	    case "mainBoardDigitalOutputSelector":
	    case "mainBoardPWMOutputSelector":
	    case "mainBoardInputSelector":
	    case "powerBoardOutputSelector":
	    case "chimeBoardOutputSelector":
		// show the chip pin selector
		showChipPinPage(pagename, page, initial, button.data("pintype"));
		break;

	    case "virtualOutputSelector":
		showVirtualPage();
		break;
	    }

	    // If we have a list header, size it to match the list interior width.
	    // We couldn't do this earlier because the page is invisible ("display:
	    // none") when the dialog isn't open or a different page is active.  We
	    // need the list to be visible in order to measure its width.
	    var lst = page.find(".pinlist");
	    lst.prev().filter(".header").css("width", lst.innerWidth() - sbwid);

	    // if opening the dialog, make sure the button is in view
	    if (initial)
		scrollIntoView(button, 0);
	}

	// show the virtual page
	function showVirtualPage()
	{
	    // select the virtual out button if applicable
	    $("#btnMakeVirtualPort").toggleClass(
		"selected", curpin.find(".pintype").val() == 5);

	    // select the ZB port button if applicable
	    $("#btnMakeZBPort").toggleClass(
		"selected", curpin.parents(".outPortRow").data("idx") == $("#zbPort").val());
	}

	// Show the pin selector dialog.  'opener' is the .pinselect INPUT child
	// that triggered the selection.  'positioner' is the visible element to
	// use as a reference point in positioning the dialog; this defaults to
	// the opener element if omitted.
	function showPinSelector(opener, positioner)
	{
	    // use the opener as the default positioner
	    positioner = positioner || opener;

	    // forget any active gpio page filters from past runs
	    pindlg.find(".pinTypeSelector > div").data("curfilter", null);

	    // show the dialog
	    pindlg.parent().css("display", "block");

	    // show just the "virtual" page for sizing purposes
	    pindlg.children(".pinSelectorPage").css("display", "none");
	    $("#virtualOutputSelector").css("display", "");

	    // move it align with the left of the field, centered vertically
	    var ofs = positioner.offset();
	    var dlght = pindlg.outerHeight() + 5;
	    var dlgwid = pindlg.outerWidth();
	    var winht = window.innerHeight - $("#nav").outerHeight();
	    var winwid = window.innerWidth - getScrollBarWidth();
	    var scrolly = $("html,body").scrollTop();
	    var scrollx = $("html,body").scrollLeft();
	    var x = ofs.left;
	    var y = ofs.top + positioner.height()/2 - dlght/2;

	    // if it goes out of view below, move it up
	    if (y + dlght > scrolly + winht)
		y = scrolly + winht - dlght;

	    // and if it goes out of view above, move it down
	    if (y < scrolly)
		y = scrolly;

	    // make sure it doesn't go out of the window to the right or left
	    if (x + dlgwid > scrollx + winwid)
		x = scrollx + winwid - dlgwid;
	    if (x < scrollx)
		x = scrollx;

	    // position it
	    pindlg.css({left: x + "px", top: y + "px"});

	    // mark the opener's associated label as active
	    curpinlbl = opener.parents(":has(.pinlabel)");
	    curpinlbl.addClass("openDlgRow");

	    // remember the opener
	    curpin = opener;

	    // add a dialog stack entry while we're open
	    dialogStack.push({
		id: "pinDialog",
		keydown: function(ev) {
		    if (curpin && curpinlst)
		    {
			function go(delta)
			{
			    // If delta is +/- 10000, scroll by a page - figure the page size.
			    if (delta == -10000 || delta == 10000)
			    {
				// refigure the delta in terms of elements per page
				var pg = Math.floor(curpinlst.innerHeight() / curpinlst.children().first().innerHeight());
				pg = (pg > 2 ? pg - 1 : 1);
				delta = delta/10000*pg;
			    }

			    // Start at the current selection.  If there isn't one,
			    // select the first item initially.
			    var newsel = curSelItem;
			    if (!newsel)
			    {
				// find the first item
				newsel = curpinlst.find("div.available").first();

				// If this is a down arrow or page down key, just go to
				// the first item from an initial null selection.  This
				// is nicer than jumping to the second item or next page
				// immediately from no selection.
				if (ev.which == 40 || ev.which == 34 || ev.which == 99) {
				    pinselect(newsel, false, false);
				    return;
				}
			    }

			    // Seek forwards or backwards by the desired number of items;
			    // if we reach the end/beginning of the list, stop at the
			    // first/last element.
			    for ( ; delta < 0 ; ++delta)
			    {
				newsel = newsel.prevAll(".available").first();
				if (!newsel.length) {
				    newsel = curpinlst.find("div.available").first();
				    break;
				}
			    }
			    for ( ; delta > 0 ; --delta)
			    {
				newsel = newsel.nextAll(".available").first();
				if (!newsel.length) {
				    newsel = curpinlst.find("div.available").last();
				    break;
				}
			    }
			    
			    // select the new pin
			    pinselect(newsel, false, false);
			}
    
			// pin dialog is open
			switch (ev.which)
			{
			case 38:
			    // up - select previous item or first item
			    go(-1);
			    ev.preventDefault();
			    return false;
			    
			case 40:
			    // down - select next item or last item
			    go(1);
			    ev.preventDefault();
			    return false;

			case 33:   // page up
			case 105:  // keypad 9/page up
			    go(-10000);
			    ev.preventDefault();
			    return false;

			case 35:   // end
			case 97:   // keypad 1/end
			    go(9999);
			    ev.preventDefault();
			    return false;

			case 36:   // home
			case 103:  // keypad 7/home
			    go(-9999);
			    ev.preventDefault();
			    return false;

			case 34:   // page down
			case 99:   // keypad 3/page down
			    go(10000);
			    ev.preventDefault();
			    return false;
			    
			case 13:
			case 10:
			    // return/enter - close the dialog, selecting the current pin
			    pinselect(curSelItem, false, true);
			    return false;
			    
			case 27:
			    // escape - close the dialog without changing the selection
			    dismissPinDlg();
			    return false;
			}
		    }
		}
	    });
	}

	// Show a KL25Z pin page in the pin selector dialog.
	//
	// 'gpiotype' is a string array giving the type of pin we're
	// selecting.  The first element must be one of the KL25Z GPIO
	// page keywords: dig-in, dig-out, pwm, adc, spi-mosi, or
	// spi-sclk.
	//
	// Additional elements specify modifiers:
	//
	//   extern -> ONLY include external header pins in the list
	//   nc     -> ALSO include "Not Connected" in the list
	//
	// 'opening' is true if we're opening the dialog, false if we're
	// merely selecting a new page.
	function showKL25ZPinPage(gpiotype, opening)
	{
	    // build a list of pin filters according to the pin type
	    var pinFilter = function(p, name) { return true; };
	    var primary = {
		"dig-in": function(p) { return p; },	     // all pins can be used as digital inputs
		"dig-out": function(p) { return p; },     // ... or digital outputs
		"adc": function(p) { return p && p.adc; },
		"pwm": function(p) { return p && p.pwm; },
		"spi-mosi": function(p) { return p && p.spi == "MOSI"; },
		"spi-sclk": function(p) { return p && p.spi == "SCLK"; }
	    };

	    // get the primary filter
	    pinFilter = primary[gpiotype[0]];

	    // add exclusion modifiers first
	    var modifiers = gpiotype.slice(1);
	    $.each(modifiers, function(k, v)
	    {
		if (v == "extern") {
		    // external pins only - pin must be external AND match primary rule
		    pinFilter = (function(f) {
			return function(p, name) { return p && !p.internal && f(p, name); };
		    })(pinFilter);
		}
	    });

	    // add inclusive modifiers last
	    $.each(modifiers, function(k, v)
	    {
		if (v == "nc") {
		    // NC - matches Not Connected always, or matches other conditions
		    pinFilter = (function(f) {
			return function(p, name) { return name == "Not Connected" || f(p, name); };
		    })(pinFilter);
		}
	    });

	    // filter the KL25Z pin list and pin images to make available
	    // the subset appropriate for this pin type
	    $("#kl25zPinImg .pinButton, #lstKL25ZPins > div").each(function() {
		var name = $(this).data("pin");
		var gp = gpioPinsByName[name];
		$(this).toggleClass("available", !!pinFilter(gp, name));
	    });

	    // make the current selection active
	    var sel = null;
	    var val = curpin.find(".pinval").val();
	    pinlst.children().each(function() {
		if (pinlistVal($(this)) == val)
		{
		    sel = $(this);
		    return false;
		}
	    });

      	    // select the item
	    sel = sel || pinlst.children().first();
	    pinselect(sel, opening, false);

	    // mark in-use pins in the list and board image
	    markPinsInUse($("#lstKL25ZPins > div, #kl25zPinImg .pinButton"), gpiotype[0] == "pwm", "kl25z");
	}

	// Mark in-use pins.  'pins' is a jQuery list of the pins to mark,
	// which can include the text list and the image buttons.
	//
	// 'pwm' is true if this selector page selects PWM pins.  If so,
	// we'll show a distinctive style for pins that aren't directly
	// in use but whose PWM channels are in use by other pins.
	//
	// 'pageType' is one of:
	//   - "kl25Z", for direct KL25Z pin selection pages
	//   - "chip", for peripheral chips - TLC5940, 74HC595
	//   - "board", for expansion boards
	var markPinsInUsePending = 0;
	function markPinsInUse(pins, pwm, pageType)
	{
	    // if we don't already have a pending timeout, set one
	    if (markPinsInUsePending++ == 0)
		setTimeout(function() { go(); }, 0);
    
	    function go()
	    {
		// no longer pending
		markPinsInUsePending = 0;
		
		// Build a table of all pins current in use
		var inuse = pinsInUse();

		// note the current selection
		var keyCur = inuseID(curpin);
		var gCur = gpioPinsByName[keyCur] || { };

		// visit each item in the dialog list
		pins.each(function()
		{
		    // get this item and its in-use key
		    var self = $(this);
		    var key = inuseID(self);

		    // presume it won't be in use
		    self.removeClass("inuse pwmInuse").attr("title", "");

		    // if it's a GPIO pin, get its descriptor
		    var g = gpioPinsByName[key] || { };

		    // get the port name and the jumper name/internal name
		    var port = g.name;
		    var jumper = pinToJumper(key);

		    // combine the pin name and conflict or remark text into a hover title
		    function title(txt)
		    {
			var lst = [];
			var h = self.data("hovername");
			if (h) lst.push(h);
			if (txt) lst.push(txt);
			return lst.join(" - ");
		    }

		    // if this is the current pin, don't show conflicts - just set the
		    // title to the remarks
		    if (key == keyCur)
		    {
			self.attr("title", title(g.remarks));
			self.addClass("current selected");
			return;
		    }

		    // If desired, check the PWM channel.  If this list/pin item is
		    // associated with a PWM channel other than the current selection's
		    // channel, show the other user(s).  We don't show a conflict with
		    // the current selection's channel because reassigning the pin will
		    // remove the old assignment, which will free up the channel.  We'll
		    // effectively be moving the same channel to a new pin, which won't
		    // create a conflict.
		    var pwmch, pwmiu;
		    var pwmUsers;
		    if (pwm
			&& (pwmch = g.pwm)
			&& pwmch != gCur.pwm
			&& (pwmiu = inuse["pwm." + pwmch]))
		    {
			// This PWM channel is in use.  Make a note of the other users.
			pwmUsers = "PWM Channel " + pwmch + " is in use by " + pwmiu.inUseBy();
		    }

		    // Note if this is a GPIO port that's connected to an expansion
		    // board port in the current configuration.  If it is, it'll have
		    // an alias.
		    var alias = pageType == "kl25z" && gpioPortAlias[key];

		    // Check for conflicts, in order of descending priority
		    if (inuse[key])
		    {
			// in use - add class highlighting and show other users in the title
			self.addClass("inuse");
			self.attr("title", title("In use by " + inuse[key].inUseBy()));
		    }
		    else if (pwmUsers)
		    {
			// the pin isn't claimed, but its PWM channel is already in use
			self.addClass("pwmInuse");
			self.attr("title", title(pwmUsers));
		    }
		    else if (alias)
		    {
			self.addClass("inuse");
			self.attr("title", title("This pin is used by the expansion board ("
						 + alias.split("|")[0]) + ")");
		    }
		    else
		    {
			// not in use - remove the class highlighting, and set the title to
			// any general remarks for this pin
			self.attr("title", title(g.remarks));
		    }
		});
	    }
	}

	// Show a chip pin page in the pin selector dialog
	function showChipPinPage(pageName, page, opening, pagePinType)
	{
	    // run the pin adjustor function for this page, if any
	    (chipPinPageAdjustor[pageName] || function() { })();

	    // find the selected item in the list
	    var sel = null;
	    var lst = page.find(".pinlist");
	    var val = curpin.find(".pinval").val();
	    var typ = curpin.find(".pintype").val();
	    lst.children().each(function()
	    {
		// Check for a match to the pin name and type.  The pin
		// type can come from the list item, if it has one, or
		// from the page.
		var self = $(this);
		if (self.data("pin") == val
		    && (self.data("pintype") || pagePinType) == typ)
		{
		    sel = $(this);
		    return false;
		}
	    });

	    // deselect all pins in the list
	    lst.children(".chipPin").removeClass("selected current inuse pwmInuse").attr("title", "");

	    // deselect all chips
	    page.find(".chipIndexer div").removeClass("selected");

	    // select the active pin if there is one, otherwise just select
	    // our first chip with no pin selection
	    if (sel)
		pinselect(sel, opening, false);
	    else
		switchChip(page, 0, 0);

	    // mark in-use items
	    markPinsInUse(page.find(".chipPin, .pinButton"), page.data("pwm"), page.data("pagetype"));
	}
    
	// Select a new chip on a chip pin selector (TLC5940, 74HC595).  This
	// switches among multiple copies of the current chip type.
	function switchChip(page, chipno, pinsPerChip)
	{
	    // deselect all pin buttons
	    var picdiv = page.find(".pinimage");
	    var buttons = picdiv.children(".pinButton");
	    buttons.removeClass("selected current inuse").attr("title", "");

	    // count the pins in the image if the caller didn't tell us
	    if (!pinsPerChip)
		pinsPerChip = buttons.filter(function() { return $(this).data("basepin") !== undefined; }).length;

	    // renumber the pins to the range for the currently selected chip
	    var firstpin = chipno * pinsPerChip;
	    buttons.each(function()
	    {
		// if this is an output pin, renumber it
		var self = $(this);
		var basepin = self.data("basepin");
		if (basepin !== undefined)
		{
		    // renumber to the base pin number (the pin index within the chip)
		    // plus the first pin for the selected chip
		    var pin = firstpin + (+basepin);
		    var typ = self.data("pintype");
		    self.data("pin", pin);
		}
	    });

	    // show the new chip as current
	    picdiv.find(".chipIndexer div").removeClass("selected").eq(+chipno).addClass("selected");

	    // mark in-use items
	    markPinsInUse(page.find(".chipPin, .pinButton"), page.data("pwm"), page.data("pagetype"));
	}

	// Handle focus and keystrokes in a pinselect text field
	$(".pinselect .pinval").focus(function(ev) {
	    // on gaining focus, select all text so we lose the flashing cursor
	    this.select();
	}).keydown(function(ev) {
	    switch (ev.which)
	    {
	    case 10:
	    case 13:
	    case 32:
		// open the pin selector popup on enter/return/space
		$(this).parents(".pinselect").click();
		ev.preventDefault();
		return false;
	    }
	});

	// clicking on a pin warning icon shows its warning
	$(".pinwarn").click(function() {
	    event.stopPropagation();
	    alert($(this).attr("title"));
	});

	// field that activated pin selector popup, and its label
	var curpin, curpinlbl;

	// Current selected list item.  This is mostly for the keyboard
	// (arrow key) interface.  This is initially set to the current
	// value of the field that opened the dialog, and we update it
	// when we move the selection via the arrow keys.
	var curSelItem;

	// current selected page button - this is the button div that
	// selected the page (one of the #pinTypeSelector descendants)
	var curpagebtn;

	// current page's pin list
	var curpinlst;

	// dismiss the pin selector dialog
	function dismissPinDlg()
	{
	    // hide the dialog
	    pindlg.parent().css("display", "none");

	    // remove the active highlighting from the label
	    if (curpinlbl)
		curpinlbl.removeClass("openDlgRow");

	    // set focus back to the field
	    $(curpin).children(".pinval").focus();
    
	    // clear the dialog tracker variables
	    curpin = curpinlbl = curSelItem = curpinlst = null;

	    // remove our dialog stack entry
	    popDialogStack("pinDialog");
	}

	// get the value for a pinlist item
	function pinlistVal(item)
	{
	    return item.data("pin");
	}

	// Default flags to set for certain special pin selections.  We'll
	// set these flags when one of these pins is selected as an output port.
	var specialPinFlags = {
	    "1.PTB18": 0x05,	// Red on-board LED, PWM Out: Active Low + Gamma
	    "2.PTB18": 0x01,	// Red on-board LED, Digital Out: Active Low
	    "1.PTB19": 0x05,	// green on-board LED, PWM Out: Active Low + Gamma
	    "2.PTB19": 0x05,	// green on-board LED, Digital Out: Active Low + Gamma
	    "1.PTD0":  0x05,	// blue on-board LED, PWM Out: Active Low + Gamma
	    "2.PTB0":  0x05 	// blue on-board LED, Digital Out: Active Low + Gamma
	};

	// select an item in a pinlist
	function pinselect(item, initial, dismiss)
	{
	    // If this is a 'dismiss' action, don't do anything if the pin
	    // isn't available.  This prevents losing the selection when
	    // clicking on an image pin button that's not currently enabled.
	    // We allow these button elements to handle events even when
	    // inactive to provide visual feedback when hovering over pin
	    // areas, since it's nice to be able to identify a pin this way
	    // even when it can't be selected for the current function.
	    if (!item.hasClass("available"))
		return;

	    // get the page
	    var page = $("#" + curpagebtn.data("page"));

	    // reset the selected and current state on all pins
	    curpinlst.children().removeClass("selected current");
	    page.find(".pinButton").removeClass("selected current");
	    
	    // Only allow selecting available items
	    if (!item || !item.hasClass("available"))
		return;

	    // get the new selected item's name and pin type
	    var name = pinlistVal(item);
	    var pintype = item.data("pintype") || curpagebtn.data("pintype");
	    var opalias = outPortAlias[pintype + "." + name];

	    // check for warnings associated with this GPIO pin (e.g., warnings
	    // about re-assigning pins wired to the on-board LED)
	    var g = gpioPinsByName[name];
	    if (dismiss && g && g.warning)
	    {
		if (!window.external.YesNoDialog(
		    g.warning
		    + "\r\n\r\nWould you like to proceed with this pin assignment?"))
		return;
	    }

	    // If the selection is being made from the KL25Z pin selector
	    // directly, and this pin has an expansion board alias in the
	    // current hardware configuration, show a warning.
	    var alias;
	    if (dismiss && page.attr("id") == "gpioSelector" && (alias = gpioPortAlias[name]))
	    {
		if (!window.external.YesNoDialog(
		    "You're attempting to assign a pin that's already wired "
		    + "to a specific function on the expansion board ("
		    + alias.split("|")[0] + "). The physical wiring on the "
		    + "board might make other uses impossible even if the "
		    + "associated feature is disabled in the software."
		    + "\r\n\r\n"
		    + "Are you sure you want to proceed with this pin selection?"))
		    return;
	    }

	    // Warn about the power limits for expansion board pins connected
	    // directly to KL25Z GPIO ports
	    if (dismiss && !initial && /^(Extender \d|Plunger \d|Cal Button\|)/i.test(opalias))
	    {
		window.external.ShowAdviceDialog(
		    "RawOutputPowerLimitWarning",
		    "WARNING!\n\n"
		    + "This pin is connected DIRECTLY to a CPU port on the KL25Z. "
		    + "These pins have EXTREMELY low power handling capacity. "
		    + "NEVER CONNECT ANY LOAD LARGER THAN 4mA TO THIS PIN. "
		    + "The 4mA limit applies whether the pin is used in \"active "
		    + "high\" or \"active low\" mode. Exceeding 4mA in either mode "
		    + "can damage the CPU, which can render the whole KL25Z "
		    + "board inoperable.");
	    }

	    // dismiss the dialog if desired, otherwise fix up the list display
	    // for the new selection
	    if (dismiss)
	    {
		// set the value in the container field
		if (curpin)
		{
		    // set the pin type and value
		    $(".pintype", curpin).val(pintype);
		    $(".pinval", curpin).val(name).change();

		    // set the pin flags, if appropriate
		    var sf = specialPinFlags[pintype + "." + name] || 0;
		    curpin.parents(".outPortRow").find(".pinflags").val(sf).change();

		    // notify the parent .pinselect object of the change
		    curpin.parents(".pinselect").change();
		}

		// build a new in-use table and update warnings
		updatePinWarnings();

		// dismiss the dialog
		dismissPinDlg();
	    }
	    else
	    {
		// get the list element
		var f = function() { return $(this).data("pin") == name; };
		var lstele = $.contains(curpinlst[0], item[0]) ? item : curpinlst.children().filter(f);

		// switch to the new chip, if there's a chip indexer
		if (page.find(".chipIndexer").length)
		    switchChip(page, lstele.data("chip"));

		// On the initial selection, set the 'current' class.  In all
		// cases, set 'selected'.
		var cl = "selected";
		if (initial)
		    cl += " current";

		// add the classes to the newly selected item
		lstele.addClass(cl);
		page.find(".pinButton").filter(f).addClass(cl);
		
		// scroll the list element into view
		scrollIntoView(lstele, 1, { top: curpinlst.prev(".header").outerHeight() });

		// remember it as the new item
		curSelItem = item;
	    }
	}

	// any click in the window cover area dismisses the dialog, but not
	// in the dialog itself (stop propagation to prevent that)
	pindlg.click(function(ev) { ev.stopPropagation(); });
	pindlg.parent().click(function() { dismissPinDlg(); });
    }
});

// Open dialog stack.  Each element is an object defining global
// event interceptors.  Our document-level events handlers will
// call these in sequence, starting from the LAST element of the
// list (which corresponds to the topmost open dialog).  If a
// handler returns false, it cancels further processing of the
// key - it won't "bubble" to other dialogs or to the document
// handler.
//
//    .keydown(ev) -> keydown interceptor
//
var dialogStack = [];

// remove the topmost dialog stack matching the given ID
function popDialogStack(id)
{
    for (var i = dialogStack.length - 1 ; i >= 0 ; --i)
    {
	if (dialogStack[i].id == id)
	{
	    // this is the match - remove this element
	    dialogStack = $.grep(dialogStack, function(ele, idx) { return idx != i });
	    return;
	}
    }
}

// Global keyboard handler
$(document).keydown(function(ev)
{
    // Run it past any dialogs in the stack first
    for (var i = dialogStack.length - 1 ; i >= 0 ; --i)
    {
	// call this handler - if it returns false, stop processing
	if (dialogStack[i].keydown(ev) === false)
	    return false;
    }

    // if it's an arrow key, and focus isn't in a text-like INPUT
    // control, scroll the page
    if (ev.which == 38 || ev.which == 40)
    {
	// check for focus
	var ele = document.activeElement;
	if (!ele || $(ele).filter("input[type=text], select").length == 0)
	{
	    // it's not in a text field or a select box - scroll the page
	    $("html,body").stop(false, true).animate(
		{ "scrollTop": $("html,body").scrollTop() + (ev.which == 38 ? -64 : 64) }, 100);
	}
    }
});

// Normalize a configuration.  This sets certain unused fields to
// default values to make comparisons more uniform.  We return a
// new configuration object - the original isn't modified.
function normalizeConfig(config)
{
    // if it's empty, return nothing
    if (!config)
	return { };

    // create a new copy of the object, so that we leave the
    // original unmodified
    config = JSON.parse(JSON.stringify(config));
    
    // remove the array counts for buttons and outputs
    if (config.buttons)
	delete config.buttons.count;
    if (config.outputs)
	delete config.outputs.count;

    // set "Not Connected" values for unused plunger sensor fields
    switch (config.plungerType)
    {
    case 0:
	// No sensor - set all pins to "NC"
	config.plungerPins.a = "NC";
	config.plungerPins.b = "NC";
	config.plungerPins.c = "NC";
	config.plungerPins.d = "NC";
	break;
	
    case 1:
    case 3:
	// TSL1410R / TSL1412R, serial mode - pin 'd' is unused
	config.plungerPins.d = "NC";
	break;

    case 5:
	// Potentiometer - pins b, c, and d are unsed
	config.plungerPins.b = "NC";
	config.plungerPins.c = "NC";
	config.plungerPins.d = "NC";
	break;
    }

    // if the TV-On feature is disabled, clear all fields
    if (config.TVon) {
	if (config.TVon.statusPin === undefined || config.TVon.statusPin == "NC") {
	    config.TVon.statusPin = "NC";
	    config.TVon.latchPin = "NC";
	    config.TVon.relayPin = "NC";
	    config.TVon.delay = 700;
	}
    }

    // if the TLC5940 feature is disabled, clear all fields
    if (config.TLC5940) {
	if (config.TLC5940.nchips == 0) {
	    config.TLC5940.SIN = "NC";
	    config.TLC5940.SCLK = "NC";
	    config.TLC5940.XLAT = "NC";
	    config.TLC5940.BLANK = "NC";
	    config.TLC5940.GSCLK = "NC";
	}
    }

    // if the 74HC595 feature is disabled, clear all fields
    if (config.HC595) {
	if (config.HC595.nchips == 0) {
	    config.HC595.SIN = "NC";
	    config.HC595.SCLK = "NC";
	    config.HC595.LATCH = "NC";
	    config.HC595.ENA = "NC";
	}
    }

    // we don't use or change the plunger calibration
    delete config.plungerCal;

    // if in standalone mode, clear all expansion board fields
    if (config.expansionBoards) {
	if (config.expansionBoards.type == 0) {
	    config.expansionBoards.version = 0;
	    config.expansionBoards.ext0 = 0;
	    config.expansionBoards.ext1 = 0;
	    config.expansionBoards.ext2 = 0;
	}
    }

    // if ZB Launch Ball is disabled, clear fields
    if (config.ZBLaunchBall) {
	if (config.ZBLaunchBall.port == 0) {
	    config.ZBLaunchBall.keytype = 0;
	    config.ZBLaunchBall.keycode = 0;
	    config.ZBLaunchBall.pushDistance = 0;
	}
    }

    // string-ize all output port IDs
    $.each(config.outputs, function(k, v) {
	if (v.port && typeof v.port.pin != "string")
	    v.port.pin = "" + v.port.pin;
    });

    // string-ize all numbers for consistent comparisons
    function numToString(val)
    {
	if (typeof val === "number")
	    val = "" + val;
	if (typeof val === "object")
	    $.each(val, function(k, v) { val[k] = numToString(v); });
	return val;
    }
    numToString(config);

    // if there's no night mode button, the button flags don't matter
    if (config.nightMode && config.nightMode.button == 0)
	config.nightMode.flags &= ~0x03;

    // return the updated config object
    return config;
}

// When configuration loading is in progress, we set this to the config
// template object being loaded.  Change handlers can use this for
// special dependency handling needed during loading.
var loadingConfig;

// Load a configuration into and/or from the UI.
//
// configFromUI() returns a new config object built from the current UI state
// configToUI(config) updates the UI state to match the given config object
//
var configFromUI, configToUI;
function configFunctionSetup()
{
    // Create a new configuration data object from the current UI state
    configFromUI = function()
    {
	// create a new empty config object
	var newconfig = { }
    
	// run through the control mappings
	for (var i = 0 ; i < fields.length ; ++i)
	{
	    // get this field descriptor and its UI control
	    var f = fields[i];
	    var ctl = $(f.ctl);

	    // retrieve the value, according to the control type
	    var v = f.type.fromUI(ctl);

	    // apply any declared data conversions on the value
	    if (f.datatype)
		v = f.datatype.fromUI(v);

	    // if there's a value-from-UI translator, run it
	    if (f.fromUI)
		v = f.fromUI(v);

	    // apply the filter, if any
	    if (f.filter)
		v = f.filter(v);

	    // if we ended up with a valid value, add it to the config
	    if (typeof v != "undefined")
		setprop(newconfig, f.prop, v);
	}

	// return the new configuration object
	return newconfig;
    }

    // Update the UI state to reflect the contents of the given configuration object.
    // 'source' is a ConfigSource element giving the source of the configuration data.
    configToUI = function(config, source)
    {
	// set the global loading flag
	loadingConfig = config;
    
	// run through the control mappings
	for (var i = 0 ; i < fields.length ; ++i)
	{
	    // get this field descriptor and the config property
	    var f = fields[i];
	    var v = getprop(config, f.prop);

	    // if we got a property, store it
	    if (typeof v != "undefined")
	    {
		// get the UI control
		var ctl = $(f.ctl);

		// if there's a declared datatype conversion, apply it
		if (f.datatype)
		    v = f.datatype.toUI(v);

		// if there's a property-to-UI conversion function, call it
		if (f.toUI)
		    v = f.toUI(v);

		// store the value in the control
		f.type.toUI(ctl, v);
	    }
	}

	// update peripheral pin connection active status
	adjustPeripheralPins(true, true);
	
	// update pin warnings
	updatePinWarnings();

	// adjust the display size of the outputs table
	sizeOutputsTable();

	// If loading a board configuration, size the button table.
	// Only do this for configurations loaded directly from the
	// board, since each firmware version has a fixed number of
	// buttons it can support, and we always want to display the
	// appropriate number for the connected firmware.
	if (source == ConfigSource.Board)
	    sizeButtonTable(config);

	// we're no longer loading a configuration
	loadingConfig = false;
    }

    // control types
    var tText = {
	toUI:   function(ctl, val) { ctl.val(val).change(); },
	fromUI: function(ctl) { return ctl.val(); }
    };
    var tSelect = tText;
    var tCheckbox = {
	toUI:   function(ctl, val) { ctl.prop("checked", !!val).change(); },
	fromUI: function(ctl) { return ctl.prop("checked") ? 1 : 0; }
    };
    var tRadio = {
	toUI:   function(ctl, val) { ctl.val([val]).change(); },
	fromUI: function(ctl) { return $(ctl).filter(":checked").val(); }
    };
    var tPin = {
	toUI:   function(ctl, val) { ctl.val(val == "NC" ? "Not Connected" : val).change(); },
	fromUI: function(ctl) {
	    var val = ctl.val();
	    return (val == "Not Connected" ? "NC" : val);
	}
    };

    // datatypes
    var dNumber = {
	toUI:   function(v) { return parseInt(v); },
	fromUI: function(v) { return parseInt(v); }
    };
    function dNumberScale(factor) {
	return {
	    toUI:   function(v) { return parseInt(v)/factor; },
	    fromUI: function(v) { return parseFloat(v)*factor; }
	};
    }

    // Mappings between controls and config variables
    var fields = [
        { prop: "USBID", ctl: "#popUsbID", type: tText,
	  toUI: function(v) { var v = hex4(v.vendor) + hex4(v.product); ensureUsbId(v); return v; },
	  fromUI: function(v) { return { vendor: parseInt(v.substr(0, 4), 16), product: parseInt(v.substr(4), 16) }; }
	},
	{ prop: "pinscapeID", ctl: "#popPinscapeID", type: tSelect, datatype: dNumber },
	{ prop: "joystickEnabled", ctl: "#ckJoystick", type: tCheckbox },
	{ prop: "disconnectRebootTime", ctl: "#ckRebootEnable", type: tCheckbox,
          toUI: function(v) { return +v != 0; },
	  fromUI: function(v) { return undefined; }
	},
	{ prop: "disconnectRebootTime", ctl: "#txtRebootTime", type: tText, datatype: dNumber,
          fromUI: function(v) { return $("#ckRebootEnable").prop("checked") ? v : 0; }
	},
	{ prop: "accelOrientation", ctl: "input:radio[name=accel]", type: tRadio, datatype: dNumber },
	{ prop: "plungerType", ctl: "#plungerType", type: tSelect, datatype: dNumber },
	{ prop: "calButtonPins.enabled", ctl: "", type: tText, datatype: dNumber,
          fromUI: function(v) {
	      return ($("#calBtnEna").prop("checked") ? 0x01 : 0x00)
		  + ($("#calLEDEna").prop("checked") ? 0x02 : 0x00);
          },
	  toUI: function(v) {
	      $("#calBtnEna").prop("checked", (v & 0x01) != 0).change();
	      $("#calLEDEna").prop("checked", (v & 0x02) != 0).change();
	      return undefined;
          }
	},
	{ prop: "ZBLaunchBall.pushDistance", ctl: "#zbDistance", type: tText, datatype: dNumberScale(1000) },
	{ prop: "ZBLaunchBall.port", ctl: "#zbEnabled", type: tCheckbox,
          toUI: function(v) { return +v != 0; },
	  fromUI: function(v) { return undefined; }
	},
	{ prop: "ZBLaunchBall.port", ctl: "#zbPort", type: tText, datatype: dNumber },
	{ prop: "ZBLaunchBall.keytype", ctl: "#keymapZB .keytype", type: tText, datatype: dNumber },
	{ prop: "ZBLaunchBall.keycode", ctl: "#keymapZB .keycode", type: tText, datatype: dNumber },
	{ prop: "TVon.delay", ctl: "#tvDelay", type: tText, datatype: dNumberScale(100),
          fromUI: function(v) { return $("#tvOnEnabled").prop("checked") ? v : 0; },
	},
	{ prop: "TVon.delay", ctl: "#tvOnEnabled", type: tCheckbox,
          fromUI: function(v) { return undefined; },
	  toUI: function(v) { return v != 0; }
	},
	{ prop: "nightMode.button", ctl: "#nightModeButtonNo", type: tText, datatype: dNumber },
	{ prop: "nightMode.output", ctl: "#nightModeOutputNo", type: tText, datatype: dNumber },
	{ prop: "nightMode.flags", ctl: "", type: tRadio, datatype: dNumber,
          toUI: function(v) {
	      // set the switch type: if flag bit 0x01 is set, it's switch mode (2), otherwise momentary toggle mode (1)
	      $("input:radio[name=nightModeButtonType]").val([(v & 0x01) ? 2 : 1]).change();

	      // set the shift status: if flag bit 0x02 is set, it's the shifted button, otherwise the primary button;
	      // but this only applies in toggle mode, so bit 0x01 must not be set
	      $("#nightModeButtonShift input").prop("checked", (v & 0x03) == 0x02);
	      return undefined;
          },
	  fromUI: function(v) {
	      var v = 0;
	      if ($("input:radio[name=nightButtonModeType]:checked").val() == 2) v |= 0x01;  // switch mode (2) -> flag 0x01
	      if (!(v & 0x01) && $("#nightModeButtonShift input").prop("checked")) v |= 0x02; // shift button -> flag 0x02
	      return v;
          }
	},
		  
	{ prop: "expansionBoards.type", ctl: "input:radio[name=hardwareType]", type: tRadio, datatype: dNumber },
	{ prop: "expansionBoards.version", ctl: "#expBoardVersion", type: tText },
	{ prop: "expansionBoards.ext0", ctl: "#numMainBoards", type: tText, datatype: dNumber,
          fromUI: function(v) { return $("input:radio[name=hardwareType]:checked").val() == "1" ? v : undefined; }
	},
	{ prop: "expansionBoards.ext1", ctl: "#numPowerBoards", type: tText, datatype: dNumber,
          fromUI: function(v) { return $("input:radio[name=hardwareType]:checked").val() == "1" ? v : undefined; }
	},
	{ prop: "expansionBoards.ext2", ctl: "#numChimeBoards", type: tText, datatype: dNumber,
          fromUI: function(v) { return $("input:radio[name=hardwareType]:checked").val() == "1" ? v : undefined; }
	},
	{ prop: "TLC5940.nchips", ctl: "#tlc_nchips", type: tText, datatype: dNumber },
	{ prop: "HC595.nchips", ctl: "#hc595_nchips", type: tText, datatype: dNumber },
	{ prop: "shiftButton", ctl: "#shiftButton", type: tText, datatype: dNumber },
    ];

    // add field descriptors for all of the pin selectors
    $(".pinselect").each(function()
    {
	// get the configuration property name
	var self = $(this);
	var prop = self.data("cfg");

	// add a field definition for it
	fields.push({
	    prop: prop,
	    ctl: self.children(".pinval"),
	    type: tPin,
	    filter: function(v) { return self.data("outOfService") ? undefined : v; }
	});
    });

    // add field descriptors for the key mappings
    $(".keymapping").each(function()
    {
	var self = $(this);
	var idx = self.data("idx");
	var xidx = self.data("xidx");
	var prop = idx ? "buttons." + idx : xidx ? "xbuttons." + xidx : null;
	if (prop)
	{
	    var filter = function(v) { return self.data("outOfService") ? undefined : v; };
	    fields.push({ prop: prop + ".keytype", ctl: self.children(".keytype"), type: tText, datatype: dNumber, filter: filter });
	    fields.push({ prop: prop + ".keycode", ctl: self.children(".keycode"), type: tText, datatype: dNumber, filter: filter });
	    if (idx)
		fields.push({ prop: prop + ".flags", ctl: self.children("input.keyflags"), type: tText, datatype: dNumber, filter: filter });
	}
    });

    // add field descriptors for the output port mappings
    $(".outPortRow").each(function()
    {
	var self = $(this);
	var idx = self.data("idx");
	if (idx && idx != "end")
	{
	    var prop = "outputs." + idx;
	    fields.push({ prop: prop + ".port.type", ctl: self.find(".pintype"), type: tText, datatype: dNumber });
	    fields.push({ prop: prop + ".port.pin", ctl: self.find(".pinval"), type: tText });
	    fields.push({ prop: prop + ".flags", ctl: self.find(".pinflags"), type: tText, datatype: dNumber });
	}
    });
	    
    // Get a property by path, if present
    function getprop(obj, prop, defval)
    {
	// if we don't have an object, stop here
	if (!obj)
	    return obj;

	// traverse the dot-separated property list
	prop = prop.split(".");
	while (prop.length)
	{
	    // descend only if the next property is present
	    var p = prop.shift();
	    if (p in obj)
		obj = obj[p];
	    else
		return defval;
	}

	// return the final evaluated object
	return obj;
    }
    
    // Set a property by path, creating intermediate
    // container objects as necessary.
    function setprop(obj, prop, val)
    {
	// traverse the dot-separated property list
	prop = prop.split(".");
	while (prop.length > 1)
	{
	    // if the next property isn't present, create an empty object for it
	    var p = prop.shift();
	    if (!(p in obj))
		obj[p] = { };

	    // traverse into the subobject
	    obj = obj[p];
	}

	// set the final property
	obj[prop[0]] = val;
    }
}

// Convert a configuration set from UI format to USB format.

function configToUSB(uicfg)
{
    // Get the config var format descriptors.  This tells us how to format
    // the variables for the USB messages.
    var vardescs = window.external.GetConfigVarDescs().split("|");

    // Format each variable into a USB byte list
    var usb = [];
    $.each(vardescs, function(i, desc)
    {
	// Each variable descriptor uses this format:
	//   <varnum> <varname> <desc>
	// Split into the three parts.
	desc = desc.split(" ");
	var varid = desc[0];
	var varname = desc[1];
	var format = desc[2];

	// The <value> can be a substitution type, or an object.
	// The substitution types are of the form $X, where X is a
	// one-letter type code.  Object types use javascript object
	// syntax.  First, turn the type codes into strings, then
	// parse the descriptor into a javascript string or object.
	function parse(format, val)
	{
	    if (/\{/.test(format))
	    {
		// object format
		$.each(format.substr(1, format.length-2).split(","), function(k, v)
		{
		    // each field is a "property:value" - split at the ":" and
		    // process the field
		    v = v.split(":");
		    parse(v[1], val[v[0]]);
		});
	    }
	    else
	    {
		// scalar value - check which type we have
		switch (format)
		{
		case "$B":	// byte - integer value to USB byte
		    bytes.push(parseInt(val || 0));
		    break;

		case "$W":	// word - integer value to USB two bytes little-endian 
		    var ii = parseInt(val || 0);
		    bytes.push(ii & 0xff);
		    bytes.push((ii >> 8) & 0xff);
		    break;

		case "$P":	// port number - port name in "PTxx" format to USB byte
		    bytes.push(parseGPIOName(val));
		    break;

		case "$o":	// output port: object with {type:, pin:} fields to USB type byte + pin byte
		    // add the type byte
		    bytes.push(parseInt(val.type));
    
		    // interpret the pin name
		    switch (val.type)
		    {
		    case 1:
		    case 2:
			// GPIO pins - the pin is a GPIO name
			bytes.push(parseGPIOName(val.pin));
			break;

		    case 3:
		    case 4:
			// TLC5940 or 74HC595 ports - the pin is a port number
			bytes.push(parseInt(val.pin));
			break;

		    default:
			// pin is unused in all other types
			bytes.push(0);
			break;
		    }
		    break;
		}
	    }

	    function parseGPIOName(val)
	    {
		if (/PT([A-E])(\d+)/i.test(val))
		{
		    var port = RegExp.$1.charCodeAt(0) - 65;
		    var pin = parseInt(RegExp.$2);
		    return (port << 5) | (pin & 0x1F);
		}
		else if (typeof val == "undefined" || val == "NC")
		{
		    // not connected
		    return 255;
		}
		else
		{
		    // anything else is invalid - use NC, but flag it internally by adding 256
		    // (the extra 256 will be masked out when we transmit the bytes via USB)
		    return 255 + 256;
		}
	    }
	}

	// get the current UI settings for the current variable
	var uival = uicfg[varname];

	// check for an array variable
	if (typeof uival != "undefined")
	{
	    if (/\d+\[\]/.test(varid))
	    {
		// array - start at index 1 and continue until we run out of entries
		var arr = uicfg[varname];
		for (var j = 1 ; j in arr ; ++j)
		{
		    // the USB data starts with the variable ID and array index 
		    var bytes = [parseInt(varid), j];
		    parse(format, arr[j]);
		    usb.push(bytes.join(" "));
		}
	    }
	    else
	    {
		// scalar variable - the USB data starts with the variable ID
		var bytes = [parseInt(varid)];
		parse(format, uival);
		usb.push(bytes.join(" "));
	    }
	}
    });

    // return the usb list
    return usb;
}

// build a comma-separated list
function serialComma(lst, conjunction)
{
    if (lst.length < 1)
	return "";
    else if (lst.length == 1)
	return lst[0];
    else if (lst.length == 2)
	return lst[0] + " " + conjunction + " " + lst[1];
    else
	return lst.slice(0, -1).join(", ") + ", " + conjunction + " " + lst[lst.length-1];
}

// build a table of in-use pins
function pinsInUse()
{
    // generate a description of the list of users of an in-use pin
    var users = function() {
	return serialComma($.map(this.fields, function(ele) { return ele.data("desc"); }), "and");
    };

    function add(ele, v)
    {
	// create an entry for this name, if it's empty
	var t = inuse[v];
	if (!t)
	    inuse[v] = t = {
		name: v,
		gpio: gpioPinsByName[v],
		inUseBy: users,
		fields: []
	    };
	
	// add this pin's description to the list
	t.fields.push(ele);
    }

    // run through the .pinselect fields, and enroll each active one
    var inuse = { };
    $(".pinselect").each(function()
    {
	// only consider active items
	var self = $(this);
	if (self.data("active"))
	{
	    // get the pin by name; proceed if we're connected to a pin
	    var v = self.children(".pinval").val();
	    if (v != "Not Connected" && gpioPinsByName[v])
	    {
		// add an entry for the pin name
		add(self, v);

		// if this is a PWM pin, also add an entry for PWM channel
		if (/\b(pwm)\b/.test(self.data("gpiotype")))
		    add(self, "pwm." + gpioPinsByName[v].pwm);

		// if it has a SPI function, add an entry for that
		if (/\b(spi-)/.test(self.data("gpiotype")))
		    add(self, "spi." + gpioPinsByName[v].spi);
	    }
	}
    });

    // add the output ports
    $(".outPortRow").each(function()
    {
	// only consider GPIO pins
	var self = $(this);
	var v = self.find(".pinval").val();
	var typ = +self.find(".pintype").val();
	switch (typ)
	{
	case 1: // PWM GPIO
	case 2: // Digital Out GPIO
	    // get the pin by name; proceed if we're connected
	    if (v != "NC" && gpioPinsByName[v])
	    {
		// add an entry for the pin name
		add(self, v);

		// if it's used as a PWM pin, add an entry for the PWM channel
		if (typ == 1 && gpioPinsByName[v].pwm)
		    add(self, "pwm." + gpioPinsByName[v].pwm);
	    }
	    break;

	case 3: // TLC5940
	    add(self, "tlc5940." + v);
	    break;

	case 4: // 74HC595
	    add(self, "hc595." + v);
	    break;
	}
    });

    // return the table
    return inuse;
}

// create the in-use table ID for a pin selection
function inuseID(ele)
{
    // If the element has a "pin" data field, use that, along with
    // the "pintype" field if present.  Don't use a prefix for GPIO
    // port types (output types 1 and 2).
    var pinval = ele.data("pin");
    var pintype = ele.data("pintype");

    // If there's no "pin" data element, use the .pinval and .pintype fields
    if (pinval === undefined) {
	pinval = ele.find(".pinval").val();
	pintype = ele.find(".pintype").val();
    }
    
    // If the element has a .pintype field, apply the prefix for the type.
    // These fields apply to output rows, so the type ID corresponds to the
    // output type byte in the USB output port setup messages:
    // 
    //   type 3 -> TLC5940 -> prefix "tlc5940."
    //   type 4 -> 74HC595 -> prefix "hc595."
    //
    var pfx = { 3: "tlc5940.", 4: "hc595." }[pintype] || "";

    // return the prefix plus the pin name
    return pfx + pinval;
}

// Update pin warnings.  This updates all of the visible warning icons
// attached to .pinselect and .outPortRow pin selector fields.
function updatePinWarnings()
{
    genPinWarnings(function(item, msg) {
	var warn = item.find(".pinwarn");
	if (msg) {
	    warn.addClass("active");
	    warn.attr("title", msg);
	}
	else {
	    warn.removeClass("active");
	}
    });
}

// Determine if there are any warnings.  Returns a list of the .pinselect
// and .outPortRow items with warnings.
function getPinWarnings()
{
    var lst = [];
    genPinWarnings(function(item, msg) {
	if (msg)
	    lst.push(item);
    });
    return lst;
}

// General pin warning handler.  We run through the .pinselect fields
// and .outPortRow items, checking each one to see if it has a conflict.
// For each conflict, we call the callback function:
//
//   cb(item, warningMessage)
//
// For items without conflicts, we call the callback with no message.
//
function genPinWarnings(cb)
{
    // get the in-use table
    var inuse = pinsInUse();

    // run through the pin selectors and update warnings
    $(".pinselect, #outputTab .outPortRow").each(function()
    {
	// check to see if this item has multiple users
	var self = $(this);
	var pin = inuseID(self);
	var pintype = self.find(".pintype").val();
	var gpiotype = self.data("gpiotype");
	var pwm = (/\b(pwm)\b/.test(gpiotype) || pintype == "1") && nullobj(gpioPinsByName[pin]).pwm;
	var spi = /b(spi-)/.test(gpiotype) && nullobj(gpioPinsByName[pin]).spi;
	var warn = self.find(".pinwarn");
	if (self.hasClass("pinselect") && !self.data("active"))
	{
	    // it's inactive, so it can't be in conflict
	    cb(self, undefined);
	}
	else if (inuse[pin] && inuse[pin].fields.length > 1)
	{
	    // this one is in use multiple times - activate the warning
	    cb(self, "This pin is assigned to multiple functions ("
	       + inuse[pin].inUseBy() + ")");
	}
	else if (pwm && inuse["pwm." + pwm] && inuse["pwm." + pwm].fields.length > 1)
	{
	    // the PWM channel is overcommitted
	    cb(self, "This pin's PWM channel is used more than once "
	       + "(PWM channel " + pwm + ", used by " + inuse["pwm." + pwm].inUseBy()
	       + "). The PWM channel assigned to a pin can't be changed "
	       + "(it's hard-wired within the CPU), so only one of "
	       + pwmChannels[pwm].orList() + " may be used concurrently "
	       + "as PWM outputs.  The others can still be used for other "
	       + "purposes, but not for PWM outputs.");
	}
	else if (spi && inuse["spi." + spi] && inuse["spi." + spi].fields.length > 1)
	{
	    // the SPI controller is overcommitted
	    cb(self, "This pin's SPI controller function is used more than once "
	       + "(" + spi + ", used by " + inuse["spi." + spi].inUseBy()
	       + "). Each SPI function can only be assigned to one pin.");
	}
	else
	{
	    // turn off this one's warning
	    cb(self, undefined);
	}
    });
}


// treat a return key in a text field as a commit
$("input[type='text']").keydown(function(event) {
    if (event.which == 13)
	$(this).change();
});

// update highlighting on selection change in a radio button table
$("table.radio input:radio").change(function() {
    $("td", $(this).parents("table.radio")).each(function() {
	$(this).toggleClass("selected", $("input:radio", $(this)).prop("checked"));
    });
});

function hex4(val)
{
    return ("0000" + (+val).toString(16).toUpperCase()).substr(-4);
}

$(function() {
    // On text field changes, remember the old value on each change.
    // Note that event binding order is important - this is bound last so
    // that it runs after other handlers have a chance to use the old value.
    $("input:text").change(function() {
	$(this).data("oldVal", $(this).val());
    });

    // initialize everyone's oldVal to their initial value
    $("input:text").each(function() {
	$(this).data("oldVal", $(this).val()); });
    
});

// show PWM port help
$("a.pwmHelp").click(function(ev) {
    window.external.ShowHelp("HelpPWM.htm");
    ev.preventDefault();
});

// show SPI port help
$("a.spiHelp").click(function(ev) {
    window.external.ShowHelp("HelpSPI.htm");
    ev.preventDefault();
});

// show output port flag help
$("a.outPortOptionsHelp").click(function(ev) {
    window.external.ShowHelp("HelpOutPortOptions.htm");
    ev.preventDefault();
});

// show button assignment help
$("a.btnHelp").click(function(ev) {
    window.external.ShowHelp("HelpKeyAssignments.htm");
    ev.preventDefault();
});

</script>

</body>
</html>
