<!DOCTYPE html>
<html>
<head>
   <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
   <link rel="stylesheet" href="main.css"/>
   <link rel="stylesheet" href="jquery-ui/jquery-ui-1.11.4.css"/>
   <title>Pinscape Controller Settings</title>
</head
<body>

<script type="text/javascript" src="jquery-1.12.1.js"></script>
<script type="text/javascript" src="jquery-ui/jquery-ui-1.11.4.js"></script>
<script type="text/javascript" src="util.js"></script>


<script>
// Maximum table sizes.  These control the sizes of UI tables we
// build; they aren't necessarily the actual maximum values that the
// firmware actually supports.  We build some of our tables out to
// fixed maximum sizes so that we can pre-build parts of the UI before
// loading any of the device configuration data, so we have to choose
// maximum sizes that are likely to be above the actual firmware
// maxima for the foreseeable future.  It would be better in principle
// to get the values from the device, but the KL25Z is pretty limited
// on memory, so the practical limits for most items really can't ever
// go much higher than they are now.  That lets us simplify our UI
// initialization work by picking fixed limits in the UI that are high
// enough that the device will likely never be able to exceed them.
var MaxOutputs = 128;   // maximum number of feedback device outputs
var MaxButtons = 128;   // maximum number of buttons

// Configuration sources
var ConfigSource = {
    Board: 1,           // loading from the board
    File: 2,            // configuration saved in a local file
    Factory: 3          // pre-set factory configuration
};

// Accessible KL25Z GPIO ports.  These are the ports that can be
// assigned to configurable functions, such as LedWiz outputs, key
// inputs, and outboard chip connections.  The CPU nominally has 160
// GPIO lines (five ports of 32 pins each), but only the subset shown
// below are physically wired to external pins on the Freescale board.
//
// Notes:
//
// - One additional port, PTC1, is connected to an external pin, but can't
//   be connected to anything, because it's reserved by the mbed software
//   as the real-time clock input.  The pin is thus omitted from the list.
//
// - PTD0 is exposed as an external pin, but is also hardwired on the
//   Freescale board to the blue on-board LED.  It *can* be used for an
//   external device, but doing so will give up control over the blue LED
//   for status displays.  The blue LED in this case will still turn
//   on and off according to the electrical state of the pin, since there's
//   no way to physically disconnect the LED.
//
// - PTB18 and PTB19 are included even though they're *not* connected to
//   external pins.  We include them because they're connected to the
//   on-board red and green LEDs, respectively, which makes them usable as
//   LedWiz outputs.  When used this way, the LedWiz output controls the
//   on-board LED.  These outputs can't be wired to any external devices,
//   since the ports aren't connected to header pins, but it could be
//   useful in some cases to connect outputs to the on-board LEDs.  For
//   example, this can be used as a quick way to test software on the PC
//   to see if it's talking to the output controller properly.
//
// A limited subset of pins are capable of being used as PWM outputs,
// ADC inputs, or either.  The PWM-capable pins have a "pwm" property in
// the list below.  Likewise, the ADC-capable pins have an "adc"
// property.
//
// The "pwm" property for PWM-capable pins is in the format
// "TPM.channel", giving the TPM device number and channel tied to 
// the pin.  E.g., "2.0" means TPM #2, channel 0.  The TPMs ("Timer/
// PWM Modules") are the on-board peripherals that actually generate
// the PWM signals.  The CPU doesn't itself generate the PWM signals;
// those come from the TPMs.  Each PWM-capable GPIO pin is wired to
// exactly one TPM channel through the CPU multiplexer (an electrical
// switching network within the CPU).  The multiplexer makes the TPM
// connection optional: a PWM-capable pin can be connected to its
// TPM channel, or it can be connected to something else, such as one
// of the CPU digital in/out registers.  But this configurability only
// goes so far: the MUX connection only allows a particular PWM pin to
// connect to a particular, pre-determined TPM channel.  The association
// between a given GPIO pin and its assigned TPM channel isn't
// configurable.  These fixed pin-to-TPM connections are what's
// shown in the "pwm" properties.  For example, PTA1 can be connected
// through the MUX to TPM2 channel 0.  There are a total of 10
// distinct TPM channels connected to exposed GPIO pins.  However,
// there are more than 10 PWM-capable pins because some exposed TPM
// channels are connected to more than one GPIO pin.  In such cases,
// *only one* of the associated pins may be MUXed as a PWM.  For
// example, TPM2.0 is wired to PTA1, PTB2, PTB18, and PTE22.  Since
// all four pins map to the same TPM channel, and the TPM channel is
// what generates the PWM signal for the pins, these four pins can't
// be controlled as independent PWM outs.  Only *one* of these pins
// may thus be used at any given time as a PWM out - the rest must be
// used for some other purpose.  For example, if we assign PTA1 as a
// PWM out, it means we lose the ability to assign PTB2, PTB18, and
// PTE22 as PWM outs.  This is why we can only have 10 concurrent PWM
// outputs with this chip, even though it appears superficially that
// there are 31 PWM-capable pins.
//
// The ADC-capable pins include an "adc" property in the format
// "module.channel".  E.g., 0.3 means ADC0 channel 3.  There's only
// one ADC module on the KL25Z, so the module number is always 0, but
// we include it for the sake of documentation.  The wiring between
// pins and ADC channels works just like with the PWM channels, so
// only the pins marked with "adc" can be used as ADC inputs at all,
// and each one can only be run through its hardwired ADC channel.
// The ADC setup is simpler than the TPM, though, in that there are
// no duplicate pin assignments for any ADC channels - meaning that
// every ADC-capable pin can be assigned as an ADC concurrently,
// without having to worry about overcommitting module channels.
//
// It's important to understand that the "pwm" and "adc" associations
// in the list below merely *document* the pin-to-channel connections.
// The entries don't determine them or affect what's connected to what.
// The connections are physically hard-wired within the CPU and simply
// can't be changed.  Changing the property values below won't change
// the way the pins are wired; it will only make the entries in the
// table wrong.
//
var gpioPins = [
    { name: "PTA1",  pwm: "2.0", interrupt: true },
    { name: "PTA2",  pwm: "2.1", interrupt: true },
    { name: "PTA4",  pwm: "0.1", i2c: "1.SDA", interrupt: true },
    { name: "PTA5",  pwm: "0.2", i2c: "1.SCL", interrupt: true },
    { name: "PTA12", pwm: "1.0", interrupt: true },
    { name: "PTA13", pwm: "1.1", interrupt: true },
    { name: "PTA16", interrupt: true  },
    { name: "PTA17", interrupt: true  },
    { name: "PTB0",  pwm: "1.0", adc: "0.8" },
    { name: "PTB1",  pwm: "1.1", adc: "0.9" },
    { name: "PTB2",  pwm: "2.0", adc: "0.12" },
    { name: "PTB3",  pwm: "2.1", adc: "0.13" },
    { name: "PTB8"   },
    { name: "PTB9"   },
    { name: "PTB10"  },
    { name: "PTB11"  },
    { name: "PTB18", pwm: "2.0", onBoardLED: 1,
                     internal: true, internalName: "Red on-board LED", internalShortName: "Red LED",
                     warning: "This port is hard-wired on the KL25Z to the red on-board LED. "
                              + "Using this port will supersede the red LED's normal status "
                              + "display function." },
    { name: "PTB19", pwm: "2.1", onBoardLED: 2,
                     internal: true, internalName: "Green on-board LED", internalShortName: "Green LED",
                     warning: "This port is hard-wired on the KL25Z to the green on-board LED. "
                              + "Using this port will supersede the green LED's normal status "
                              + "display function." },
    { name: "PTC0",  adc: "0.14" },
    // { name: "PTC1",  pwm: "0.0", adc: "0.15", idc: "1.SCL" }, // omitted - reserved by mbed platform for real-time clock input
    { name: "PTC2",  pwm: "0.1", adc: "0.11", idc: "1.SDA" },
    { name: "PTC3",  pwm: "0.2" },
    { name: "PTC4",  pwm: "0.3" },
    { name: "PTC5",  spi: "SCLK" },
    { name: "PTC6",  spi: "MOSI" },
    { name: "PTC7",  spi: "MISO" },
    { name: "PTC8",  pwm: "0.4", i2c: "0.SCL" },
    { name: "PTC9",  pwm: "0.5", i2c: "0.SDA" },
    { name: "PTC10", i2c: "1.SCL"  },
    { name: "PTC11", i2c: "1.SDA"  },
    { name: "PTC12"  },
    { name: "PTC13"  },
    { name: "PTC16"  },
    { name: "PTC17"  },
    { name: "PTD0",  pwm: "0.0", interrupt: true },
    { name: "PTD1",  pwm: "0.1", adc: "0.5b", spi: "SCLK", onBoardLED: 3, interrupt: true,
                     remarks: "Blue on-board LED",
                     warning: "This port is hard-wired on the KL25Z to the blue on-board LED. "
                              + "You can use this port for other purposes, but doing so will "
                              + "supersede the blue LED's normal status display function." },
    { name: "PTD2",  pwm: "0.2", spi: "MOSI", interrupt: true },
    { name: "PTD3",  pwm: "0.3", spi: "MISO", interrupt: true },
    { name: "PTD4",  pwm: "0.4", interrupt: true },
    { name: "PTD5",  pwm: "0.5", adc: "0.6b", interrupt: true },
    { name: "PTD6",  adc: "0.7b", interrupt: true },
    { name: "PTD7",  interrupt: true},
    { name: "PTE0",  i2c: "1.SDA" },
    { name: "PTE1",  i2c: "1.SCL" },
    { name: "PTE2"   },
    { name: "PTE3"   },
    { name: "PTE4"   },
    { name: "PTE5"   },
    { name: "PTE20", pwm: "1.0", adc: "0.0" },
    { name: "PTE21", pwm: "1.1", adc: "0.4a" },
    { name: "PTE22", pwm: "2.0", adc: "0.3" },
    { name: "PTE23", pwm: "2.1", adc: "0.7a" },
    { name: "PTE29", pwm: "0.2", adc: "0.4b" },
    { name: "PTE30", pwm: "0.3", adc: "0.23" },
    { name: "PTE31", pwm: "0.4" }
];

// build a hash of the pin table indexed by name
var gpioPinsByName = { };
for (var i = 0 ; i < gpioPins.length ; ++i)
    gpioPinsByName[gpioPins[i].name] = gpioPins[i];

// get the jumper location for a given pin
function pinToJumper(pin)
{
    var g = gpioPinsByName[pin] || {};
    return g.internalShortName || (g.pin || {}).name;
}

// Extract the TPM unit from a PWM channel name.  Channel
// names are in the format "1.2", where 1 is the TPM unit
// number and 2 is the channel number.  We pull out just
// the TPM unit number ("1" in this case).
function pwmToTpm(pwm)
{
    return /(\d+)\.\d+/.test(pwm) ? RegExp.$1 : null;
}

// build a hash of PWM channels and the associated pins
var pwmChannels = { };
var tpmUnits = { };
for (var i = 0 ; i < gpioPins.length ; ++i)
{
    var g = gpioPins[i];
    if (g.pwm)
    {
        var t = pwmChannels[g.pwm];
        if (!t)
            pwmChannels[g.pwm] = t = {
                name: g.pwm,
                orList: function() { return serialComma($.map(this.pins, function(ele) { return ele.name; }), "or"); },
                pins: []
            };
        t.pins.push(g);

        var tpm = pwmToTpm(g.pwm);
        if (!(t = tpmUnits[tpm]))
        {
            tpmUnits[tpm] = t = {
                name: tpm,
                orList: function() { return serialComma($.map(this.pins, function(ele) { return ele.name; }), "or"); },
                pins: []
            };
        }
        t.pins.push(g);
    }
}

// KL25Z pin headers
var kl25z_headers = {
    "J1": {
        pins: [["PTC7", "PTC0", "PTC3", "PTC4",  "PTC5", "PTC6", "PTC10", "PTC11"],
               ["PTA1", "PTA2", "PTD4", "PTA12", "PTA4", "PTA5", "PTC8",  "PTC9"]],
        type: "pinheader",
        pin1: [26, 88],
        pinN: [14, 174]
    },
    "J2": {
        pins: [["PTC12", "PTC13", "PTC16", "PTC17", "PTA16", "PTA17", "PTE31", "NC",    "PTD6", "PTD7"],
               ["PTA13", "PTD5",  "PTD0",  "PTD2",  "PTD3",  "PTD1",  "GND",   "VREFH", "PTE0", "PTE1"]],
        type: "pinheader",
        pin1: [26, 194],
        pinN: [14, 306]
    },
    "J9": {
        pins: [["PTB8",    "PTB9", "PTB10", "PTB11", "PTE2",  "PTE3", "PTE4", "PTE5"],
               ["SDA_PTD", "P3V3", "RESET", "P3V3",  "USB5V", "GND",  "GND",  "VIN"]],
        type:   "pinheader",
        pin1: [238, 262],
        pinN: [250, 175]
    },
    "J10": {
        pins: [["PTE20", "PTE21", "PTE22", "PTE23", "PTE29", "PTE30"],
               ["PTB0",  "PTB1",  "PTB2",  "PTB3",  "PTC2",  "CLKIN"]],
        type: "pinheader",
        pin1: [238, 150],
        pinN: [250, 88]
    },

    // fake header representing the internal LED connections
    "LED": {
        pins: [["PTB18", "PTB19"]],
        type: "pinheader",
        pin1: [163, 137],
        pinN: [163, 152]
    }
};

// TLC5940 pins
var tlc5940_pins = {
    pins: ["OUT1",  "OUT2", "OUT3", "OUT4",  "OUT5",  "OUT6", "OUT7", "OUT8", "OUT9",  "OUT10", "OUT11", "OUT12", "OUT13", "OUT14",
           "OUT15", "XERR", "SOUT", "GSCLK", "DCPRG", "IREF", "VCC",  "GND",  "BLANK", "XLAT",  "SCLK",  "SIN",   "VPRG",  "OUT0"],
    type: "dip",
    pin1: [73, 46],
    pinN: [197, 368]
};

// 74HC595 pins
var hc595_pins = {
    pins: ["OUT1",  "OUT2", "OUT3", "OUT4",  "OUT5",  "OUT6", "OUT7", "GND",
           "OUT7'", "RST",  "SCLK", "LATCH", "ENA",   "SIN",  "OUT0", "VCC"],
    type: "dip",
    pin1: [85, 99],
    pinN: [188, 337]
};

// TLC59116 pins
var tlc59116_pins = {
    pins: ["REXT", "A0",   "A1",    "A2",    "A3",  "OUT0",  "OUT1",  "OUT2",  "OUT3",  "GND", "OUT4",  "OUT5", "OUT6", "OUT7",
           "OUT8", "OUT9", "OUT10", "OUT11", "GND", "OUT12", "OUT13", "OUT14", "OUT15", "GND", "RESET", "SCL",  "SDA",  "VCC"],
    type: "dip",
    pin1: [73, 46],
    pinN: [197, 368]
};

// Expansion board - main board headers
var mainBoard_headers = {
    "JP12": {
        pins: [["PTC4", "PTC0"],
               ["PTC3", "PTA2"]],
        type: "pinheader",
        pin1: [217, 76],
        pinN: [226, 67],
        orientation: "horizontal"
    },

    "JP11": {
        pins: [["3.8", "3.9", "3.10", "3.11", "3.12", "3.13", "3.14", "+5V"],
               ["3.0", "3.1", "3.2",  "3.3",  "3.4",  "3.5",  "3.6",  "3.7"]],
        type: "pinheader",
        pin1: [91, 137],
        pinN: [82, 77]
    },

    "JP8": {
        pins: [["3.16", "3.17", "3.18", "3.19", "3.20", "3.21", "3.28", "3.29", "3.30"],
               ["3.22", "3.23", "3.24", "3.25", "3.26", "3.27", "3.31", "NC", "+5V"]],
        type: "pinheader",
        pin1: [327, 152],
        pinN: [318, 83]
    },

    "JP3": {
        pins: [["PTE23", "LED+"],   // JP3-3 = LED+ = +5V; JP3-1 = Cal Btn LED- = open collector switched by PTE23
               ["PTE29", "GND"]],   // JP3-2 = Cal Btn = direct connection to PTE29
        type: "pinheader",
        orientation: "horizontal",
        pin1: [239, 336],
        pinN: [231, 345]
    },
    
    "JP2": {
        pins: [["PTB0", "PTE21", "3.3V", "5V"],
               ["NC",   "PTE22", "GND",  "PTE20"]],
        type: "pinheader",
        pin1: [206, 336],
        pinN: [181, 345]
    },
    
    "JP1": {
        pins: [["PTC2", "PTB2", "PTE30", "PTE5", "PTE3", "PTB11", "PTB9", "PTC12", "PTC16", "PTA16", "PTE31", "PTD7", "NC"],
               ["PTB3", "PTB1", "PTC11", "PTE4", "PTE2", "PTB10", "PTB8", "PTC13", "PTC17", "PTA17", "PTD6",  "PTE1", "COMMON"]],
        type: "pinheader",
        pin1: [144, 337],
        pinN: [43, 346]
    },

    "JP9": {
        pins: [["PTC8", "3.15"]],
        type: "pinheader",
        pin1: [190, 71],
        pinN: [199, 71]
    }

    // JP6 - PWM OUT.  For reference only; none of these pins
    // can be assigned as inputs or outputs
    //"JP6": {
    //    pins: [["SOUT", "SCLK", "XLAT", "BLANK", "GSCLK"],
    //           ["GND",  "GND",  "GND",  "GND",   "NC"]],
    //    type: "pinheader",
    //    pin1: [320, 214],
    //    pinN: [328, 249]
    //},

    // JP5 - Chime Out.  For reference only; these pins aren't
    // assignable as inputs or outputs.
    //"JP5": {
    //    pins: [["SOUT", "SCLK", "LATCH", "ENA", "3.3V"],
    //           ["NC",   "GND",  "GND",   "GND", "GND"]],
    //    type: "pinheader",
    //    pin1: [319, 285],
    //    pinN: [328, 320]
    //},

    // JP4 - TV switches.  For reference only; these pins can't
    // be assigned as inputs or outputs.
    //"JP4": {
    //    pins: [["TV1",  "TV2",  "IR+"],      // JP4-5 = IR+ = 5V
    //           ["TV1",  "TV2",  "PTC9"]],    // JP4-6 = IR- = open collector switched by PTC9
    //    type: "pinheader",
    //    pin1: [275, 309],
    //    pinN: [258, 317]
    //},
};

var powerBoard_headers = {
    "JP5": {
        pins: [["3.32", "3.33", "3.34", "3.35", "3.36", "3.37", "3.38", "3.39", "3.40", "3.41", "3.42", "3.43", "3.44", "3.45", "3.46", "3.47"]],
        type: "pinheader",
        pin1: [97, 49],
        pinN: [225, 49]
    },
    
    "JP6": {
        pins: [["3.48", "3.49", "3.50", "3.51", "3.52", "3.53", "3.54", "3.55", "3.56", "3.57", "3.58", "3.59", "3.60", "3.61", "3.62", "3.63"]],
        type: "pinheader",
        pin1: [97, 361],
        pinN: [225, 361]
    }

    // for reference only - these pins aren't assignable
    //"JP2": {
    //    pins: [["SIN",  "SCLK", "XLAT", "BLANK", "GSCLK"],
    //           ["GND",  "GND",  "GND",  "GND",   "GND"]],
    //    type: "pinheader",
    //    pin1: [318, 212],
    //    pinN: [327, 246]
    //},
    //"JP3": {
    //    pins: [["SOUT", "SCLK", "XLAT", "BLANK", "GSCLK"],
    //           ["GND",  "GND",  "GND",  "GND",   "GND"]],
    //    type: "pinheader",
    //    pin1: [318, 292],
    //    pinN: [327, 327]
    //}
};

var chimeBoard_headers = {
    "JP9": {
        pins: [["4.0", "4.1", "4.2", "4.3", "4.4", "4.5", "4.6", "4.7"]],
        type: "pinheader",
        pin1: [113, 68],
        pinN: [174, 68]
    }

    // for reference only - these pins aren't assignable
    //"JP2": {
    //    pins: [["SOUT", "SCLK", "LATCH", "ENA", "3.3V"],
    //           ["NC",   "GND",  "GND",   "GND", "GND"]],
    //    type: "pinheader",
    //    pin1: [319, 224],
    //    pinN: [328, 259]
    //},
    //"JP3": {
    //    pins: [["SIN",  "SCLK", "LATCH", "ENA", "3.3V"],
    //           ["NC",   "GND",  "GND",   "GND", "GND"]],
    //    type: "pinheader",
    //    pin1: [319, 299],
    //    pinN: [328, 334]
    //}
};

// Iterate over a pin header object.  Calls func(name, x, y), where
// 'name' is the pin name, 'n' is the pin number (starting at 1), and
// 'x' and 'y' give the spatial coordinates.
function forEachPin(header, func)
{
    ({ "dip": forEachDIPPin, "pinheader": forEachHeaderPin })[header.type](header, func);
}

// DIP IC chip pins are conventionally arranged clockwise around
// the chip, starting with pin 1 at the lower left:
//
//   n n-1 n-2 ... n/2+1
//   1 2   3   ... n/2
//
// Chips can of course be rotated on the board.  We allow rotations
// in 90 degree increments.  We infer the orientation from the
// positions of the first pin and diametrically opposed pins, given
// by properties pin1=[x,y] and pinN=[x,y].  The pin positions are
// given as image-relative coordinates of the centers of the
// respective pins.  Note that pinN isn't the highest numbered pin:
// it's actually the diametrically opposed pin, so the first pin
// in the second row at pin number n/2+1.
function forEachDIPPin(chip, func)
{
    // get the number of pins, and the number on each side (it's a DIP,
    // so there are exactly two rows of pins)
    var npins = chip.pins.length;
    var oneSidePins = npins/2;

    // get the pin 1 location (pin1=[x,y] position of center of pin 1)
    var x1 = chip.pin1[0];
    var y1 = chip.pin1[1];

    // get the last pin location (pinN=[x,y] position of center of last pin)
    var xN = chip.pinN[0];
    var yN = chip.pinN[1];

    // Infer the orientation.  If pin1 is at the lower left or upper right,
    // it's horizontal, otherwise it's vertical.
    var horizontal = ((x1 < xN && y1 > yN) || (x1 > xN && y1 < yN));

    // figure the iteration increments
    var pindx = 0, pindy = 0, rowdx = 0, rowdy = 0;
    if (horizontal)
    {
        if (oneSidePins > 1) pindx = (xN - x1)/(oneSidePins - 1);
        rowdy = yN - y1;
    }
    else
    {
        if (oneSidePins > 1) pindy = (yN - y1)/(oneSidePins - 1);
        rowdx = xN - x1;
    }

    // go up the first row, starting at pin 1
    var pins = chip.pins;
    var x = x1, y = y1;
    for (var pin = 0 ; pin < oneSidePins ; ++pin, x += pindx, y += pindy)
        func(pins[pin], pin, x, y);

    // go down the second row, reversing direction
    for (x += rowdx, y += rowdy, x -= pindx, y -= pindy ; pin < npins ; ++pin, x -= pindx, y -= pindy)
        func(pins[pin], pin, x, y);
}

// Pin headers are arranged into rows and columns, where the
// row is the long dimension.  E.g., a 2x10 header has 2 rows
// of 10 pins, and a 3x15 has 3 rows of 15 pins.
//
// We use a zig-zag numbering scheme.  Pin 1 is always at
// one corner.  Pin 2 is the next pin in the same column.
// Continue numbering up the column until reaching the last
// pin, then go back to the next pin in the starting row.
// Repeat until done.
//
// This conventional is pretty universal, but the headers
// can of course be rotated, and they can also be mirrored.
// We allow for four rotations, at right angles.
//
// header.pins = [[row1], [row2], [row3]...] - pin name strings
// header.pin1 = [x,y] - center coordinates of pin 1, relative to image
// header.pinN = [x,y] - center coordinates of LAST pin, relative to image
//
// Important: the pin1 and pinN positions are the coordinates
// of the centers of the respective pins, not of the header
// plastic or shroud.  Also, note that the property name pinN
// is literal - the N isn't meant to be replaced with a number,
// it's just a literal N.
//
// For reference, here are the standard numbering layouts in
// the cardinal rotations.  In most cases, we can work out the
// orientation on our own, by noting which dimension (x or y)
// is longer - the long dimension is the row.  The exception
// is when the pin array is square, such as a 2x2.  In this
// case, we need to know whether it's a horizontal or vertical
// orientation.  Set header.orientation to "horizontal" or
// "vertical" in this case to tell us which it is.  (You can
// set that in all cases, and it'll override our inference if
// set, but it's easier to omit it when not necessary.)
//
//            0 deg        90 deg      180 deg     270 deg
//
//                           6 5                     1 2
//            2 4 6          4 3        5 3 1        3 4
//  normal    1 3 5          2 1        6 4 2        5 6
//
//                           2 1                     5 6
//            6 4 2          4 3        1 3 5        3 4
//  mirror    5 3 1          6 5        2 5 6        1 2
//
function forEachHeaderPin(header, func)
{
    // get the number of pin rows in this header, and number of pins in each row
    var nrows = header.pins.length;
    var npins = header.pins[0].length;

    // get the pin 1 location (header.pin1 = [x,y])
    var x1 = header.pin1[0];
    var y1 = header.pin1[1];

    // get the position of the last pin (pinN)
    var xN = header.pinN[0];
    var yN = header.pinN[1];

    // figure the orientation - user the header.orientation setting if provided,
    // of infer it from which dimension is longer
    var wid = Math.abs(x1 - xN);
    var ht = Math.abs(y1 - yN);
    var orientation = header.orientation || (wid > ht ? "horizontal" : "vertical");

    // figure the column (pin) and row increments for the iteration
    var rowdx = 0, rowdy = 0, pindx = 0, pindy = 0;
    if (orientation == "horizontal")
    {
        // horizontal
        if (npins > 1) pindx = (xN - x1)/(npins - 1);
        if (nrows > 1) rowdy = (yN - y1)/(nrows - 1);
    }
    else
    {
        // vertical
        if (npins > 1) pindy = (yN - y1)/(npins - 1);
        if (nrows > 1) rowdx = (xN - x1)/(nrows - 1);
    }

    // start at pin 1
    var xrow = x1, yrow = y1;

    // process each row
    for (var row = 0 ; row < nrows ; ++row, xrow += rowdx, yrow += rowdy)
    {
        // start at the first pin of the row
        var pinno = row+1;
        var x = xrow, y = yrow;
        var pinrow = header.pins[row];
        
        // process each pin in the row
        for (var pin = 0 ; pin < npins ; ++pin, x += pindx, y += pindy, pinno += nrows)
            func(pinrow[pin], pinno, x, y);
    }
}

</script>


<h1>
   <img src="h1options.png" style="float: right;">
   Settings
   <img src="h1options.png" style="vertical-align: middle; visibility: hidden;">
</h1>

<div>

   <p>
      <b>Configuration settings for KL25Z CPU ID
      <span id="CPUID">unknown</span></b>
   </p>
   <div id="heapInfo" style="display: none;">
      Memory used: <span id="usedHeapBytes">Unknown</span> of 16K bytes (<span id="freeHeapBytes">Unknown</span> bytes free)
      <a href="#" class="shower">Explain</a>
      <div class="hider">
         This shows the total RAM usage on the KL25Z for your current configuration.
         Memory usage is mostly static; the software allocates memory during initialization
         after the device boots up.  You shouldn't see any fluctuation during normal use.
         Memory usage changes only when you add or remove features via the settings below,
         and only updates after you save the new settings.  Since memory is assigned
         during startup, the software doesn't need much free memory to run, so don't
         worry if the free space looks tight.  We show the memory figure mostly for
         diagnostics, and to give you an idea of how much headroom you have left for
         enabling additional features.
      </div>
   </div>


   <!--  System type  ----------------------------------------------------->
   <hr>
   <div class="section" data-name="System Type">
      <div>
         <img src="hardwareSection.png" class="sectionIcon">
         <b>System type.</b>  Are you using this KL25Z on its own,
         or with a set of expansion boards?  <a href="#" class="shower">Help</a>

         <div class="hider">
            If you're using the <a href="http://mjrnet.org/pinscape/expansion-board.html" target="_blank">
            Pinscape expansion boards</a>, select that option below, and the
            setup tool will automatically fill in the appropriate pin assignments
            throughout the configuration.
            If you're using the KL25Z by itself, or you're using your own custom add-ons
            (e.g., your own output booster circuits), select "stand-alone" so that you
            can set the individual pin assignments to match your wiring.
         </div>

         <table class="radio">
            <tr>
               <td>
                  <label>
                     <img src="kl25z.png"><br>
                     <input type="radio" name="hardwareType" value="0">
                     Stand-alone KL25Z<br>
                     (or your own custom boards)
                  </label>
               </td>
               <td>
                  <label>
                     <img src="expansionStack.png"><br>
                     <input type="radio" name="hardwareType" value="1">
                     Pinscape Expansion Boards<br>
                     &nbsp;
                  </label>
               </td>
            </tr>
         </table>
         <input type="hidden" id="expBoardVersion">

         <!-- expansion board options - initially hidden -->
         <div id="expansionBoardOptions" style="height: 0px; overflow: hidden; margin: 1em 2em;">
            <b>Expansion board details:</b>
            <input id="numMainBoards" type="hidden">
            <table class="inputs">
               <!--
               <tr>
                  <td>Number of main interface boards:</td>
                  <td><input type="text" id="numMainBoards" size="4" value="1">
               </tr>
               -->
               <tr>
                  <td>Number of MOSFET power boards:</td>
                  <td><input type="text" id="numPowerBoards" size="4" value="0">
               </tr>
               <tr>
                  <td>Number of chime boards:</td>
                  <td><input type="text" id="numChimeBoards" size="4" value="0">
               </tr>
            </table>

            <div>
               <label><input type="checkbox" id="ckExpBoardShowPins"> Show KL25Z pin assignments</label>
               <div style="margin: 1ex 0px 0px 2em;">
                  The KL25Z pin assignments are hidden by default because you've selected the
                  expansion board configuration.  All pin assignments are pre-determined in
                  this configuration.  Check the box above if you want to view the pin assignments
                  anyway, but be aware that any changes to pin assignments will probably cause problems.
               </div>
            </div>
         </div>
      </div>

      <script>

// Factory configuration for the stand-alone KL25Z (no expansion boards)
var standaloneFactoryConfig = {
    expansionBoards: {
        version: "0",
        ext0: "0",
        ext1: "0",
        ext2: "0"
    },
    calButtonPins: {
        enabled: 0x03,
        button: "PTE29",
        led: "PTE23"
    },
    TVon: {
        statusPin: "NC",
        latchPin: "NC",
        relayPin: "NC",
        delay: 0
    },
    TLC5940: {
        nchips: 0,
        SIN: "PTC6",
        SCLK: "PTC5",
        XLAT: "PTC10",
        BLANK: "PTC7",
        GSCLK: "PTA1"
    },
    HC595: {
        nchips: 0,
        SIN: "PTA5",
        SCLK: "PTA4",
        LATCH: "PTA12",
        ENA: "PTD4"
    },
    TLC59116: {
        chipMask: 0,
        SDA: "NC",
        SCL: "NC",
        RESET: "NC"
    },
    ZBLaunchBall: {
        port: 0,
        keytype: 2,             // keyboard key
        keycode: 0x28,          // Enter key
        pushDistance: 63        // .063" ~ 1/16"
    },
    buttons: {
        // use the defaults from earlier versions, where everything was mapped to joystick buttons
        1:  { pin: "PTC2",  keytype: 1, keycode: 1, flags: 0 },
        2:  { pin: "PTB3",  keytype: 1, keycode: 2, flags: 0 },
        3:  { pin: "PTB2",  keytype: 1, keycode: 3, flags: 0 },
        4:  { pin: "PTB1",  keytype: 1, keycode: 4, flags: 0 },
        5:  { pin: "PTE30", keytype: 1, keycode: 5, flags: 0 },
        6:  { pin: "PTE22", keytype: 1, keycode: 6, flags: 0 },
        7:  { pin: "PTE5",  keytype: 1, keycode: 7, flags: 0 },
        8:  { pin: "PTE4",  keytype: 1, keycode: 8, flags: 0 },
        9:  { pin: "PTE3",  keytype: 1, keycode: 9, flags: 0 },
        10: { pin: "PTE2",  keytype: 1, keycode: 10, flags: 0 },
        11: { pin: "PTB11", keytype: 1, keycode: 11, flags: 0 },
        12: { pin: "PTB10", keytype: 1, keycode: 12, flags: 0 },
        13: { pin: "PTB9",  keytype: 1, keycode: 13, flags: 0 },
        14: { pin: "PTB8",  keytype: 1, keycode: 14, flags: 0 },
        15: { pin: "PTC12", keytype: 1, keycode: 15, flags: 0 },
        16: { pin: "PTC13", keytype: 1, keycode: 16, flags: 0 },
        17: { pin: "PTC16", keytype: 1, keycode: 17, flags: 0 },
        18: { pin: "PTC17", keytype: 1, keycode: 18, flags: 0 },
        19: { pin: "PTA16", keytype: 1, keycode: 19, flags: 0 },
        20: { pin: "PTA17", keytype: 1, keycode: 20, flags: 0 },
        21: { pin: "PTE31", keytype: 1, keycode: 21, flags: 0 },
        22: { pin: "PTD6",  keytype: 1, keycode: 22, flags: 0 },
        23: { pin: "PTD7",  keytype: 1, keycode: 23, flags: 0 },
        24: { pin: "PTE1",  keytype: 1, keycode: 24, flags: 0 }
    },
    outputs: {
        1: { port: { type: 1, pin: "PTA1" }, flags: 0x00 },     // port 1  = PTA1 (PWM)
        2: { port: { type: 1, pin: "PTA2" }, flags: 0x00 },     // port 2  = PTA2 (PWM)
        3: { port: { type: 1, pin: "PTD4" }, flags: 0x00 },     // port 3  = PTD4 (PWM)
        4: { port: { type: 1, pin: "PTA12" }, flags: 0x00 },    // port 4  = PTA12 (PWM)
        5: { port: { type: 1, pin: "PTA4" }, flags: 0x00 },     // port 5  = PTA4 (PWM)
        6: { port: { type: 1, pin: "PTA5" }, flags: 0x00 },     // port 6  = PTA5 (PWM)
        7: { port: { type: 1, pin: "PTA13" }, flags: 0x00 },    // port 7  = PTA13 (PWM)
        8: { port: { type: 1, pin: "PTD5" }, flags: 0x00 },     // port 8  = PTD5 (PWM)
        9: { port: { type: 1, pin: "PTD0" }, flags: 0x00 },     // port 9  = PTD0 (PWM)
        10: { port: { type: 2, pin: "PTD3" }, flags: 0x00 },    // port 10 = PTD3 (PWM)
        11: { port: { type: 2, pin: "PTD2" }, flags: 0x00 },    // port 11 = PTD2 (Digital)
        12: { port: { type: 2, pin: "PTC8" }, flags: 0x00 },    // port 12 = PTC8 (Digital)
        13: { port: { type: 2, pin: "PTC9" }, flags: 0x00 },    // port 13 = PTC9 (Digital)
        14: { port: { type: 2, pin: "PTC7" }, flags: 0x00 },    // port 14 = PTC7 (Digital)
        15: { port: { type: 2, pin: "PTC0" }, flags: 0x00 },    // port 15 = PTC0 (Digital)
        16: { port: { type: 2, pin: "PTC3" }, flags: 0x00 },    // port 16 = PTC3 (Digital)
        17: { port: { type: 2, pin: "PTC4" }, flags: 0x00 },    // port 17 = PTC4 (Digital)
        18: { port: { type: 2, pin: "PTC5" }, flags: 0x00 },    // port 18 = PTC5 (Digital)
        19: { port: { type: 2, pin: "PTC6" }, flags: 0x00 },    // port 19 = PTC6 (Digital)
        20: { port: { type: 2, pin: "PTC10" }, flags: 0x00 },   // port 20 = PTC10 (Digital)
        21: { port: { type: 2, pin: "PTC11" }, flags: 0x00 },   // port 21 = PTC11 (Digital)
        22: { port: { type: 2, pin: "PTE0" }, flags: 0x00 }     // port 22 = PTE0 (Digital)
    }
};
var standaloneFactoryXConfig = { };

// Factory configuration for the expansion boards
var expansionBoardFactoryConfig = {
    expansionBoards: {
        version: "0",
        ext0: "1",
        ext1: "1",
        ext2: "0"
    },
    calButtonPins: {
        enabled: 0x03,
        button: "PTE29",
        led: "PTE23"
    },
    TVon: {
        statusPin: "PTD2",
        latchPin: "PTE0",
        relayPin: "PTD3",
        delay: 700
    },
    TLC5940: {
        SIN: "PTC6",
        SCLK: "PTC5",
        XLAT: "PTC10",
        BLANK: "PTC7",
        GSCLK: "PTA1"
    },
    HC595: {
        SIN: "PTA5",
        SCLK: "PTA4",
        LATCH: "PTA12",
        ENA: "PTD4"
    },
    TLC59116: {
        chipMask: 0,
        SDA: "NC",
        SCL: "NC",
        RESET: "NC"
    },
    ZBLaunchBall: {
        port: 0,
        keytype: 2,             // keyboard key
        keycode: 0x28,          // Enter key
        pushDistance: 63        // .063" ~ 1/16"
    },
    IRRemote: {
        sensorPin: "PTA13",
        ledPin: "PTC9"
    },
    buttons: {
        // for expansion board mode, use keyboard mappings for the standard VP and VPinMAME keys
        1:  { pin: "PTC2",  keytype: 2, keycode: 0x1E, flags: 0 },  // "1" = start
        2:  { pin: "PTB3",  keytype: 2, keycode: 0x1F, flags: 0 },  // "2" = extra ball
        3:  { pin: "PTB2",  keytype: 2, keycode: 0x22, flags: 0 },  // "5" = coin 1
        4:  { pin: "PTB1",  keytype: 2, keycode: 0x21, flags: 0 },  // "4" = coin 2
        5:  { pin: "PTE30", keytype: 2, keycode: 0x23, flags: 0 },  // "6" = coin 4
        6:  { pin: "PTC11", keytype: 2, keycode: 0x28, flags: 0 },  // Enter = launch ball
        7:  { pin: "PTE5",  keytype: 2, keycode: 0x29, flags: 0 },  // Escape = exit
        8:  { pin: "PTE4",  keytype: 2, keycode: 0x14, flags: 0 },  // "Q" = quit 
        9:  { pin: "PTE3",  keytype: 2, keycode: 0xE1, flags: 0 },  // left shift = left flipper 
        10: { pin: "PTE2",  keytype: 2, keycode: 0xE5, flags: 0 },  // right shift = right flipper
        11: { pin: "PTB11", keytype: 2, keycode: 0xE0, flags: 0 },  // left control = left magna
        12: { pin: "PTB10", keytype: 2, keycode: 0xE4, flags: 0 },  // right control = right magna 
        13: { pin: "PTB9",  keytype: 2, keycode: 0x17, flags: 0 },  // "T" = tilt bob  
        14: { pin: "PTB8",  keytype: 2, keycode: 0x4A, flags: 0 },  // Home = slam tilt switch
        15: { pin: "PTC12", keytype: 2, keycode: 0x2C, flags: 0 },  // Space = keyboard nudge
        16: { pin: "PTC13", keytype: 2, keycode: 0x4D, flags: 0 },  // "End" = coin door
        17: { pin: "PTC16", keytype: 2, keycode: 0x24, flags: 0 },  // "7" = service escape
        18: { pin: "PTC17", keytype: 2, keycode: 0x25, flags: 0 },  // "8" = service down/-
        19: { pin: "PTA16", keytype: 2, keycode: 0x26, flags: 0 },  // "9" = service up/+
        20: { pin: "PTA17", keytype: 2, keycode: 0x27, flags: 0 },  // "0" = service enter
        21: { pin: "PTE31", keytype: 2, keycode: 0x2E, flags: 0 },  // "=" = VP volume down
        22: { pin: "PTD6",  keytype: 2, keycode: 0x2D, flags: 0 },  // "-" = VP volume up
        23: { pin: "PTD7",  keytype: 3, keycode: 0xE9, flags: 0 },  // media volume down
        24: { pin: "PTE1",  keytype: 3, keycode: 0xEA, flags: 0 }   // media volume up
    },
    outputs: {
        // Map the first 16 ports to the flashers & strobe on TLC5940 #1.
        // These are among the most common devices, so we want to map them
        // into the first 32 logical port numbers for LedWiz compatibility.
        1:  { port: { type: 3, pin: 0  }, flags: 0x04 },
        2:  { port: { type: 3, pin: 1  }, flags: 0x04 },
        3:  { port: { type: 3, pin: 2  }, flags: 0x04 },
        4:  { port: { type: 3, pin: 3  }, flags: 0x04 },
        5:  { port: { type: 3, pin: 4  }, flags: 0x04 },
        6:  { port: { type: 3, pin: 5  }, flags: 0x04 },
        7:  { port: { type: 3, pin: 6  }, flags: 0x04 },
        8:  { port: { type: 3, pin: 7  }, flags: 0x04 },
        9:  { port: { type: 3, pin: 8  }, flags: 0x04 },
        10: { port: { type: 3, pin: 9  }, flags: 0x04 },
        11: { port: { type: 3, pin: 10 }, flags: 0x04 },
        12: { port: { type: 3, pin: 11 }, flags: 0x04 },
        13: { port: { type: 3, pin: 12 }, flags: 0x04 },
        14: { port: { type: 3, pin: 13 }, flags: 0x04 },
        15: { port: { type: 3, pin: 14 }, flags: 0x04 },
        16: { port: { type: 3, pin: 15 }, flags: 0x04 },

        // Map port 17 to the knocker output, since it shares the jumper with the
        // strobe on output 16 - that makes these two physically adjacent outputs
        // logically adjacent in the port mapping.  Knockers are also quite common,
        // so this belongs in the first 32 ports anyway.  Mark it as noisy.
        17: { port: { type: 2, pin: "PTC8"}, flags: 0x02 },

        // Map the next 32 ports to the outputs from the first power board.  These
        // are TLC5940 chips #3 and #4 in the daisy chain (the main board has #1
        // and #2).  This mapping will provide an additional 15 general-purpose 
        // outputs that are accessible through the legacy LedWiz protocol, plus 17
        // more that aren't (because the ports are numbered 33 and up).  Once we
        // get above port 32 (the highest LedWiz-compatible port number), there are
        // no external constraints on port numbering, so we might as well just keep
        // going with contiguous port numbering for the remaining power board outputs.
        // This gives us consecutive DOF numbering for all 32 outputs on the board.
        //
        // These are general-purpose outputs, so don't use gamma.
        18: { port: { type: 3, pin: 32 }, flags: 0x00 },
        19: { port: { type: 3, pin: 33 }, flags: 0x00 },
        20: { port: { type: 3, pin: 34 }, flags: 0x00 },
        21: { port: { type: 3, pin: 35 }, flags: 0x00 },
        22: { port: { type: 3, pin: 36 }, flags: 0x00 },
        23: { port: { type: 3, pin: 37 }, flags: 0x00 },
        24: { port: { type: 3, pin: 38 }, flags: 0x00 },
        25: { port: { type: 3, pin: 39 }, flags: 0x00 },
        26: { port: { type: 3, pin: 40 }, flags: 0x00 },
        27: { port: { type: 3, pin: 41 }, flags: 0x00 },
        28: { port: { type: 3, pin: 42 }, flags: 0x00 },
        29: { port: { type: 3, pin: 43 }, flags: 0x00 },
        30: { port: { type: 3, pin: 44 }, flags: 0x00 },
        31: { port: { type: 3, pin: 45 }, flags: 0x00 },
        32: { port: { type: 3, pin: 46 }, flags: 0x00 },
        33: { port: { type: 3, pin: 47 }, flags: 0x00 },
        34: { port: { type: 3, pin: 48 }, flags: 0x00 },
        35: { port: { type: 3, pin: 49 }, flags: 0x00 },
        36: { port: { type: 3, pin: 50 }, flags: 0x00 },
        37: { port: { type: 3, pin: 51 }, flags: 0x00 },
        38: { port: { type: 3, pin: 52 }, flags: 0x00 },
        39: { port: { type: 3, pin: 53 }, flags: 0x00 },
        40: { port: { type: 3, pin: 54 }, flags: 0x00 },
        41: { port: { type: 3, pin: 55 }, flags: 0x00 },
        42: { port: { type: 3, pin: 56 }, flags: 0x00 },
        43: { port: { type: 3, pin: 57 }, flags: 0x00 },
        44: { port: { type: 3, pin: 58 }, flags: 0x00 },
        45: { port: { type: 3, pin: 59 }, flags: 0x00 },
        46: { port: { type: 3, pin: 60 }, flags: 0x00 },
        47: { port: { type: 3, pin: 61 }, flags: 0x00 },
        48: { port: { type: 3, pin: 62 }, flags: 0x00 },
        49: { port: { type: 3, pin: 63 }, flags: 0x00 },

        // Map the main board flipper button light/small LED outputs next.
        // These are the 16 outputs from the TLC5940 #2.  Flipper button
        // lights aren't among the most common toys, so we deliberately
        // map these in the high number range (where old LedWiz software
        // won't be able to access them) to make room for more common toys
        // in the LedWiz range.
        //
        // These are meant for LEDs, so use gamma by default.
        50: { port: { type: 3, pin: 16 }, flags: 0x04 },
        51: { port: { type: 3, pin: 17 }, flags: 0x04 },
        52: { port: { type: 3, pin: 18 }, flags: 0x04 },
        53: { port: { type: 3, pin: 19 }, flags: 0x04 },
        54: { port: { type: 3, pin: 20 }, flags: 0x04 },
        55: { port: { type: 3, pin: 21 }, flags: 0x04 },
        56: { port: { type: 3, pin: 22 }, flags: 0x04 },
        57: { port: { type: 3, pin: 23 }, flags: 0x04 },
        58: { port: { type: 3, pin: 24 }, flags: 0x04 },
        59: { port: { type: 3, pin: 25 }, flags: 0x04 },
        60: { port: { type: 3, pin: 26 }, flags: 0x04 },
        61: { port: { type: 3, pin: 27 }, flags: 0x04 },
        62: { port: { type: 3, pin: 28 }, flags: 0x04 },
        63: { port: { type: 3, pin: 29 }, flags: 0x04 },
        64: { port: { type: 3, pin: 30 }, flags: 0x04 },
        65: { port: { type: 3, pin: 31 }, flags: 0x04 }
    }
};
var expansionBoardFactoryXConfig = { };

// fill out the factory defaults for the maximum output and button table sizes
(function() {
    function fill(d) {
        for (var i = 1 ; i <= MaxButtons ; ++i) {
            if (!(i in d.buttons)) {
                d.buttons[i] = { pin: "NC", keytype: 0, keycode: 0, flags: 0 };
            }
        }
        for (var i = 1 ; i <= MaxOutputs ; ++i) {
            if (!(i in d.outputs)) {
                d.outputs[i] = { port: { type: 0, pin: 0 } };
            }
        }
    }
    fill(expansionBoardFactoryConfig);
    fill(standaloneFactoryConfig);
})();
    
// Output Port Aliases.  This is a table of port name aliases for
// expansion boards.  With the base configuration, we show output
// port names in raw hardware terms - i.e., the physical pins on
// the KL25Z or peripheral chips such as TLC5940's.  When an expansion
// board is used, the user does all of the wiring through the board
// headers, so we substitute the header pin locations in our displays.
// This table maps from hardware pins to the alias strings.  The keys
// are strings in the form "type.pin", where 'type' is the pin type
// number used in the USB setup messages (1 for KL25Z PWM GPIO, etc)
// and 'pin' is the internal pin name ("PTxx" for GPIO ports, or a
// port number from 0 to N for peripheral chips).
//
// Format of each entry:
//
//   Descriptive name|Output type description|Board name|JPx-y|xxxxOutputSelector
//
var outPortAlias = { };

// GPIO Port Aliases.  This is similar to the outPortAlias table,
// but covers only GPIO ports (no peripheral ports), and covers all
// GPIO ports used for any purpose, including inputs, outputs, and
// control connections to peripherals.
//
// Format:
//
//   Descriptive name|JPx-y or Internal
//
var gpioPortAlias = { };

// build the expansion board out port alias table
var expOutPortAlias, expGpioPortAlias;
(function()
{
    var o = {
        "3.15":   "Strobe|PWM Mid Power|Main Board|JP9-2|mainBoardPWMOutputSelector",

        "3.0":    "Flasher 1R|PWM Mid Power|Main Board|JP11-2|mainBoardPWMOutputSelector",
        "3.1":    "Flasher 1G|PWM Mid Power|Main Board|JP11-4|mainBoardPWMOutputSelector",
        "3.2":    "Flasher 1B|PWM Mid Power|Main Board|JP11-6|mainBoardPWMOutputSelector",
        "3.3":    "Flasher 2R|PWM Mid Power|Main Board|JP11-8|mainBoardPWMOutputSelector",
        "3.4":    "Flasher 2G|PWM Mid Power|Main Board|JP11-10|mainBoardPWMOutputSelector",
        "3.5":    "Flasher 2B|PWM Mid Power|Main Board|JP11-12|mainBoardPWMOutputSelector",
        "3.6":    "Flasher 3R|PWM Mid Power|Main Board|JP11-14|mainBoardPWMOutputSelector",
        "3.7":    "Flasher 3G|PWM Mid Power|Main Board|JP11-16|mainBoardPWMOutputSelector",
        "3.8":    "Flasher 3B|PWM Mid Power|Main Board|JP11-1|mainBoardPWMOutputSelector",
        "3.9":    "Flasher 4R|PWM Mid Power|Main Board|JP11-3|mainBoardPWMOutputSelector",
        "3.10":   "Flasher 4G|PWM Mid Power|Main Board|JP11-5|mainBoardPWMOutputSelector",
        "3.11":   "Flasher 4B|PWM Mid Power|Main Board|JP11-7|mainBoardPWMOutputSelector",
        "3.12":   "Flasher 5R|PWM Mid Power|Main Board|JP11-9|mainBoardPWMOutputSelector",
        "3.13":   "Flasher 5G|PWM Mid Power|Main Board|JP11-11|mainBoardPWMOutputSelector",
        "3.14":   "Flasher 5B|PWM Mid Power|Main Board|JP11-13|mainBoardPWMOutputSelector",

        "3.16":   "LED 1R|PWM Low Power|Main Board|JP8-1|mainBoardPWMOutputSelector",
        "3.17":   "LED 1G|PWM Low Power|Main Board|JP8-3|mainBoardPWMOutputSelector",
        "3.18":   "LED 1B|PWM Low Power|Main Board|JP8-5|mainBoardPWMOutputSelector",
        "3.19":   "LED 2R|PWM Low Power|Main Board|JP8-7|mainBoardPWMOutputSelector",
        "3.20":   "LED 2G|PWM Low Power|Main Board|JP8-9|mainBoardPWMOutputSelector",
        "3.21":   "LED 2B|PWM Low Power|Main Board|JP8-11|mainBoardPWMOutputSelector",
        "3.22":   "LED 3R|PWM Low Power|Main Board|JP8-2|mainBoardPWMOutputSelector",
        "3.23":   "LED 3G|PWM Low Power|Main Board|JP8-4|mainBoardPWMOutputSelector",
        "3.24":   "LED 3B|PWM Low Power|Main Board|JP8-6|mainBoardPWMOutputSelector",
        "3.25":   "LED 4R|PWM Low Power|Main Board|JP8-8|mainBoardPWMOutputSelector",
        "3.26":   "LED 4G|PWM Low Power|Main Board|JP8-10|mainBoardPWMOutputSelector",
        "3.27":   "LED 4B|PWM Low Power|Main Board|JP8-12|mainBoardPWMOutputSelector",
        "3.28":   "LED 5R|PWM Low Power|Main Board|JP8-13|mainBoardPWMOutputSelector",
        "3.29":   "LED 5G|PWM Low Power|Main Board|JP8-15|mainBoardPWMOutputSelector",
        "3.30":   "LED 5B|PWM Low Power|Main Board|JP8-17|mainBoardPWMOutputSelector",
        "3.31":   "LED 6|PWM Low Power|Main Board|JP8-14|mainBoardPWMOutputSelector"
    };

    // add four power boards worth of outputs
    for (var i = 0 ; i < 128 ; ++i) {
        o["3." + (i+32)] =
            "Output " + ((i%32) + 1)
            + "|PWM Hi Power"
            + "|Power Board " + (Math.floor(i/32) + 1)
            + "|JP" + (Math.floor((i%32)/16)+5)+ "-" + ((i%16)+1)
            + "|powerBoardOutputSelector";
    }

    // add four chime boards worth of outputs
    for (i = 0 ; i < 32 ; ++i) {
        o["4." + i] =
            "Output " + ((i%8) + 1)
            + "|Timed Digital"
            + "|Chime Board " + (Math.floor(i/8) + 1)
            + "|JP9-" + ((i%8)+1)
            + "|chimeBoardOutputSelector";
    }

    // Table of all internal GPIO connections on the main expansion board.
    // These generally can't be used for any other purpose.
    var gInternal = {
        "PTC10":  "TLC5940 XLAT",
        "PTC6":   "TLC5940 SIN",
        "PTC5":   "TLC5940 SCLK",
        "PTC7":   "TLC5940 BLANK",
        "PTA1":   "TLC5940 GSCLK",
        "PTC9":   "IR OUT",
        "PTA13":  "IR IN",
        "PTD2":   "PSU2 STATUS",
        "PTD3":   "TV RELAY",
        "PTE0":   "PSU2 LATCH"
    };

    // Table of all external GPIO connections on the main expansion
    // board.  These KL25Z pins are connected more or less directly
    // to external headers on the board, so they can be re-purposed
    // (sometimes with restrictions) for other external uses.  For
    // example, if a plunger sensor isn't being used, all of the
    // plunger input pins can be used as button inputs instead.
    var gExternal = {
        "PTB0":   "Plunger 1|JP2-1",
        "PTE23":  "Cal Button LED|JP3-2",
        "PTE29":  "Cal Button Switch|JP3-1",
        "PTE22":  "Plunger 4|JP2-4",
        "PTD5":   "Plunger 4|JP2-4",
        "PTE21":  "Plunger 3|JP2-3",
        "PTD0":   "Plunger 3|JP2-3",
        "PTE20":  "Plunger 2|JP2-8",
        "PTD4":   "74HC595 ENA|JP5-7",
        "PTA4":   "74HC595 SCLK|JP5-3",
        "PTA5":   "74HC595 SOUT|JP5-1",
        "PTA12":  "74HC595 LATCH|JP5-5",
        "PTC8":   "Knocker|JP9-1|Timed Digital",
        "PTC4":   "Extender 1|JP12-1",
        "PTC3":   "Extender 2|JP12-2",
        "PTC0":   "Extender 3|JP12-3",
        "PTA2":   "Extender 4|JP12-4",
    };

    // Build a combined table of the GPIO port aliases for internal and
    // external main board connections.
    var g = { };
    $.each(gInternal, function(k, v) { g[k] = v + "|Internal"; });
    $.each(gExternal, function(k, v) { g[k] = v.split("|").slice(0, 2).join("|"); });

    // Add GPIO aliases for all of the buttons
    $.each(expansionBoardFactoryConfig.buttons, function(k, v) {
        g[v.pin] = "Button " + k + "|Digital In|Main Board|JP1-" + k + "|mainBoardInputSelector";
    });

    // Add all of the external ports as output aliases.
    $.each(gExternal, function(k, v)
    {
        // break v into fields - Descriptive Name, Jumper, [output type description]
        v = v.split("|");

        // if it's a PWM-capable port, add a PWM output type for it
        var gp = gpioPinsByName[k] || { };
        if (gp.pwm)
            o["1." + k] = [v[0], v[2] || "PWM GPIO", "Main Board", v[1], "mainBoardPWMOutputSelector"].join("|");

        // add a Digital Out type for it
        o["2." + k] = [v[0], v[2] || "Digital GPIO", "Main Board", v[1], "mainBoardDigitalOutputSelector"].join("|");
    });

    // remember these
    expOutPortAlias = o;
    expGpioPortAlias = g;
})();

$("input:radio[name=hardwareType]").change(function(ev)
{
    // check which hardware configuration is now selected
    var d = $("#expansionBoardOptions");
    var v = $("input:radio[name=hardwareType]:checked").val();
    var fromUI = !!ev.originalEvent;

    // show or hide sub-option sections as appropriate
    slideToggle(d, v == 1, 250, fromUI);        // type 1 = expansion boards

    // set up defaults for the new configuration
    switch (+v)
    {
    case 1:
        // Pinscape Expansion Boards, first release

        // use the expansion board output port aliases
        outPortAlias = expOutPortAlias;
        gpioPortAlias = expGpioPortAlias;

        // if the selection was made from the UI, apply the factory defaults
        if (fromUI)
            configToUI(expansionBoardFactoryConfig, expansionBoardFactoryXConfig, ConfigSource.Factory);

        // hide KL25Z pin assignments by default
        $("#ckExpBoardShowPins").prop("checked", false);
        break;

    default:
        // plain KL25Z or unknown

        // use hardware pin names for the output ports (no board aliases)
        outPortAlias = { };
        gpioPortAlias = { };

        // set factory defaults if the change came from the UI
        if (fromUI)
            configToUI(standaloneFactoryConfig, standaloneFactoryXConfig, ConfigSource.Factory);
        break;
    }

    // show/hide items globally according to the type
    $(".expBoardOnly").css("display", v == 1 ? "" : "none");
    $(".expBoardExclude").css("display", v == 1 ? "none" : "");

    // note the new type
    prvHardwareType = v;

    // update pin displays - this shows the pin selectors in standalone
    // mode, and hides them in expansion board mode, except when the "show
    // pins anyway" box is checked
    updatePinVisibility();

    // If the change came from a UI event, reset plunger pin assignments
    // for the new factory defaults.  Pass -1 for the previous type, since
    // the previous type is irrelevant: it's the pin wiring that's changing,
    // not the plunger type, so we need to reassign the pins no matter what
    // type is selected.
    if (fromUI)
        setPlungerPinFactoryDefaults(-1);

    // update pin warnings
    updatePinWarnings();
    
});

// "Show pin assignments" box - expansion board option.  By default, when
// this box is not checked and the expansion board configuration is active.
// All .expBoardPin elements are hidden - these are elements containing
// selectors for KL25Z pins wired to specific functions on the expansion
// boards.  .expBoardAlt elements are the converse - these show alternative
// text in expansion board mode, which can be used to fill in gaps left
// when the pin selections are missing.
$("#ckExpBoardShowPins").change(function() { updatePinVisibility(); });

function updatePinVisibility()
{
    // get the hardware mode
    switch (+$("input:radio[name=hardwareType]:checked").val())
    {
    case 0:
    default:
        // standalone mode/unknown - show pin selectors, hide special
        // expansion board alternate text
        $(".expBoardPin").show();
        $(".expBoardAlt").hide();
        break;

    case 1:
        // expansion board mode - show the expansion board alternate text,
        // and hide the regular pin selectors, *unless* the "show pins anyway"
        // box is checked
        $(".expBoardPin").toggle(!!$("#ckExpBoardShowPins").prop("checked"));
        $(".expBoardAlt").show();
        break;
    }
}

$("#numMainBoards,#numPowerBoards,#numChimeBoards").change(function()
{
    // make sure we have a valid number
    var v = $(this).val().trim();
    if (!/^\d+$/.test(v))
        $(this).val($(this).data("oldVal"));

    // adjust the peripheral chip configuration
    expBoardAdjustChips();
});

// adjust the number of peripheral chips to match the expansion board setup
function expBoardAdjustChips()
{
    // adjust the TLC5940 count: 2 per main board + 2 per power board
    $("#tlc_nchips").val(2*$("#numMainBoards").val() + 2*$("#numPowerBoards").val()).change();

    // adjust the 74HC595 count: 1 per chime board
    $("#hc595_nchips").val($("#numChimeBoards").val()).change();
}

      </script>

   <!--  USB ID  ------------------------------------------------------------->
   <hr>
   <div class="section" data-name="USB ID">
      <div>
         <img src="usbident.png" class="sectionIcon">
         <b>USB Identification.</b>  This is how the KL25Z identifies itself to
         Windows through the USB port.
      </div>

      <div>
         <select id="popUsbID" style="margin-right: 2em;">
            <option value="FAFA00F0">LedWiz Unit 1</option>
            <option value="FAFA00F1">LedWiz Unit 2</option>
            <option value="FAFA00F2">LedWiz Unit 3</option>
            <option value="FAFA00F3">LedWiz Unit 4</option>
            <option value="FAFA00F4">LedWiz Unit 5</option>
            <option value="FAFA00F5">LedWiz Unit 6</option>
            <option value="FAFA00F6">LedWiz Unit 7</option>
            <option value="FAFA00F7">LedWiz Unit 8</option>
            <option value="FAFA00F8">LedWiz Unit 9</option>
            <option value="FAFA00F9">LedWiz Unit 10</option>
            <option value="FAFA00FA">LedWiz Unit 11</option>
            <option value="FAFA00FB">LedWiz Unit 12</option>
            <option value="FAFA00FC">LedWiz Unit 13</option>
            <option value="FAFA00FD">LedWiz Unit 14</option>
            <option value="FAFA00FE">LedWiz Unit 15</option>
            <option value="FAFA00FF">LedWiz Unit 16</option>
            <option value="1209EAEA">Pinscape ID</option>
            <option value="00000000">Custom</option>
         </select>

         <span id="usbCustomFields">
            Vendor ID: <input type="text" size=4 id="txtUsbVendor">
            Product ID: <input type="text" size=4 id="txtUsbProduct">
         </span>
         <span id="usbInfoFields">
         </span>

      </div>

      <div>
         <ul>
            <li>If you have a <b>real</b> LedWiz unit in your
            system, choose <b>LedWiz Unit 8</b> for your first Pinscape
            unit, 9 for the second, etc.

            <li>If you <b>don't</b> have any real LedWiz units, choose
            <b>LedWiz Unit 1</b> for the first unit, 2 for the second, etc.
         </ul>

         <a href="#" class="shower">I want more details!</a>
         <div class="hider">
            <ul>
               <li><b>For LedWiz compatibility</b>, choose an LedWiz unit number.
               LedWiz compatibility lets older programs, like Future Pinball, 
               control outputs through this Pinscape unit.

               <li>LedWiz unit numbers <b>must be unique</b>.
               Be sure to choose an ID that isn't used by your real LedWiz, or by another
               Pinscape controller.
               Programs on the PC use the unit number to tell the devices apart, so each
               device needs a different number.

               <li>If the LedWiz IDs cause conflicts on your system with other USb devices,
               you can try the Pinscape ID.  This ID is registered uniquely to
               Pinscape, so it shouldn't conflict with anything.
               However, <b>using this ID will give up LedWiz compatibility.</b>  This
               means that older software like Future Pinball won't be able to access
               the output controller features.  Newer software based on DOF R3
               (such as Visual Pinball and PinballX) <b>will</b> still be able to take
               full advantage of the output features.  The input features shouldn't
               be affected one way or the other.

               <li>The Custom ID option is only for techies doing something
               tricky.  Don't use it unless you have a good reason.  Using a
               custom ID will make the output features unreachable even from DOF.
               (The input features will still work, though.)
            </ul>
         </div>
      </div>
   </div>

   <script>
$("#popUsbID").change(function() {
    var v = $(this).val() || "";
    var vendor = v.substr(0, 4);
    var product = v.substr(4);
    $("#txtUsbVendor").val(vendor);
    $("#txtUsbProduct").val(product);

    // fill in the info fields
    $("#usbInfoFields").text("(USB Vendor ID " + vendor + ", Product " + product + ")");

    // show the custom ID fields if and only if the custom item is selected
    var custom = ($("#popUsbID option:selected").text() == "Custom");
    $("#usbCustomFields").css("display", custom ? "inline" : "none");
    $("#usbInfoFields").css("display", custom ? "none" : "inline");
});
$("#txtUsbVendor, #txtUsbProduct").change(function() {
    // normalize the updated value by parsing it as a hex number and then
    // formatting back into our standard format
    $(this).val(hex4(parseInt($(this).val(), 16)));

    // set the popup value
    var pop = $("#popUsbID");
    var newval = $("#txtUsbVendor").val() + $("#txtUsbProduct").val();
    ensureUsbId(newval);
    pop.val(newval).change();
});

// ensure that a USB ID is in the popup list, setting the "custom" entry if required
function ensureUsbId(val)
{
    // search the list
    var found = false;
    var pop = $("#popUsbID");
    pop.children().each(function() {
        if ($(this).val() == val) {
            found = true;
            return false;
        }
    });

    // if we didn't find it, set the custom element to the new value
    if (!found)
        pop.children().last().val(val);
}

   </script>

   <!-- Pinscape ID  ------------------------------------------------------->
   <hr>
   <div class="section" data-name="Pinscape ID">
      <img src="pinscapeID.png" class="sectionIcon">
      <b>Pinscape ID.</b>  This is a <b>separate</b> ID from the LedWiz
      unit number.  DOF R3 and the <a class="dofconfigtool">
         DOF Config Tool</a> use this ID to identify the unit.
      <b>Set this to 1 for your first unit, 2 for the second</b>, and so on.
      <p>
      This is completely unrelated to the LedWiz unit number, so it doesn't need
      to match that, and by the same token doesn't need to be different.  This
      doesn't affect the USB ID or the Windows device drivers.  It's purely for
      DOF and other Pinscape-aware software.
      </p>

      <div>
         <select id="popPinscapeID" style="margin-right: 2em;">
            <option value="1">Pinscape Unit 1</option>
            <option value="2">Pinscape Unit 2</option>
            <option value="3">Pinscape Unit 3</option>
            <option value="4">Pinscape Unit 4</option>
            <option value="5">Pinscape Unit 5</option>
            <option value="6">Pinscape Unit 6</option>
            <option value="7">Pinscape Unit 7</option>
            <option value="8">Pinscape Unit 8</option>
            <option value="9">Pinscape Unit 9</option>
            <option value="10">Pinscape Unit 10</option>
            <option value="11">Pinscape Unit 11</option>
            <option value="12">Pinscape Unit 12</option>
            <option value="13">Pinscape Unit 13</option>
            <option value="14">Pinscape Unit 14</option>
            <option value="15">Pinscape Unit 15</option>
            <option value="16">Pinscape Unit 16</option>
         </select>
      </div>

   </div>


   <!-- reboot on disconnect ----------------------------------------------->
   <hr>
   <div class="section" data-name="Disconnect Reset">
      <img src="disconnect.png" class="sectionIcon">
      <b>Reset on disconnect.</b>  If the USB connection is broken, and
      can't be re-established within a time limit, the KL25Z can
      automatically reset itself as an attempt to fix whatever's wrong.
      Select the time interval (in seconds) before this happens.

      <div>
         <label><input type="checkbox" id="ckRebootEnable">Enabled</label>
         <div id="rebootOptions">       
            Time before reboot (seconds):
            <input type="text" id="txtRebootTime" size=4 style="margin-left: 1em;">
         </div>
      </div>

      <div>
         <a href="#" class="shower">Details</a>
         <div class="hider">
            <b>Details</b><br>
            On some systems, the KL25Z has trouble re-establishing a broken
            USB connection, such as after rebooting or power-cycling the PC.
            This can usually be solved by resetting the KL25Z.  If you set
            this option, the KL25Z will reset itself automatically when it
            detects a broken connection and can't reconnect within the specified
            time limit.  The delay is there to avoid unnecessary resets when
            the connection only glitches momentarily.  The recommended setting
            is 10 seconds.
         </div>
      </div>
   </div>

   <script>
$("#ckRebootEnable").change(function(ev) {
    var show = $(this).prop("checked");
    slideToggle($("#rebootOptions"), show, 250, !!ev.originalEvent);
    if (show && $("#txtRebootTime").val() == 0)
        $("#txtRebootTime").val(10);
});

$("#txtRebootTime").change(function() {
    var val = $(this).val().trim();
    if (!/^\d+$/.test(val))
        $(this).val(+config.disconnectRebootTime);
    else if (+val < 1 && $("#ckRebootEnable").prop("checked"))
        $(this).val(1);
    else if (+val < 0)
        $(this).val(0);
    else if (+val > 255)
        $(this).val(255);
    else if (val != +val)
        $(this).val(+val);
});
   </script>


   <!-- TV On button ------------------------------------------------------->
   <a name="TVON"></a>
   <hr>
   <div class="section" data-name="TV ON">
      <img src="tvon.png" class="sectionIcon">
      <b>TV ON switch.</b>  If one or more of your monitors needs to be turned
      on manually every time you power up your cabinet, you can use this feature
      to switch them on automatically.  See the Build Guide for wiring instructions.

      <div>
         <div>
            <label><input id="tvOnEnabled" type="checkbox">Enabled</label>
            <span style="margin-left: 2em;" id="tvOnTestButton">
               <a href="#" id="btnTvOnTest" class="button">Test</a>
            </span>
         </div>
         <div id="tvOnPins">
            <table class="inputs">
               <tr class="expBoardPin">
                  <td class="pinlabel">Power status input:</td>
                  <td>
                     <span class="pinselect" id="tvStatus"
                       data-cfg="TVon.statusPin" data-gpiotype="dig-in extern"
                       data-desc="TV ON Power Status Input" data-default="PTD2">
                     </span>
                  </td>
               </tr>
               <tr class="expBoardPin">
                  <td class="pinlabel">Status latch output:</td>
                  <td>
                     <span class="pinselect" id="tvLatch"
                       data-cfg="TVon.latchPin" data-gpiotype="dig-out extern"
                       data-desc="TV ON Status Latch" data-default="PTE0">
                     </span>
                  </td>
               </tr>
               <tr class="expBoardPin">
                  <td class="pinlabel">Relay output:</td>
                  <td>
                     <span class="pinselect" id="tvRelay"
                       data-cfg="TVon.relayPin" data-gpiotype="dig-out extern"
                       data-desc="TV ON Relay Output" data-default="PTD3">
                     </span>
                  </td>
               </tr>
               <tr>
                  <td>Startup delay time (seconds):</td>
                  <td><input type="text" id="tvDelay" size=4></td>
                  <td style="padding-left: 2em;">This is how long to wait after power-on before pulsing the relay</td>
               </tr>
            </table>
         </div>
      </div>
   </div>

   <script>

var oldTVOn = { };
$("#tvOnEnabled").click(function(ev) 
{
    // if we're disabling it, set the pins to NC, but save the
    // current values first in case the user re-enables it
    var ena = $(this).prop("checked");
    if (!ena)
    {
        function saveAndClear(id) { 
            oldTVOn[id] = $(id).val(); 
            $(id).val("Not Connected");
        }
        saveAndClear("#tvStatus .pinval");
        saveAndClear("#tvLatch .pinval");
        saveAndClear("#tvRelay .pinval");
    }

    // show or hide the pin assignment fields
    showTvOn(ena, true, ena);
});
$("#tvStatus, #tvLatch, #tvRelay").change(function()
{
    // if any of these are set, enable the whole feature
    var ena = $("#tvStatus .pinval").val() != "Not Connected"
              || $("#tvLatch .pinval").val() != "Not Connected";

    // If we're newly enabling it, show the details section.
    // Don't hide the section on disabling, though, since the
    // user might only be making a temporary change.
    var ck = $("#tvOnEnabled");
    if (ena && !ck.prop("checked"))
        showTvOn(true, false, false);

    // if we're loading the config, hide the section initially
    // no pins are enabled
    if (loadingConfig && !ena)
        showTvOn(false, false, false);

    // bring the checkbox into alignment with the settings
    ck.prop("checked", ena);
});

function showTvOn(show, scroll, setDefs)
{
    // show the pin selectors
    slideToggle($("#tvOnPins"), show, 250, scroll);
    $("#tvOnTestButton").toggle(show);
    $("#tvOnPins .pinselect").data("active", show);

    // set defaults if desired
    if (setDefs)
    {
        function def(id, def) {
            var ctl = $(id);
            if (ctl.val() == "Not Connected")
                ctl.val(oldTVOn[id] || def).change();
        }
        def("#tvStatus .pinval", "PTD2");
        def("#tvLatch .pinval",  "PTE0");
        def("#tvRelay .pinval", "PTD3");
    }

    // update pin warnings
    updatePinWarnings();
}

$("#btnTvOnTest").click(function(ev)
{
    // don't open the link
    ev.preventDefault();

    // check for pin changes
    function pin(sel) { var p = $(sel).val(); return p == "Not Connected" ? "NC" : p; }
    if (pin("#tvStatus .pinval") != config.TVon.statusPin
        || pin("#tvLatch .pinval") != config.TVon.latchPin
        || pin("#tvRelay .pinval") != config.TVon.relayPin)
    {
        if (!window.external.YesNoDialog(
            "You've made changes to the TV ON setup that you haven't "
            + "programmed into the KL25Z yet. The tester window will reflect "
            + "the current device settings, not your new unsaved changes. "
            + "If you want to test your new settings, click \"Program KL25Z\" "
            + "before proceeding to the tester window."
            + "\r\n\r\n"
            + "Do you want to open the tester anyway?"))
            return;
    }

    // show the dialog
    window.external.ShowTvOnTester(CPUID);
});
   </script>


   <!-- IR Remote Control -------------------------------------------------->
   <hr>
   <div class="section" data-name="IR Remote">
      <img src="irRemote.png" class="sectionIcon">
      <b>IR Remote Control.</b>  The controller can send and/or receive IR
      remote control signals if you attach some additional components.  This
      can be used with the <a href="#TVON">TV ON</a> feature to turn
      your cabinet TVs on via IR commands at system startup.  See the Build
      Guide for details on the components required and how to connect them.
      If you don't have any IR components attached or wish to disable them,
      simply set the pin assignments here to "Not Connected".

      <div id="irRemotePins">
         <table class="inputs">
            <tr class="expBoardPin">
               <td class="pinlabel">IR LED (transmitter) pin:</td>
                  <td>
                     <span class="pinselect" id="irTransmitter"
                       data-cfg="IRRemote.ledPin" data-gpiotype="pwm tpm extern"
                       data-desc="IR LED transmitter output pin" data-default="PTC9">
                     </span>
                  </td>
                  <td>
                     Requires a PWM-capable pin
                  </td>
               </tr>
               <tr class="expBoardPin">
                  <td class="pinlabel">IR receiver input pin:</td>
                  <td>
                     <span class="pinselect" id="irReceiver"
                       data-cfg="IRRemote.sensorPin" data-gpiotype="interrupt-in extern"
                       data-desc="IR remote control receiver input pin" data-default="PTA13">
                     </span>
                  </td>
                  <td>
                     Requires an interrupt-capable pin
                  </td>
               </tr>
            </table>
      </div>
      <div id="noIrRemotePins" style="display:none;">
         The firmware version installed on your device doesn't support the IR
         remote features.  Update to the latest firmware to enable these features.
      </div>

      <div id="irCommands">
         <b>IR Command List.</b>  You can program the Pinscape unit with remote
         control commands that it can then send and receive.  Each slot below
         stores one code.  <a href="#" id="helpIR">Help</a>
         <div>
            <table id="irCommandTab">
            </table>
         </div>
         <div id="irCommandTabStretchNote">
            <i><b>Note:</b> your current firmware version can store up to
            <span id="irCommandTabMaxNote">0</span> codes. The list above
            will automatically expand as you fill in new rows, up to the
            limit.</i>
         </div>
      </div>

   </div>

   <script type="text/javascript">

$("#helpIR").click(function(ev) {
    ev.preventDefault();
    window.external.ShowHelp("HelpIR.htm");
});

// Update the IR receiver and sender command pins.  The IR command
// table is only shown if we have at least one of these enabled.
$("#irTransmitter, #irReceiver").change(function() {
    var ena = $("#irTransmitter").children(".pinval").val() != "Not Connected"
              || $("#irReceiver").children(".pinval").val() != "Not Connected";
    slideToggle($("#irCommands"), ena, loadingConfig ? 0 : 250, false);
});

// Show the IR command selectors on the button inputs and the IR
// test buttons on the code slots only if we have an IR transmitter
// configured.
$("#irTransmitter").change(function() {
    var ena = $("#irTransmitter").children(".pinval").val() != "Not Connected";
    $("#buttonTab .keyIR, #irCommands .irTest").toggle(ena);
});

// Show the IR learn buttons on the code slots only if we have an
// IR receiver configured.
$("#irReceiver").change(function() {
    var ena = $("#irReceiver").children(".pinval").val() != "Not Connected";
    $("#irCommands .irLearn").toggle(ena);
});


// Build the IR command table rows using the number of slots in the
// firmware config.  This is a fixed maximum in the firmware, so it's
// only necessary to do this once when first loading the config.
var irCommandTabMax = 0;
function sizeIRCommandTab(config)
{
    // we only have to do this once per load
    if (irCommandTabMax)
        return false;
    
    // figure the table size
    var count = 0;
    $.each(config.IRCode1, function(key) { if (/\d+/.test(key)) ++count; });

    // remember it globally and set the note
    $("#irCommandTabMaxNote").html(irCommandTabMax = count);

    // build the table
    var tab = $("#irCommandTab");
    tab.html("<tr><th>#</th><th>IR Code</th><th></th><th>TV ON</th><th>Key</th><th>Description</th></tr>");
    for (var i = 1 ; i <= count ; ++i)
    {
        var row =
            "<tr class=\"irCommandRow buttonRow\" data-irrow=\"" + i + "\">"
            + "<td>" + i + "</td>"
            + "<td class=\"irCode\">"
            +   "<input type=\"text\" size=\"22\">"
            +   "<input type=\"hidden\" class=\"irFlags\">"
            +   "<input type=\"hidden\" class=\"irProtocol\">"
            +   "<input type=\"hidden\" class=\"irCodeLo\">"
            +   "<input type=\"hidden\" class=\"irCodeHi\">"
            + "</td>"
            + "<td class=\"irCodeCtls\">"
            +   "<span class=\"irLearn\" title=\"Learn a code from a remote control\"></span>"
            +   "<span class=\"irTest\" title=\"Test sending this code\"></span>"
            + "</td>"
            + "<td>"
            +   "<span class=\"irTVON\" title=\"Send this command at system startup to turn on your cabinet TVs\">"
            +   "</span>"
            + "</td>"
            + "<td>"
            +   "<span class=\"keymappingContainer\">"
            +     "<span class=\"keymapping\" id=\"keymapIR" + i + "\">"
            +       "<span class=\"keyname\"></span>"
            +       "<span class=\"keycode\"></span>"
            +       "<span class=\"keytype\"></span>"
            +     "</span>"
            +   "</span>"
            + "</td>"
            + "<td><input class=\"irDesc\" type=\"text\" size=20\"></td>"
            + "</tr>";
        tab.append($(row));
    }

    // schedule all rows for refresh when we're idle
    $("#irCommandTab .keymapping .keycode, #irCommandTab .keymapping .keytype").change(function(ev) {
        IRTabUpdate.touch($(this));
    });

    // set the hidden code component field change handlers
    $("#irCommandTab .irCode input:hidden").change(function() {
        IRTabUpdate.touch($(this));
    });

    // set the key and 'change' handler for typing in a code
    $("#irCommandTab .irCode input:text").keydown(function(ev)
    {
        switch (ev.keyCode)
        {
        case 13:
        case 10:
            // on Enter/Return, apply the change
            $(this).change();
            break;
            
        case 27:
            // on Escape, revert to the old code
            IRTabUpdate.touch($(this));
            break;
        }
    }).change(function()
    {
        // get the row
        var self = $(this);
        var td = self.parent();

        // parse the value
        self.removeClass("error").attr("title", "IR Code: Protocol.Flags.64BitCode as hex digits");
        var val = self.val();
        var protocol, flags, codeLo, codeHi;
        if (/^\s*$/.test(val))
        {
            // empty - set all fields to zero
            protocol = flags = codeHi = codeLo = 0;
        }
        else if (/^\s*([0-9a-f]{1,2})\s*\.\s*([0-9a-f]{1,2})\s*\.\s*([0-9a-f]{1,16})\s*$/i.test(val))
        {
            // valid format - pull out the components and set the new code value
            protocol = parseInt(RegExp.$1, 16);
            flags = parseInt(RegExp.$2, 16);
            var code = RegExp.$3;

            // break the code into two 8-character hex parts for high and low
            code = zeroPad(code, 16);
            codeHi = parseInt(code.substr(0, 8), 16);
            codeLo = parseInt(code.substr(8, 8), 16); 

            // if the protocol if 0, it means "empty"; normalize all fields to zero
            if (protocol == 0)
                flags = codeHi = codeLo = 0;

        }
        else
        {
            // invalid format - mark it as an error
            self.addClass("error").attr("title", "Incorrect format: use Protocol.Flags.64BitCode, as "
                                        + "hex digits. Press Escape to revert to the previous value.");
            return;
        }

        // set the component fields
        td.children(".irProtocol").val(protocol);
        td.children(".irCodeHi").val(codeHi);
        td.children(".irCodeLo").val(codeLo);

        // The Flags field combines bit flags represented numerically in
        // the code, plus flags represented as buttons:
        //
        //   0x01  -> TV ON, represented via the TV ON button
        //   0x02  -> "ditto" protocol mode, represented in the numeric flags
        //
        // When applying the numeric value, then, we only want to change the
        // bits that are actually represented in the field, and keep the
        // separate button flags unchanged.
        var f = td.children(".irFlags");
        var nonNumFlags = 0x01;
        f.val((+f.val() & nonNumFlags) | (flags & ~nonNumFlags));

        // schedule an update
        IRTabUpdate.touch(td);
    });

    // set the key-mapping handler
    $("#irCommandTab .keymapping").click(keymappingClick);

    // set the code input handler
    $("#irCommandTab .irCode input:hidden").change(function(ev) {
        var self = $(this);
        IRTabUpdate.touch(self);
    });

    // set the Learn button handler
    $("#irCommandTab .irLearn").click(function(ev) {
        var code = window.external.ShowIRLearn(CPUID);
        if (code)
            $(this).parents(".irCommandRow").find(".irCode input:text").val(code).change();
    });

    // set the Test button handler
    $("#irCommandTab .irTest").click(function(ev) {
        var btn = $(this);
        var code = $(this).parents(".irCommandRow").find(".irCode input:text").val();
        showCallResult(window.external.SendIRCommand(CPUID, code), {
            "ok": function() {
                btn.addClass("sending");
                var i = 0, flash = function() {
                    btn.toggleClass("sending");
                    if (i++ < 4) setTimeout(flash, 75);
                };
                setTimeout(flash, 75);
            }
        })
    });

    // set the TV ON button handler
    $("#irCommandTab .irTVON").click(function(ev)
    {
        // get the input.irFlags element in the row
        var self = $(this);
        var inp = self.parents(".irCommandRow").find(".irCode .irFlags");

        // invert the TV ON bit (0x01) in the flags and update the row
        inp.val(+inp.val() ^ 0x01);
        IRTabUpdate.touch(self);
    });

    // tell the caller we rebuilt the table
    return true;
}

function stretchIRTable()
{
    var last = 0;
    $("#irCommandTab .irCommandRow").each(function() {
        var tr = $(this);
        var idx = +tr.data("irrow");
        if (idx > irCommandTabMax) return false;
        if (idx >= last && +tr.find(".irCode .irProtocol").val() != 0)
            last = idx;
    });

    // show one blank row if we haven't maxed out the table
    if (last < buttonTabMax) ++last;

    $("#irCommandTab .irCommandRow").each(function() {
        $(this).toggle(+$(this).data("irrow") <= last);
    });

    $("#irCommandTabStretchNote").toggle(last < buttonTabMax);
}

function zeroPad(str, len)
{
    if (str.length < len)
    {
        var cnt = len - str.length;
        var zero = "0000000000000000";
        while (zero.length < cnt) zero += zero;
        str = zero.substr(0, cnt) + str;
    }
    return str;
}

function updateIRRow(tr)
{
    // flags represented via separate controls rather than numerically:
    //   0x01 -> TV ON
    var nonNumFlags = 0x01;

    // build the code from the components
    var td = tr.children(".irCode");
    var pro = +td.children(".irProtocol").val();
    var flags = +td.children(".irFlags").val();
    var codeLo = +td.children(".irCodeLo").val();
    var codeHi = +td.children(".irCodeHi").val();
    td.children("input:text").val(
        (pro == 0 ? "" :
         pro.toString(16)
         + "." + (flags & ~nonNumFlags).toString(16)
         + "." + (codeHi != 0 ? codeHi.toString(16) + zeroPad(codeLo.toString(16), 8) : codeLo.toString(16))
        ).toUpperCase()
    );

    // update the TV ON button from bit 0x01 in the flags
    tr.find(".irTVON").toggleClass("active", (flags & 0x01) != 0);

    // update the key cap
    updateKeyCap(tr.find(".keymapping"));
}

var IRTabUpdate = {
    touch: function(item) {  // item can be a button row element (TR) or any element within a row
        if (!item.is("tr"))
            item = item.parents("tr.irCommandRow");
        this.pending[item.data("irrow")] = item;
        if (!this.queued) {
            var self = this;
            setTimeout(function() { self.go(); }, 1);
            this.queued = true;
        }
    },
    pending: { },
    queued: false,
    go: function() {
        $.each(this.pending, function(key, val) {
            updateIRRow(val);
        });
        stretchIRTable();
        this.queued = false;
        this.pending = { };
    }
};

// prepare the IR command selector popup
function prepIRCommandSelector(curSelIdx, clickFunc)
{
    // start with the "none" row
    var lst = [];
    var ck = function(idx) {
        return "<span class='IRCheck'>"
            + (idx == curSelIdx ? "&#10004;" : "")
            + "</span>";
    };
    lst.push("<div data-idx='0'>"
             + ck(0)
             + "(No IR Command)"
             + "</div>");

    // build the list of commands
    $("#irCommandTab .irCommandRow").each(function() {
        var tr = $(this);
        var idx = +tr.data("irrow");
        if (idx <= irCommandTabMax && +tr.find(".irCode .irProtocol").val() != 0)
        {
            lst.push("<div data-idx=\"" + idx + "\">"
                     + ck(idx)
                     + "<span class='IRIdx'>#" + idx + ":</span>"
                     + "<span class='IRCode'>" + tr.find(".irCode input:text").val() + "</span>"
                     + "<span class='IRDesc'>" + tr.find(".irDesc").val() + "</span>"
                     + "</div>");
        }
    });

    // populate the command selector
    $("#IRCommandList").html(lst.join(""));

    // assign the click function to each row
    $("#IRCommandList > div").click(clickFunc);

    // return the number of command rows (excluding the "none" row)
    return lst.length - 1;
}
      
   </script>

   <!-- joystick enable ---------------------------------------------------->
   <hr>
   <div class="section" data-name="Joystick">
      <img src="joystick.png" class="sectionIcon">
      <b>Joystick input.</b>  The controller acts like a Windows USB Joystick
      in order to send the plunger position, accelerometer readings (for nudging),
      and button inputs to the PC.  You can disable these inputs if desired.

      <div>
         <label><input id="ckJoystick" type="checkbox"> Enable joystick input</label>
      </div>

      <div>
         <a href="#" class="shower">Why would I want to disable this?</a>
         <div class="hider">
            <b>Why would I want to disable this?</b><br>
            By default, each Pinscape unit reports its accelerometer readings
            to the PC via the joystick interface.  If you have more than one
            unit installed, that means you'll have more than one set of these
            reports coming in.  The extra reports can confuse some pinball
            software, and can also affect system performance.  This option
            lets you disable the extra reports from the secondary units.  If
            you have a plunger attached to one of the units, you should consider
            that one to be your primary unit and leave its joystick interface
            enabled.  You should disable the joystick interface on any other units.
         </div>
      </div>

   </div>


   <!-- accelerometer settings --------------------------------------------->
   <hr>
   <div class="section" data-name="Accelerometer">
      <img src="orientation.png" class="sectionIcon">
      <b>Accelerometer orientation.</b>  If you're using the accelerometer
      (for nudge sensing), the software needs to know how the KL25Z is oriented
      in the cabinet so that it can report motion in the right direction.  Install
      the KL25Z in one of the orientations shown below, level with the floor of
      the cabinet, with the chips and LEDs facing up.

      <div>

         <table class="radio">
            <tr style="margin: auto;">
               <td>
                  <label>
                     <img src="accel-front.png"><br>
                     <input type="radio" name="accelOrientation" value="0">
                     Ports facing front
                  </label>
               </td>
               <td>
                  <label>
                     <img src="accel-left.png"><br>
                     <input type="radio" name="accelOrientation" value="1">
                     Ports facing left
                  </label>
               </td>
               <td>
                  <label>
                     <img src="accel-right.png"><br>
                     <input type="radio" name="accelOrientation" value="2">
                     Ports facing right
                  </label>
               </td>
               <td>
                  <label>
                     <img src="accel-rear.png"><br>
                     <input type="radio" name="accelOrientation" value="3">
                     Ports facing rear
                  </label>
               </td>
            </tr>
         </table>

      </div>


      <div id="newAccelFeatures">
         <div style="margin-top: 2em;"><b>Dynamic range.</b>  Select the range for
            accelerometer readings.  Ranges above &plusmn;2G have lower precision.
            <a href="#" class="shower">Details</a>

            <div class="hider">
               <p>
                  The KL25Z accelerometer hardware has three native range settings:
                  &plusmn;2G, &plusmn;4G, and &plusmn;8G.  (A "G" is the acceleration
                  of the earth's gravity, 9.8m/s&sup2;.)  The device offers the options
                  because each is a compromise between precision and dynamic
                  range, and some applications care more about precision while others
                  care more about range.  <i>Precision</i> is the ability to discern
                  the difference between nudges that are very close together in
                  strength. <i>Dynamic range</i> is the ability to tell the difference
                  between nudges that are very far apart in strength.  In the 2G range,
                  the device has the best precision, but the tradeoff is that readings
                  are capped at 2G, so real accelerations that are higher than 2G will
                  read as 2G.  The 4G and 8G ranges increase the cap, allowing for true
                  readings up to the respective limits, but the tradeoff
                  is that they lose some of the ability to distinguish readings that
                  are very close together.
               </p>
               <p>
                  For virtual pinball use, the 1G or 2G settings are recommended,
                  because precision is more important to us than range.  It makes it
                  more realistic if the game can discern fine shadings of strength.
                  It's not as important to distinguish very high accelerations from
                  one another, since anything beyond a certain point is just a
                  TILT anyway.
               </p>
               <p>
                  1G is the default because it was the fixed setting in older versions
                  of the Pinscape firmware, before this option existed.  1G will produce
                  the same effects you're used if you had previous versions installed.
                  If you wish, you can change to 2G with no loss of precision, because
                  1G and 2G use the same native device settings.  If you do change to
                  2G, you should adjust your VP "axis gain" settings (in the keyboard
                  preferences) to compensate, by doubling the old settings.  Similarly,
                  if you decide to try 4G or 8G, double the gain settings again at 4G,
                  and yet again at 8G.
               </p>
            </div>

         <div style="margin-left: 2em; margin-top: 0ex;">
            <label><input type="radio" name="accelRange" value="0"> &plusmn;1G
             (original Pinscape setting, highest precision)</label><br>
            <label><input type="radio" name="accelRange" value="1"> &plusmn;2G
             (same precision as &plusmn;1G but with wider range)</label><br>
            <label><input type="radio" name="accelRange" value="2"> &plusmn;4G
             (reduced precision, wider range)</label><br>
            <label><input type="radio" name="accelRange" value="3"> &plusmn;8G
             (lowest precision, widest range)</label><br>
         </div>
      </div>

      <div style="margin-top: 2em;">
         <b>Auto-centering.</b>  The controller automatically zeroes the
         accelerometer after it's been sitting still for a while.  This
         compensates for any tilt in the mounting position.  If you prefer,
         you can disable the automatic centering, and center it manually
         when needed using the <a href="#" id="accJoystickLink">Joystick Viewer</a>.

         <div id="autoCenterRadioButtons">
            <div>
               <label><input type="radio" name="autoCenterMode" value="255"> Manually center only (no auto-centering)</label>
            </div>
            <div>
               <label><input type="radio" name="autoCenterMode" value="0"> Auto-center with default time (5 seconds)</label>
            </div>
            <div>
               <label><input type="radio" name="autoCenterMode" value="1"> Auto-center with custom time</label>
               <div style="margin: 1ex 2em 0px 1em;" id="accelAutoCenterTimeDiv">
                  Time in seconds: <input type="text" size="4" id="accelAutoCenterTime">
                  <span style="padding-left: 3em;"><i>1-60 seconds</i></span>
               </div>
            </div>
         </div>
      </div>
   </div>
   <div id="noNewAccelFeatures" style="display:none;">
      The firmware version installed on your device has a fixed &plusmn;1G
      dynamic range for the accelerometer, and automatic centering (zeroing)
      after being motionless for 5 seconds.  Update to the latest firmware
      if you want to customize these settings.
   </div>

   <script>
$("#accJoystickLink").click(function(ev) {
    ev.preventDefault();
    window.external.ShowJoystickViewer(CPUID);
});
$("#accelAutoCenterTime").change(function(ev) {
    var self = $(this);
    var v = self.val();
    self.toggleClass("error", v < 1 || v > 60);
});
$("#autoCenterRadioButtons input:radio[name=autoCenterMode]").change(function(ev) {
    var v = $("#autoCenterRadioButtons input:radio[name=autoCenterMode]:checked").val();
    $("#accelAutoCenterTimeDiv").toggle(v == 1);
});

   </script>



   <!-- plunger ------------------------------------------------------------>
   <hr>
   <div class="section" data-name="Plunger Sensor">
      <img src="plungerSection.png" class="sectionIcon">
      <b>Plunger sensor setup</b>

      <div>
         Sensor type:
         <select id="plungerType" style="margin-left: 1em;">
            <option value="0">None</option>
            <option value="1">TSL1410R</option>
            <option value="3">TSL1412S</option>
            <option value="5">Potentiometer</option>
            <option value="6">AEDR-8300</option>
            <!-- <option value="8">TSL1401CL</option> -->
            <option value="9">VL6180X</option>
         </select>
         <span style="margin-left: 2em;" id="plungerSensorButton">
            <a href="#" id="btnPlungerCal" class="button">Live Sensor View</a>
         </span>

      </div>

      <div id="plungerPinGroup">
         <div id="plungerPinsTSL">
            <div id="tsl1410-1412-details">
               <img style="float: right; margin: 0px 0px 1em 2em;" src="TSL1410R.jpg">
               <b><span id="TSLName">TSL14xx</span> optical sensor.</b>  This is a large
               optical sensor with the pixels arranged in a single row, about 3" long.
               We detect the plunger position by reading the image from the sensor and
               looking for the shadow cast by the plunger.  The edge of the shadow tells
               us the plunger position.
            </div>
            <div id="tsl1401-details">
               <img style="float: right; margin: 0px 0px 1em 2em;" src="TSL1401CL.jpg">
               <b>TSL1401CL bar code sensor.</b> This is a small optical sensor that we
               use to read the plunger position from a bar-coded "scale".  The scale has
               a series of tiny bar codes across its length, with each bar code representing
               its position.  As the plunger moves, the sensor slides along the scale, and
               we can read the current position by scanning the nearest bar code.  This
               requires the specially printed scale with bar codes in the format
               the software recognizes.

               <div>
                  <b>Important!  Don't confuse this with the TSL1410R.</b>  This option
                  is for the TSL14<b>01</b>CL, which is a completely different sensor
                  from the TSL14<b>10</b>R.  The two are at the opposite extremes of
                  the size scale, so they can't be used interchangeably despite the
                  confusingly similar names.  The TSL1401CL is about 8mm long, and we
                  use the small window to read a compact bar code.  The <b>other</b>
                  sensor is about 3" long, and we use to take pictures of the plunger
                  directly.  Choose <b>TSL1410R</b> instead if you're using that other,
                  larger sensor.
               </div>
            </div>
            <div class="expBoardPin">
               <b>Pin assignments:</b>
               <div class="indented">
                  <table class="inputs">
                     <tr>
                        <td class="pinlabel">SI (serial data):</td>
                        <td>
                           <span class="pinselect" id="tsl_si"
                              data-cfg="plungerPins.a" data-gpiotype="dig-out extern"
                              data-desc="Plunger Sensor SI" data-default="PTE20">
                           </span>
                        </td>
                     </tr>
                     <tr>
                        <td class="pinlabel">CLK (serial clock):</td>
                        <td>
                           <span class="pinselect" id="tsl_clk"
                              data-cfg="plungerPins.b" data-gpiotype="dig-out extern"
                              data-desc="Plunger Sensor CLK" data-default="PTE21">
                           </span>
                        </td>
                     </tr>
                     <tr>
                        <td class="pinlabel">AO (analog data):</td>
                        <td>
                           <span class="pinselect" id="tsl_ao"
                              data-cfg="plungerPins.c" data-gpiotype="adc extern"
                              data-desc="Plunger Sensor AO" data-default="PTB0">
                           </span>
                        </td>
                        <td>Requires an ADC-capable (analog in) pin</td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="expBoardAlt">
               Connect the sensor to the PLUNGER connector (JP2) on the main interface board:
               <ul>
                  <li>Sensor AO1/AO2 to pin 1
                  <li>Sensor CLK to pin 3
                  <li>Sensor VDD to pin 5
                  <li>Sensor VPP (GND) to pin 6
                  <li>Sensor SI to pin 8
               </ul>
            </div>
         </div>
         <div id="plungerPinsPot">
            <div>
               <img src="slidePot.png" style="float: right; margin: 0px 0px 1em 2em;">
               <b>Potentionmeter.</b>  This uses a slide potentiometer,
               which is a variable resistor with a control knob that moves linearly
               across the length of the device.  We attach the control knob to the
               plunger so that the two move together.  A potentionmeter's
               electrical resistance changes as the knob moves, proportionally to
               the position, so we can determine the plunger position at any given
               time by measuring the electrical resistance.
            </div>
            <div class="expBoardPin">
               <b>Pin assignments:</b>
               <div class="indented">
                  <table class="inputs">
                     <tr>
                        <td class="pinlabel">Wiper:</td>
                        <td>
                           <span class="pinselect" id="pot_ao"
                              data-cfg="plungerPins.a" data-gpiotype="adc extern"
                             data-desc="Plunger Sensor AO" data-default="PTB0">
                           </span>
                        </td>
                        <td>Requires an ADC (analog in) pin</td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="expBoardAlt">
               Connect the sensor to the PLUNGER connector (JP2) on the main interface board:
               <ul>
                  <li>Pot wiper to pin 1
                  <li>One fixed-resistor end to pin 5
                  <li>Other fixed-resistor end to pin 6
               </ul>
            </div>
            <div>
               Note: this sensor type setting can be used with other sensors
               that represents the plunger position as an analog voltage level,
               such as an LVDT or analog IR distance finder.  Connect the sensor's
               analog output pin to JP2 pin 1.  Connect sensor power to pin 5 and
               GND to pin 6.
            </div>
         </div>
         <div id="plungerPinsQuad">
            <div>
               <img src="aedr8300.png" style="float: right; margin: 0px 0px 1em 2em;">
               <b>Quadrature sensor.</b>  This uses an optical sensor that tracks its
               position along a special reflective guide rail, with bars marked at
               regular intervals.  The sensor keeps track of its position by counting
               the bars it passes as it moves.
            </div>
            <div class="expBoardPin">
               <b>Pin assignments:</b>
               <div class="indented">
                  <table class="inputs">
                     <tr>
                        <td class="pinlabel">Channel A:</td>
                        <td>
                           <span class="pinselect" id="quadrature_CHA"
                              data-cfg="plungerPins.a" data-gpiotype="interrupt-in extern"
                             data-desc="Quadrature Sensor Channel A" data-default="PTD0">
                           </span>
                        </td>
                        <td>Requires an interrupt-capable pin</td>
                     </tr>
                     <tr>
                        <td class="pinlabel">Channel B:</td>
                        <td>
                           <span class="pinselect" id="quadrature_CHB"
                             data-cfg="plungerPins.b" data-gpiotype="interrupt-in extern"
                             data-desc="Quadrature Sensor Channel B" data-default="PTD5">
                           </span>
                        </td>
                        <td>Requires an interrupt-capable pin</td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="expBoardAlt">
               Connect the sensor to the PLUNGER connector (JP2) on the main interface board:
               <ul>
                  <li>Channel A (CHA) to pin 3
                  <li>Channel B (CHB) to pin 4
                  <li>Sensor 3.3V to pin 5 (if required)
                  <li>Sensor GND to pin 6
                  <li>Sensor 5V to pin 7 (if required)
               </ul>
            </div>
         </div>
         <div id="plungerPinsVL6180X">
            <div>
               <img src="VL6180X.png" style="float: right; margin: 0px 0px 1em 2em;">
               <b>VL6180X distance sensor.</b>  This sensor determines the distance
               to a nearby object by bouncing pulses of light off the object and
               measuring how long the light takes to return, using a very precise
               clock.
            </div>
            <div class="expBoardPin">
               <b>Pin assignments:</b>
               <div class="indented">
                  <table class="inputs">
                     <tr>
                        <td class="pinlabel">SDA:</td>
                        <td>
                           <span class="pinselect" id="VL6180X_SDA"
                              data-cfg="plungerPins.a" data-gpiotype="dig-out extern"
                             data-desc="VL6180X SDA" data-default="PTE20">
                           </span>
                        </td>
                     </tr>
                     <tr>
                        <td class="pinlabel">SCL:</td>
                        <td>
                           <span class="pinselect" id="VL6180X_SCL"
                             data-cfg="plungerPins.b" data-gpiotype="dig-out extern"
                             data-desc="VL6180X SCL" data-default="PTE21">
                           </span>
                        </td>
                     </tr>
                     <tr>
                        <td class="pinlabel">GPIO0/CE:</td>
                        <td>
                           <span class="pinselect" id="VL6180X_GPIO0CE"
                             data-cfg="plungerPins.c" data-gpiotype="dig-out extern"
                             data-desc="VL6180X GPIO0/CE" data-default="PTB0">
                           </span>
                        </td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="expBoardAlt">
               Connect the sensor to the PLUNGER connector (JP2) on the main interface board:
               <ul>
                  <li>SDA to pin 8
                  <li>SCL to pin 3
                  <li>GPIO0/CE to pin 1
                  <li>Sensor VIN to pin 5
                  <li>Sensor GND to pin 6
               </ul>
            </div>
         </div>
      </div>

      <div id="plungerAutoZero">
         <b>Plunger auto-zeroing:</b> If this is enabled, the firmware will automatically
         reset the plunger position to zero after it hasn't moved for the minimum time selected.
         <a href="#" class="shower">Details</a>
         <div class="hider">
            Quadrature sensors use purely relative positioning, so they need a fixed
            starting point.  We use the plunger's "park position" (where it comes to
            rest when you're not moving it manually) as the natural zero point.  If the
            sensor ever misses any plunger motion, or if the plunger isn't at rest when
            the system is powered up, the relative position counter can get out of sync
            with reality, making the on-screen plunger a little off from the real position.
            The firmware can correct for this by automatically zeroing the on-screen
            position (setting it to exactly the park position) whenever the plunger remains
            at rest for a minimum time period.  It's usually safe to assume that the plunger
            is at the park position when it hasn't moved in a long time, since you don't
            normally hold it still anywhere else for long periods.  You only need to
            enable this if the plunger doesn't always stay in perfect sync on its own.
            Choose a long enough time period that you probably won't ever hold the plunger
            away from the park position for that long in normal play.
         </div>
         
         <div>
            <label><input type="checkbox" id="plungerAutoZeroEnabled"> Enable auto-zeroing</label>
            <div style="margin: 1ex 0px 1em 2em;">
               Auto-zero after <input type="text" size="4" id="plungerAutoZeroTime"> seconds
            </div>
         </div>
      </div>

   </div>

   <script>
var prvPlungerType = -1;
var plungerTypeValid = false;
$("#plungerType").change(function(ev)
{
    // deactivate all pin groups until we know which ones we're activating
    $("#plungerPinsTSL .pinselect, #plungerPinsPot .pinselect,"
      + "#plungerPinsQuad .pinselect, #plungerPinsVL6180X .pinselect").data(
        {"active": false, "save": false});

    // show or hide the ZB Launch Ball and calibration button sections
    var newvis = ($(this).val() != 0);
    slideToggle($("#zbGroup, #calBtnGroup"), newvis, 250, false);
    slideToggle($("#zbHidden, #calBtnHidden"), !newvis, 250, false);

    // hide the auto-zero section - it only applies to certain sensor types
    $("#plungerAutoZero").hide();

    // show or hide the sensor viewer button
    $("#plungerSensorButton").css("display", newvis ? "" : "none");

    // presume we have a valid plunger type
    plungerTypeValid = true;

    // show the appropriate section
    var all = $("#plungerPinsTSL, #plungerPinsPot, #plungerPinsQuad, #plungerPinsVL6180X");
    var typ = +$(this).val();
    switch (typ)
    {
    case 0:
    default:
        // no sensor - hide all
        slideClosed(all, 250);
        plungerTypeValid = false;
        break;
    
    case 1:
    case 3:
    case 8:
        // TSL1410R, TSL1412S, and TSL1401CL
        $("#TSLName").text({1: "TSL1410R", 3: "TSL1412S", 8: "TSL1401CL"}[typ] || "TSLxx");
        $("#tsl1410-1412-details, #tsl1401-details").hide();
        $(typ == 8 ? "#tsl1401-details" : "#tsl1410-1412-details").show();
        slideRadio($("#plungerPinsTSL"), all, 250, false);
        $("#plungerPinsTSL .pinselect").data("active", true).data("save", true);
        break;

    case 5:
        // Potentiometer
        slideRadio($("#plungerPinsPot"), all, 250, false);
        $("#plungerPinsPot .pinselect").data("active", true).data("save", true);
        break;

    case 6:
        // Quadrature sensor - AEDR-8300
        slideRadio($("#plungerPinsQuad"), all, 250, false);
        $("#plungerPinsQuad .pinselect").data("active", true).data("save", true);
        $("#plungerAutoZero").show();
        break;

    case 9:
        // VL6180X
        slideRadio($("#plungerPinsVL6180X"), all, 250, false);
        $("#plungerPinsVL6180X .pinselect").data("active", true).data("save", true);
        break;
    }

    // if this was a UI event, reset the factory defaults for the pin configuration
    if (!!ev.originalEvent)
        setPlungerPinFactoryDefaults(prvPlungerType);

    // update the calibration button pin active/inactive status
    updateCalButtonStatus();

    // update pin warning indicators for any active status change
    updatePinWarnings();

    // remember the new type
    prvPlungerType = typ;
});

// set the factory defaults for the plunger pins
function setPlungerPinFactoryDefaults(prvPlungerType)
{
    switch (+$("#plungerType").val())
    {
    case 1:
    case 3:
    case 8:
        // TSL1410R / TSL1412R.  Reset pins only if we're not switching between
        // these two subtypes.  The 1410R and 1412R use identical pin wiring, so
        // switching from one type to the other doesn't require any pin changes.
        if (prvPlungerType != 1 && prvPlungerType != 3) {
            $("#tsl_si .pinval").val("PTE20");
            $("#tsl_clk .pinval").val("PTE21");
            $("#tsl_ao .pinval").val("PTB0");
        }
        break;

    case 5:
        // Potentiometer
        $("#pot_ao .pinval").val("PTB0");
        break;

    case 6:
        // AEDR-8300 quadrature sensor
        $("#quadrature_CHA .pinval").val("PTD0");
        $("#quadrature_CHB .pinval").val("PTD5");
        break;

    case 9:
        // VL6180X time-of-flight sensor
        $("#VL6180X_SDA .pinval").val("PTE20");
        $("#VL6180X_SCL .pinval").val("PTE21");
        $("#VL6180X_GPIO0CE .pinval").val("PTB0");
        break;
    }
}

$("#btnPlungerCal").click(function(ev) {
    // don't actually open the link
    ev.preventDefault();
    
    // check for pin changes
    function pinChanges()
    {
        switch ($("#plungerType").val())
        {
        case "1":
        case "3":
        case "8":
            return $("#tsl_si .pinval").val() != config.plungerPins.a
                || $("#tsl_clk .pinval").val() != config.plungerPins.b
                || $("#tsl_ao .pinval").val() != config.plungerPins.c;

        case "5":
            return $("#pot_ao").text() != config.plungerPins.a;

        case 6:
            return $("#quadrature_CHA .pinval").val() != config.plungerPins.a
                || $("#quadrature_CHB .pinval").val() != config.plungerPins.b;

        case 9:
            return $("#VL6180X_SDA .pinval").val() != config.plungerPins.a
                || $("#VL6180X_SCL .pinval").val() != config.plungerPins.b
                || $("#VL6180X_GPIO0CE .pinval").val() != config.plungerPins.c;

        default:
            return false;
        }
    }
    
    // make sure the config values haven't changed
    if ($("#plungerType").val() != config.plungerType || pinChanges())
    {
        if (!window.external.YesNoDialog(
            "You've made changes to the sensor setup that you haven't "
            + "programmed into the KL25Z yet. The live viewer will reflect "
            + "the current device settings, not your new unsaved changes. "
            + "If you want to view the sensor using the new settings, click "
            + "\"Program KL25Z\" before proceeding to the sensor viewer."
            + "\r\n\r\n"
            + "Do you want to open the sensor viewer anyway?"))
            return;
    }
        
    // show the sensor dialog
    window.external.ShowPlungerWindow(CPUID);
});
   </script>

   <!-- Plunger calibration button ----------------------------------------->
   <hr>
   <div class="section" data-name="Calibration Button">
      <img src="calbtn.png" class="sectionIcon">
      <b>Plunger calibration button.</b>  If you wish, you can install a 
      pushbutton in your cabinet to activate plunger calibration mode.
      This is optional, since you can also run the calibration from this
      setup program.  See the Build Guide for wiring instructions.

      <div id="calBtnGroup">
         <table class="inputs">
            <tr>
               <td class="pinlabel">Button input:</td>
               <td>
                  <span class="pinselect expBoardPin" id="calBtn"
                    data-cfg="calButtonPins.button" data-gpiotype="dig-in extern"
                    data-desc="Plunger Calibration Button" data-default="PTE29">
                  </span>
                  <label><input type="checkbox" id="calBtnEna">Enabled</label>
               </td>
            </tr>
            <tr>
               <td class="pinlabel">Indicator lamp output:</td>
               <td>
                  <span class="pinselect expBoardPin" id="calLED"
                    data-cfg="calButtonPins.led" data-gpiotype="dig-out extern"
                    data-desc="Plunger Calibration Lamp" data-default="PTE23">
                  </span>
                  <label><input type="checkbox" id="calLEDEna">Enabled</label>
               </td>
            </tr>
         </table>
      </div>
      <div id="calBtnHidden" style="height: 0px; overflow: hidden;">
         (The calibration button is only applicable when you have a plunger
         sensor installed.)
      </div>
      <div class="expBoardAlt">
         Connect the calibration button to the CAL BTN connector
         (JP3) on the main interface board.
      </div>
   </div>

   <script>

$("#calBtnEna, #calLEDEna").change(function(ev) {
    updateCalButtonStatus();
    updatePinWarnings();
});
function updateCalButtonStatus()
{
    // the calibration buttons pins are active if there's a valid plunger
    // type and the corresponding feature is enabled
    $("#calBtn").data("active", plungerTypeValid && $("#calBtnEna").prop("checked"));
    $("#calLED").data("active", plungerTypeValid && $("#calLEDEna").prop("checked"));
}


   </script>


   <!-- ZB Launch Ball ----------------------------------------------------->
   <hr>
   <div class="section" data-name="ZB Launch Ball">
      <a name="zblaunch"></a>
      <img src="ZBLaunch.png" class="sectionIcon">
      <b>ZB Launch Ball setup.</b>  You can set up your mechanical plunger
      to act as a "virtual" Launch Ball button for tables that use a button
      instead of a plunger.
      <a href="#" class="shower">Details</a>

      <div class="hider">
         This feature lets you use a mechanical plunger in lieu of a Launch Ball button,
         for tables that need it, in case you don't want to install a separate physical
         Launch button.  When this is enabled, you treat the plunger knob like a button:
         push it a little forward to "click" the button.  You can also pull back and
         release the plunger to simulate a brief button push.

         <ul>
            <li>The feature is only activated when a non-plunger table is running
            on the PC.  We can tell because Visual Pinball turns on the <b>output port</b>
            selected below when such a table is loaded.

            <li>The port you designate can be any type, including a "virtual" port that
            isn't connected to any physical output wiring.

            <li><b>In the <a class="dofconfigtool">DOF Config Tool</a></b>, be sure to
            set the port number you designate here as your <b>ZB Launch Ball</b> port.
            That connects everything on the PC to the right port.

            <li>Select the keyboard key or joystick button to send to the PC when
            the plunger triggers a launch.  This is usually the Enter key, because
            that's what almost all PC pinball software uses.

            <li>The <b>push distance</b> sets the sensitivity.  When you push the
            plunger forward by this amount or more (and the feature has been activated by
            the output port), the controller simulates pressing the Launch Ball button.
            Set the distance far enough that it doesn't trip randomly, but short enough
            that you don't have to push too hard.  We recommend about .06 to .08 inches.
         </ul>
      </div>

      <div id="zbHidden" style="overflow: hidden; height: 0px;">
         (The ZB Launch Ball feature only applies when you have a
         plunger sensor installed.)
      </div>

      <div id="zbGroup">
         <div>
            <label><input type="checkbox" id="zbEnabled">Enabled</label>
         </div>
         
         <div class="indented" id="zbFields">
            <table class="inputs">
               <tr>
                  <td>Output port number:</td>
                  <td><input id="zbPort" size=5></td>
                  <td><b>Important!</b> Set this port to "ZB Launch Ball" in the
                     <a class="dofconfigtool">DOF Config Tool</td>
               </tr>
               <tr class="buttonRow">
                  <td class="keylabel">Key/button:</td>
                  <td>
                     <span class="keymapping" id="keymapZB">
                        <span class="keyname"></span>
                        <span class="keycode"></span>
                        <span class="keytype"></span>
                     </span>
                  </td>
                  <td>Most PC pinball software uses the Enter key for ball launch</td>
               </tr>
               <tr>
                  <td>Push distance (inches):</td>
                  <td><input id="zbDistance" size=5></td>
                  <td>Recommended value is 0.063 (about 1/16")
               </tr>
            </table>
         </div>
      </div>
         
   </div>

   <script>

// show/hide the section on changing the Enable checkbox
$("#zbEnabled").change(function() {
    var ena = $(this).prop("checked");
    slideToggle($("#zbFields"), ena, 250, false);
    if (!ena)
        $("#zbPort").val("0").change();
    else if (+$("#zbPort").val() == 0)
        $("#zbPort").val("1").change();
});

$("#zbPort").change(function(ev) {
    $("#outputTab .zbRemark").remove();
    var row = +$(this).val();
    if ($("#zbEnabled").prop("checked") && row != 0) {
        var oprow = $("#outputTab .outPortRow").eq(row-1);
        if (oprow.find(".pintype").val() == 0 && !loadingConfig) {
            if (window.external.YesNoDialog(
                "The port you selected isn't currently configured. Would "
                + "you like to add it as a \"virtual\" port?  This will "
                + "ensure that the PC will be able to address it properly."))
                appendOutputs(row);
            else
                window.external.ShowAdviceDialog(
                    "InvalidZBPortWarning",
                    "Okay, no port was added. Note that the PC won't be able to "
                    + "activate the ZB Launch feature unless you assign this to a "
                    + "valid port that exists in the output list. Please be sure "
                    + "to add the port or change the number here before finalizing "
                    + "your settings.");
        }
        oprow.find(".outPortRemarks").append(
            "<span class=\"zbRemark\" title=\"This is the ZB Launch Ball output port\">"
            + "<a href=\"#zblaunch\">"
            + "<img src=\"zbLaunchSmall.png\">"
            + "</a>"
            + "</span>");
    }
});

   </script>


   <!-- Button input setup ---------------------------------------------->
   <hr>
   <div class="section" data-name="Buttons">
      <a name="buttonSection"></a>
      <img src="buttonSection.png" class="sectionIcon">
      <b>Button inputs.</b>  You can use the KL25Z as a key encoder to
      connect pinball-style buttons on your cabinet to the PC.  Set up
      the wiring connections and key assignments below.  Each input can
      be mapped as a joystick button or keyboard key.  Click an input
      pin or key assignment to change a setting.

      <div>
         <a href="#" id="btnButtonTest" class="button">Test Buttons</a>
      </div>
      
      <div id="shiftButtonSetup">
         <div>
            <span style="padding-right: 2em;">
               <img src="ShiftButton.png" style="vertical-align: middle;">
               <b>Shift button number:</b>
            </span>
            <input type="text" id="shiftButton" size="4">
            <span style="padding-left: 2em;">
               <a href="#" id="helpShiftButton">Help</a>
            </span>
            <div style="margin: 1ex 0px 2em 2em;">
               <label><input type="radio" name="shiftButtonMode" value="0">
                  Shift OR Key mode</label><br>
               <label><input type="radio" name="shiftButtonMode" value="1">
                  Shift AND Key mode</label>
            </div>
         </div>
      </div>
      
      <div>
         <a href="#" id="setAllJoystick">Set standard joystick buttons</a>
         | <a href="#" id="setAllKB">Set standard keyboard keys</a>
         | <a href="#" class="btnHelp">View standard key assignments</a>
      </div>
      
      <div>
         <table id="buttonTab">
         </table>
      </div>
      <div id="buttonTabStretchNote">
         <i><b>Note:</b> your current firmware version supports up to
            <span id="buttonTabMaxNote">0</span> physical buttons.  The
            list above will automatically expand as you fill in new
            items, up to the limit.</i>
      </div>
   </div>

   <script type="text/javascript" src="keycaps.js"></script>

   <script>

$("#helpShiftButton").click(function(ev) {
    ev.preventDefault();
    window.external.ShowHelp("HelpShiftButton.htm");
});
// show the button tester
$("#btnButtonTest").click(function(ev)
{
    ev.preventDefault();
    var cfgMem = normalizeConfig(configFromUI());
    var cfgDev = normalizeConfig(config);
    if (!valEq(cfgMem.buttons, cfgDev.buttons)
        || !valEq(cfgMem.xbuttons, cfgDev.xbuttons)
        || !valEq(cfgMem.shiftButton, cfgDev.shiftButton))
    {
        if (!window.external.YesNoDialog(
            "You've made changes to the button settings that you haven't "
            + "programmed into the KL25Z yet. The tester window will reflect "
            + "the current device settings, not your new unsaved changes. "
            + "If you want to test your new settings, click \"Program KL25Z\" "
            + "before proceeding to the tester window."
            + "\r\n\r\n"
            + "Do you want to open the tester anyway?"))
            return;
    }

    // show the dialog
    window.external.ShowButtonTester(CPUID);
});


// Button row updater.  We group updates to avoid updating
// the same row repeatedly when performing a task that affects
// multiple rows (config loading, changing the night mode
// button, changing the shift button).
var ButtonTabUpdate = {
    touch: function(item) {  // item can be a button row element (TR) or any element within a row
        if (!item)
        {
            $("#buttonTab tr.buttonRow").each(function() { ButtonTabUpdate.touch($(this)); });
            return;
        }
        if (!item.is("tr"))
            item = item.parents("tr.buttonRow");
        this.pending[item.find(".keymapping").data("idx")] = item;
        if (!this.queued) {
            var self = this;
            setTimeout(function() { self.go(); }, 1);
            this.queued = true;
        }
    },
    pending: { },
    queued: false,
    go: function() {
        $.each(this.pending, function(key, val) {
            updateButtonRow(val);
        });
        stretchButtonTable();
        this.queued = false;
        this.pending = { };
    }
};

$("#shiftButton").change(function(ev)
{
    var n = $(this).val()
    $("#buttonTab tr").removeClass("shiftRow")
         .find("td.shiftCol span").attr("title", "Click here to make this the Local Shift Button");
    $("#buttonRow" + n).addClass("shiftRow")
        .find("td.shiftCol span").attr("title", "This input is the Local Shift Button. Other "
                           + "buttons pushed while the Shift Button is held down use "
                           + "their shifted key codes.");

    $("#buttonTab .buttonCol.shifted, #buttonTab th.shifted").toggle(n != 0);

    ButtonTabUpdate.touch();
    showHideNightModeButtonShift();
    updateNightModeButton();
});

$("#setAllJoystick").click(function(ev)
{
    if (window.external.YesNoDialog(
        "This will replace your current key assignments in "
        + "slots 1-24 with joystick buttons 1-24, respectively. "
        + "Are you sure you want to replace all of these settings?"))
    {
        $("#buttonTab tr").each(function()
        {
            var tr = $(this);
            var keymapping = tr.find(".primary .keymapping");
            var idx = keymapping.data("idx");
            if (idx >= 1 && idx <= 24)
            {
                keymapping.children(".keytype").val(1).change();
                keymapping.children(".keycode").val(idx).change();
            }
        });
    }
    ev.preventDefault();
    ev.stopPropagation();
});
$("#setAllKB").click(function(ev)
{
    if (window.external.YesNoDialog(
        "This will replace your current key assignments "
        + "with the standard keyboard mappings for Visual "
        + "Pinball.  Are you sure you want to proceed?"))
    {
        $("#buttonTab tr").each(function()
        {
            var tr = $(this);
            var keymapping = tr.find(".primary .keymapping");
            var idx = keymapping.data("idx");
            var defs = expansionBoardFactoryConfig.buttons;
            if (defs[idx])
            {
                keymapping.children(".keytype").val(defs[idx].keytype).change();
                keymapping.children(".keycode").val(defs[idx].keycode).change();
            }
        });
    }
    ev.preventDefault();
    ev.stopPropagation();
});

// Map from the modifier key codes to keycaps entries.  The modifier
// keys are encoded with a bit mask, per the usual USB keyboard
// conventions.  Each modifier is represented by one bit in the mask.
// This maps from the individual bits to the corresponding keycaps
// indices.
var shiftKeyMap = {
    0x01: 0xE0,         // left control
    0x02: 0xE1,         // left shift
    0x04: 0xE2,         // left alt
    0x08: 0xE3,         // left GUI
    0x10: 0xE4,         // right control
    0x20: 0xE5,         // right shift
    0x40: 0xE6,         // right alt
    0x80: 0xE7          // right GUI
};

// Standard VP key usage, indexed by "type.keyCodeInHex" (e.g., 2.1E = keyboard "1").
// We rebuild this during initialization to index in decimal (2.30 = "1").  Hex is
// more convenient for typing in the entries, while decimal is more convenient for
// looking them up.  We could probably just as well dispense with the "2." and 
// assume that only keyboard keys have standard VP usages, which is currently the
// case.  But we include the type code anyway for the sake of future-proofing, just
// in case VP ever adopts standard usages for other input methods (e.g., joystick
// buttons).
var vpUsage = {
    "2.1E": "Start Game",
    "2.1F": "Extra Ball (Buy-In)",
    "2.22": "Coin In",
    "2.21": "Coin In (second coin slot)",
    "2.23": "Coin In (fourth coin slot)",
    "2.28": "Plunger/Launch Ball",
    "2.29": "Exit to menu (PinballX/HyperPin front ends)",
    "2.14": "Quit to editor (within VP)",
    "2.E1": "Left Flipper",
    "2.E5": "Right Flipper",
    "2.E0": "Left MagnaSave",
    "2.E4": "Right MagnaSave",
    "2.17": "Mechanical Tilt Bob",
    "2.4A": "Slam Tilt",
    "2.2C": "Forward Nudge",
    "2.1D": "Left Nudge",
    "2.38": "Right Nudge",
    "2.4D": "Open/Close Coin Door",
    "2.24": "Service Button \"Cancel/Exit\"",
    "2.25": "Service Button \"Down/-\"",
    "2.26": "Service Button \"Up/+\"",
    "2.27": "Service Button \"Enter\"",
    "2.2E": "VP Volume Down",
    "2.2D": "VP Volume Up"
};

function updateButtonRow(tr)
{
    // update the key caps
    var km = tr.find(".keymapping");
    if (km.length)
    {
        // update the displayed key caps
        km.each(function() { updateKeyCap($(this)); });

        // update the displayed usage 
        var usage = [];
        tr.find(".keymapping").each(function() {
            var m = $(this);
            usage.push(vpUsage[m.find(".keytype").val() + "." + (+m.find(".keycode").val())] || "-");
        });
        if ($("#shiftButton").val() == 0) usage.pop();  // remove the shifted key display if the shift button is disabled
        tr.find(".keyusage").text(usage.join("/"));

        // update the displayed flag icons
        var flags = +tr.find("input.keyflags").val();
        tr.find("td.keyflags img").each(function() {
            var img = $(this);
            var f = !!(flags & img.data("mask"));
            img.attr("src", img.attr("src").replace(/On|Off/, f ? "On" : "Off"));
        });
    }
}

function updateKeyCap(km)
{
    km.removeClass("asNone asKey asShiftKey asMediaKey asJoystickButton");
    km.css("background-position", "");
    var typ = +km.children(".keytype").val();
    var code = +km.children(".keycode").val();
    var typemap = { 0: "asNone", 1: "asJoystickButton", 2: "asKey", 3: "asMediaKey" };
    km.addClass(typemap[typ] || "asNone");
    var wid = "auto", ht = "32px", lht = "32px";
    var txt = "", title = "";
    switch (typ)
    {
    case 0:
    default:
        title = "Pushing this button won't send any key press to the PC";
        wid = ht = "32px";
        break;

    case 1:
        txt = code;
        title = "Joystick Button " + code;
        wid = ht = "32px";
        lht = "28px";
        break;

    case 2:
    case 3:
        // get the key name
        var k = (typ == 2 ? keycaps[code] : mediaKeycaps[code]);
        title = k.name;

        // show the "alternate" image if defined, otherwise just use the name
        if (k.cx)
        {
            wid = (k.cwid || 30) + "px";
            ht = (k.cht || 31) + "px";
            km.css("background-position", (-k.cx) + "px " + (-k.cy) + "px");
        }
        else if (k.x)
        {
            wid = (k.wid || 30) + "px";
            ht = (k.ht || 31) + "px";
            km.css("background-position", (-k.x) + "px " + (-k.y) + "px");
        }
        else
        {
            txt = k.name;
            km.removeClass("asKey asMediaKey").addClass("asKeyName");
        }
        break;
    }
    km.attr("title", title).css({ width: wid, height: ht, lineHeight: lht }); // set lineHeight for vertical centering of .keyname label
    km.children(".keyname").text(txt);
}

// size the button table to display the number of buttons the firmware
// supports
var buttonTabMax = 0;
function sizeButtonTable(config)
{
    // we only have to do this once per load
    if (buttonTabMax)
        return;

    var count = 0;
    $.each(config.buttons, function(key) { if (/\d+/.test(key)) ++count; });
    $("#shiftButton, #nightModeButtonNo").spinner("option", "max", count);
    $("#buttonTabMaxNote").text(count);
    buttonTabMax = count;
    $("#buttonTab tr.buttonRow").each(function() {
        var tr = $(this);
        var keymapping = tr.find(".keymapping");
        var idx = keymapping.data("idx");
        var active = (idx <= count);
        tr.toggle(active);
        keymapping.data("outOfService", !active);
        tr.find(".pinselect").data("save", active);
    });
}

// Adjust the visibility of button table rows at the bottom.  We hide
// rows after the last completely unused row.
function stretchButtonTable()
{
    var last = 0;
    $("#buttonTab tr.buttonRow").each(function() {
        var tr = $(this);
        var km = tr.find(".keymapping");
        var idx = +km.data("idx");
        if (idx > buttonTabMax) return false;
        if (idx >= last)
        {
            if (tr.find(".pinval").val() != "Not Connected")
                last = idx;
            else if ($("#nightModeButtonNo").val() == idx)
                last = idx;
            else
            {
                km.each(function() {
                    if ($(this).find(".keytype").val() != 0) {
                        last = idx;
                        return false;
                    }
                });
            }
        }
    });

    var sb = +$("#shiftButton").val();
    if (sb > last)
        last = sb;

    // show one blank row if we haven't maxed out the table
    if (last < buttonTabMax) ++last;

    $("#buttonTab tr.buttonRow").each(function() {
        $(this).toggle(+$(this).find(".keymapping").data("idx") <= last);
    });

    $("#buttonTabStretchNote").toggle(last < buttonTabMax);
}

// .keymapping click handler
var keymappingClick;

// build the button table rows
$(function() {

    // reindex the vpUsage table by decimal key code
    var u = vpUsage;
    vpUsage = { };
    $.each(u, function(key, val) {
        if (/(\d+)\.(.+)/.test(key)) {
            vpUsage[RegExp.$1 + "." + parseInt(RegExp.$2, 16)] = val;
        }
    });

    // Set the modifier key mapping for each modifier key in the key caps
    $.each(shiftKeyMap, function(k, v) { keycaps[v].modkey = k; });

    // Build the button table header
    var rows = [];
    rows.push("<tr>"
              + "<th>No.</th>"
              + "<th>Port</th>"
              + "<th class=\"shiftCol\"><img src=\"ShiftButton.png\"></th>"
              + "<th style=\"text-align: left;\">PC Input</th>"
              + "<th style=\"text-align: left;\" class=\"shifted\">Shifted</th>"
              + "<th style=\"padding: 0px; white-space: nowrap;\">Options [<a href=\"#\" id=\"pulseKeyHelp\">?</a>]</th>"
              + "<th class=\"keyusage\" title=\"The standard meaning of the assigned key in Visual Pinball\">VP Usage</th>"
              + "</tr>");

    // Build a <TR> for each button table row.  Start with more than we
    // need in the firmware - we'll hide extra rows after loading the
    // configuration, at which point we'll know how many rows we really
    // need.  It would be better if we populated the table dynamically
    // upon loading the config, but that would require a bunch of rework
    // thanks to early assumptions that we had a fixed number of rows
    // (versions of the firmware up until 11/2016 had a fixed size of
    // 32 keys in the firmware).  That rework is a bit tricky because
    // initialization is scattered, mostly thanks to to entanglements
    // with the pin selector dialogs.  Right now it's easier to just
    // create "more than enough" rows and hide the ones we don't need.
    // This is never a good strategy in the long run; it's the classic
    // "who'd ever need more than 640K?" all over again.  But I guess
    // I'd be pretty happy to be only as visionary as billg, plus, as
    // long as we're on the KL25Z, we really can't add infinite
    // buttons anyway, since memory is already tight.)
    for (var i = 1 ; i <= MaxButtons ; ++i)
    {
        rows.push("<tr class=\"buttonRow\" id=\"buttonRow" + i + "\" data-idx=\"" + i + "\">"
                  + "<td class=\"pinlabel keylabel\">" + i + "</td>"               // button number                     
                  + "<td>"
                  +   "<span class=\"pinselect withExpBoardAlias\" id=\"button" + i + "\" "    // input pin
                  +      "data-gpiotype=\"dig-in extern\" "
                  +      "data-cfg=\"buttons." + i + ".pin\" "
                  +      "data-desc=\"Button " + i + "\">"
                  +   "</span>"
                  + "</td>"
                  + "<td class=\"shiftCol\">"
                  +    "<span>"
                  +    "</span>"
                  + "</td>"
                  + "<td class=\"buttonCol primary\">"
                  +   "<span class=\"keymappingContainer\">"
                  +     "<span class=\"keymapping\" id=\"keymap" + i + "\" data-idx=\"" + i + "\">" // key mapping
                  +       "<span class=\"keyname\"></span>"
                  +       "<input class=\"keycode\" type=\"hidden\">"
                  +       "<input class=\"keytype\" type=\"hidden\">"
                  +       "<input class=\"keyflags\" type=\"hidden\">"
                  +     "</span>"
                  +   "</span>"
                  +   "<span class=\"keyIR\" title=\"IR command to send when you press this button\">"
                  +     "<span class=\"label\"></span>"
                  +     "<input class=\"IRCommand\" type=\"hidden\">"
                  +   "</span>"
                  +   "<span class=\"keyNightMode\" title=\"Make this the Night Mode button\"></span>"
                  + "</td>"
                  + "<td class=\"buttonCol shifted\">"
                  +   "<span class=\"keymapping\" id=\"xkeymap" + i + "\" data-xidx=\"" + i + "\">" // shift key mapping
                  +     "<span class=\"keyname\"></span>"
                  +     "<input class=\"keycode\" type=\"hidden\">"
                  +     "<input class=\"keytype\" type=\"hidden\">"
                  +   "</span>"
                  +   "<span class=\"keyIR\" title=\"IR command to send when you press this shifted button\">"
                  +     "<span class=\"label\"></span>"
                  +     "<input class=\"IRCommand\" type=\"hidden\">"
                  +   "</span>"
                  +   "<span class=\"keyNightMode\" title=\"Make this the Night Mode button\"></span>"
                  + "</td>"
                  + "<td class=\"keyflags\">"
                  +   "<img src=\"PulseOff.png\" id=\"keyPulse" + i + "\" data-mask=\"1\" "   // pulse mode flag
                  +      "title=\"Pulse mode: the button sends one key press when pushed, a second when released\">"
                  + "</td>"
                  + "<td class=\"keyusage\" id=\"keyusage" + i + "\" title=\"The standard meaning of this key in Visual Pinball\">"
                  + "</td>"
                  + "</tr>");
    }

    // inject the HTML
    $("#buttonTab").html(rows);

    // pulse key help
    $("#pulseKeyHelp").click(function(ev) {
        window.external.ShowHelp("HelpPulseKey.htm");
        ev.preventDefault();
    });

    // set the shift key to a given row
    $("#buttonTab td.shiftCol span").click(function(ev) {
        var idx = $(this).parents("tr.buttonRow").data("idx");
        var oldIdx = $("#shiftButton").val();
            $("#shiftButton").val(oldIdx == idx ? 0 : idx).change();
    });
    
    // on changing the pin selection, update the expansion board alias, if applicable
    $("#buttonTab .pinselect").change(function()
    {
        var port = $(this).children(".pinval").val();
        var alias = (gpioPortAlias[port] || "").split("|");
        $(this).find("input.expBoardAlt").val("$1 ($2)".formatOrUndef(alias[0], alias[1]) || port);
        ButtonTabUpdate.touch($(this));
    });

    // pulse mode
    $("#buttonTab td.keyflags img").click(function(ev)
    {
        var keyflags = $(this).parents("tr.buttonRow").find("input.keyflags");
        keyflags.val(keyflags.val() ^ $(this).data("mask")).change();
    });

    // on changing any of the key sub-fields, update the displayed value
    $(".keymapping .keycode, .keymapping .keytype, .keymapping input.keyflags").change(function(ev) {
        ButtonTabUpdate.touch($(this));
    });

    // get the key selector dialog element so we can set it up
    var dlg = $("#keySelector");

    // build the clickable buttons on the key cap image for the dialog, and a
    // table mapping javascript key codes to keycaps and mediaKeyCaps entries
    var btns = [];
    var jsKeyCaps = { };
    var makeKey = function(k, v, typ) {
        // if this key has a clickable image, add it
        if (v.x)
        {
            var usage = vpUsage[typ + "." + (+k)];
            usage = usage ? "\nTypical VP use: " + usage : "";
            btns.push("<span id=\"keycapBtn" + typ + "_" + k + "\" "
                      + "data-keytype=\"" + typ + "\" "
                      + "class=\"keycapBtn\" data-scancode=\"" + k + "\" "
                      + "title=\"" + (v.name + usage).replace(/"/, "&#34;") + "\" "
                      + "style=\""
                      +   "left: " + (v.x+4) + "px;"
                      +   "top: " + (v.y+4) + "px;"
                      +   "width: " + (v.wid || 30) + "px;"
                      +   "height: " + (v.ht || 31) + "px;"
                      + "\"></span>");
        }

        // if it has a javascript key code, add it to the js key map
        if (v.jskey)
            (jsKeyCaps[v.jskey] = jsKeyCaps[v.jskey] || []).push({keytype: typ, keycode: k, jsloc: v.jsloc});
    };
    $.each(keycaps, function(k, v) { makeKey(k, v, 2); });
    $.each(mediaKeycaps, function(k, v) { makeKey(k, v, 3); });
    $("#oskeyboard").html(btns.join(""));

    // build the clickable buttons for the joystick button selector dialog page
    btns = [];
    for (var i = 1, row = [] ; i <= 32 ; ++i)
    {
        row.push("<span id=\"jsBtn" + i + "\" "
                 +   "class=\"jsBtn\" "
                 +   "data-button=\"" + i + "\">"
                 +  i
                 + "</span>");
        if (row.length == 8)
        {
            btns.push("<div class=\"jsBtnRow\">" + row.join("") + "</div>");
            row = [];
        }
    }
    $("#osjoystick .jsBtnBox").html(btns.join(""));

    // set up the page selection buttons
    $("#keytype").children().click(function() {
        var page;
        $("#keytype > img").removeClass("selected");
        $("#osunused, #oskeyboard, #osjoystick, #osspecial").css("display", "none");
        (page = $($(this).data("page"))).css("display", "");
        $("#keySelector > div").css("width", page.outerWidth() + "px");
        $(this).addClass("selected");
    });

    // row that opened the dialog, and its label item
    var dlgkey, dlgkeylbl;

    // handle events on the on-screen keyboard buttons
    $(".keycapBtn").click(function(ev) {
        // click a key - select the key (keyboard is type 2) and close the dialog
        selectButton($(this).data("keytype"), +$(this).data("scancode"), true);
        ev.preventDefault();
    }).hover(redisp, redisp);

    function redisp() {
        // Hack to work around a WebBrowser (IE) bug.  This workaround is a pretty
        // egregious hack, but the bug is annoying.  The bug comes from using CSS
        // :hover to alter a transparent overlay (the button div).  This causes a
        // weird little shift in the background rendering below the div.  It makes
        // it look blurry.  The root of the bug seems to be a rounding error when IE
        // calculates the repainting region; the rounding error comes from the
        // "margin: auto" centering, which presumably comes up with a fractional
        // pixel position that gets rounded one way when the background is rendered
        // and the other way when the overlay is rendered.  The fix here forces a
        // redraw of the underlying background by changing its width.  That full
        // background refresh has the effect of painting over our bug-damaged region,
        // and IE's double buffering of the graphics rendering ensures that the
        // correction happens before the damaged pixels ever hit the screen, so the
        // damage is never visible.  To force the redraw, we simply add a pixel to
        // the underlying div width, then set a timeout to take the pixel back out
        // a millisecond later.  We have to break the two steps across a timeout so
        // that IE can't combine the two changes into one event cycle, which would
        // skip the resize and thus skip the refresh.  Neither width change has any
        // visible effect on the actual layout, so even if the timeout happens to
        // cross a physical video refresh cycle boundary, there's no change in
        // what's displayed and therefore the redraw is invisible.  This whole
        // process is horribly inefficient, but it's the only thing I've found
        // that fixes the glitch.  It's obviously tied to the peculiarities of 
        // the IE rendering engine, but I don't think it'll do any harm if this
        // particular bug is fixed in a future version, apart from the little bit
        // of added overhead.
        $("#oskeyboard").css("width", ($("#oskeyboard").outerWidth() + 1) + "px");
        setTimeout(function() {
            $("#oskeyboard").css("width", ($("#oskeyboard").outerWidth() - 1) + "px");
        }, 1);
    }

    // click a joystick button
    $(".jsBtn").click(function(ev) {
        // select the joystick button (joystick = type 1)
        selectButton("1", $(this).data("button"), true);
        ev.preventDefault();
    });

    // click the "unused" button
    $("#unusedBtn").click(function(ev) {
        // make the button unused (type 0)
        selectButton("0", 0, false);
        ev.preventDefault();

        // done with the key dialog
        dismissKeyDlg();
    });

    // Turn night mode on, off, or toggle for the given button.
    //
    // button = the keyNightMode button
    //
    // newState = "on"     - set this as the night mode button unconditionally
    //            "off"    - turn off night mode if it's set to this button
    //            "toggle" - set this as the night mode button if it's not already;
    //                       turn night mode off if it's currently the night mode button
    function nightModeClick(button, newState)
    {
        // get the button we're clicking on, and note if it's a shifted button
        var km = button.parents("td").find(".keymapping");
        var idx = km.data("idx"), xidx = km.data("xidx");
        var btn = idx || xidx;
        var shift = !!xidx;

        // get the current night mode button setting
        var fld = $("#nightModeButtonNo");
        var ck = $("#nightModeButtonShift input");

        // note if this button is currently the night mode button
        var oldState = (fld.val() == btn && ck.prop("checked") == shift);

        // figure the new state
        if (newState == "off")
        {
            // turn off night mode only if this is the night mode button currently
            if (!oldState)
                newState = "nop";
        }
        else if (newState == "toggle")
        {
            // reverse the current state
            newState = oldState ? "off" : "on";
        }

        // don't allow a shifted night mode button if in switch mode
        var toggleMode = ($("#nightModeOptions input:radio[name=nightModeButtonType]:checked").val() == 1);
        if (newState == "on" && shift && !toggleMode)
        {
            alert("Night Mode can't be assigned to a shifted button when "
                  + "the on/off switch mode is used.");
            return;
        }

        // Apply the new state.  Note that 'newState' could be "nop",
        // meaning that we're not making any changes.
        if (newState == "off") {
            ck.prop("checked", false);
            fld.val(0).change();
            $(this).removeClass("selected");
        }
        else if (newState == "on") {
            ck.prop("checked", shift);
            fld.val(btn).change();
            $(this).addClass("selected");
        }
    }
    
    // night mode button
    $(".keyNightMode").click(function(ev) {
        nightModeClick($(this), "toggle");
        ev.preventDefault();
    });

    // on clicking any key mapping, display the key selector popup
    keymappingClick = function(ev) {

        // remember who opened the dialog
        dlgkey = $(this);

        // mark the label as active
        dlgkeylbl = dlgkey.parents("tr.buttonRow");
        dlgkeylbl.addClass("openDlgRow");

        // we'll fully handle the event here - skip any default action
        ev.preventDefault();

        // reset the dialog
        $(".keycapBtn, .jsBtn, #unusedBtn, #nightModeBtn").removeClass("hover selected");
        $("#keytype > img").removeClass("selected");

        // show the dialog
        dlg.parent().css("display", "block");

        // position it below the field
        var ofs = dlgkeylbl.offset();
        var dlght = dlg.outerHeight() + 24;
        var winht = window.innerHeight - $("#nav").outerHeight();
        var scrolly = $("html,body").scrollTop();
        var y = ofs.top + dlgkeylbl.height();
        dlg.css("top", y + "px");

        // make sure the bottom of the dialog is in view
        if (y + dlght > scrolly + winht)
            scrolly = y + dlght - winht;

        // but limit this so that the top stays in view
        if (scrolly > y)
            scrolly = y;

        // scroll here
        $("html,body").animate({ scrollTop: scrolly });

        // presume the key has no special meaning
        var isSpecial = false;

        // show the appropriate panel
        $("#osunused, #oskeyboard, #osjoystick, #osspecial").css("display", "none");
        var typ = +dlgkey.children(".keytype").val();
        var code = +dlgkey.children(".keycode").val();
        var page;
        switch (typ)
        {
        default:
            // No PC input (or an unknown type).  If the key has a special
            // function (e.g., Night Mode), show the "special" page, otherwise
            // show the "unused" page.
            if (isSpecial) {
                page = $("#osspecial").css("display", "");
                $("#keytypeSpecial").addClass("selected");
            }
            else {
                page = $("#osunused").css("display", "");
                $("#keytypeUnused").addClass("selected");
            }

            // in any case, mark the "unused" button as selected - even if we
            // don't start out in this page, it's still the selected input type
            $("#unusedBtn").addClass("selected");
            break;
            
        case 1:  // joystick
            (page = $("#osjoystick")).css("display", "");
            $("#jsBtn" + code).addClass("selected");
            $("#keytypeJS").addClass("selected");
            break;

        case 2: // keyboard
        case 3: // media key
            (page = $("#oskeyboard")).css("display", "");
            $("#keycapBtn" + typ + "_" + code).addClass("selected");
            $("#keytypeKB").addClass("selected");
            break;
        }
        $("#keySelector > div").css("width", page.outerWidth() + "px");
    };
    $(".keymapping").click(keymappingClick);

    // select a joystick button
    function selectButton(type, code, dismiss)
    {
        // set the key type and code
        dlgkey.children(".keytype").val(type);
        dlgkey.children(".keycode").val("" + code).change();

        // dismiss the dialog if desired
        if (dismiss)
            dismissKeyDlg();
    }

    // handle keystrokes while the key dialog is showing
    $("html").on("keydown keyup", function(ev) {
        if (dlgkey && $("#keytypeKB").hasClass("selected"))
        {
            // If the key maps to one of our keycaps entries, select the key.
            // In order to match, the keycap entry has to have the same javascript
            // key code, and must either have no "jsloc" (key location) property,
            // or has a jsloc that matches the event location.  The location 
            // distinguishes among keys where the javascript code is shared by
            // multiple physical keys, such as keys on the numeric keypad and the
            // modifier keys that are mirrored on the left and right sides.
            var k = $.grep(jsKeyCaps[ev.which] || [], function(ele) {
                var eleloc = ele.jsloc;
                return typeof eleloc == "undefined" || eleloc == ev.originalEvent.location;
            });

            // if we found a key, select it
            if (k.length == 1)
            {
                // we found exactly one matching key - select it
                selectButton(k[0].keytype, k[0].keycode, true);
                ev.preventDefault();
                ev.stopPropagation();
            }
        }
        else
        {
            switch (ev.which)
            {
            case 32:
            case 13:
            case 27:
                // close the dialog on escape, space, or enter
                dismissKeyDlg();
                break;
            }
        }
    });

    // close the key dialog
    function dismissKeyDlg()
    {
        dlg.parent().css("display", "none");
        if (dlgkeylbl) dlgkeylbl.removeClass("openDlgRow");
        dlgkey = dlgkeylbl = null;
    }

    // dismiss the dialog on clicking outside it, but not on clicking within
    $("#keySelector > div").click(function() { event.stopPropagation(); });
    dlg.parent().click(function() { dismissKeyDlg(); });

    // on changing an IR command, update the display
    $("#buttonTab .keyIR .IRCommand").change(function(ev) {
        var idx = +$(this).val();
        $(this).parents(".keyIR").find(".label").text(idx == 0 ? "" : idx);
    });

    // set up the IR command selectors
    var irdlg = $("#IRCommandSelector");
    $("#buttonTab .keyIR").click(function(ev)
    {
        // remember who opened the dialog
        dlgkey = $(this);

        // get the hidden field with the IR command index
        var fld = dlgkey.find(".IRCommand");

        // prepare the list - if it's empty, show a message instead of the popup
        if (!prepIRCommandSelector(+fld.val(), function(ev) {
            ev.preventDefault();
            var idx = +$(this).data("idx");
            fld.val(idx).change();
        }))
        {
            alert("No IR commands have been configured yet. To associate an IR "
                  + "command with a button, set up the IR command first in the "
                  + "IR Remote Control section of the setup.");
            return;
        }

        // mark the label as active
        dlgkeylbl = dlgkey.parents("tr.buttonRow");
        dlgkeylbl.addClass("openDlgRow");

        // show the dialog
        irdlg.parent().css("display", "block");

        // position it below the field
        var ofs = dlgkeylbl.offset();
        var dlght = irdlg.outerHeight() + 24;
        var winht = window.innerHeight - $("#nav").outerHeight();
        var scrolly = $("html,body").scrollTop();
        var y = ofs.top + dlgkeylbl.height();
        irdlg.css("top", y + "px");

        // position it horizontally under the button
        ofs = dlgkey.offset();
        irdlg.css("left", ofs.left + "px");

        // make sure the bottom of the dialog is in view
        if (y + dlght > scrolly + winht)
            scrolly = y + dlght - winht;

        // but limit this so that the top stays in view
        if (scrolly > y)
            scrolly = y;

        // scroll here
        $("html,body").animate({ scrollTop: scrolly });
    });
    irdlg.parent().click(function() { dismissIRDlg(); });

    function dismissIRDlg()
    {
        irdlg.parent().css("display", "none");
        if (dlgkeylbl) dlgkeylbl.removeClass("openDlgRow");
        dlgkey = dlgkeylbl = null;
    }
});
    
   </script>
      
   <!-- TLC5940 setup --------------------------------------------------->
   <hr>
   <div class="section" data-name="TLC5940">
      <img src="tlc5940.png" class="sectionIcon">
      <b>TLC5940 (external PWM controller chip) setup</b>
      <a class="shower" href="#">What's this?</a>
      <div class="hider">
            The TLC5940 is an integrated circuit chip that you can connect
            to the KL25Z to add extra outputs for more feedback devices (lights,
            solenoids, motors, etc).  TLC5940 outputs have full PWM (Pulse
            Width Modulation) capabilities, allowing the software to control
            the brightness of an attached light or the speed of a motor.  The
            DIP version of this chip is no longer being manufactured, so you
            can't order them from most distributors, but they're still easy
            to find on eBay and elsewhere.
         <p>
            These chips let you go beyond the KL25Z's limited PWM capabilities.
            The KL25Z only has 10 PWM channels of its own, which isn't enough
            for most virtual pinball machines.  Each TLC5940 chip provides 16 PWM
            outputs, and you can connect two or more of the chips in a daisy chain
            to add almost unlimited outputs.  Only five GPIO pins are needed to
            control the whole chain.
         </p>
         <p>
            The Pinscape Expansion Boards use these chips to provide extra PWM
            outputs. You can also install them with your own custom wiring. The
            circuitry needed is outlined in the Build Guide.  The settings below
            configure the data signal connections between the KL25Z and the TLC5940's.
         </p>
      </div>

      <div class="expBoardAlt">
         The TLC5940 configuration is automatically set up for your expansion boards.
      </div>
      <div class="expBoardPin">
         <table class="inputs">
            <tr>
               <!-- the fixed width is a hack to get the two table column sets to line up -->
               <td style="width: 32ex;">Number of TLC5940 chips:</td>
               <td>
                  <input type="text" size=4 id="tlc_nchips">
               </td>
            </tr>
         </table>
         <table id="tlcPins" class="inputs" style="display: block;">
            <tr>
               <!-- the fixed width is a hack to get the two table column sets to line up -->
               <td td style="width: 32ex;" class="pinlabel">SI (serial data) output:</td>
               <td>
                  <span class="pinselect" id="tlc_si"
                    data-cfg="TLC5940.SIN" data-gpiotype="spi-mosi extern"
                    data-desc="TLC5940 SI" data-default="PTC6">
                  </span>
               </td>
               <td>Requires an <a href="#" class="spiHelp">SPI MOSI</a> output pin</td>
            </tr>
            <tr>
               <td class="pinlabel">SCLK (serial clock) output:</td>
               <td>
                  <span class="pinselect" id="tlc_si"
                    data-cfg="TLC5940.SCLK" data-gpiotype="spi-sclk extern"
                    data-desc="TLC5940 SCLK" data-default="PTC5">
                  </span>
               </td>
               <td>Requires an <a href="#" class="spiHelp">SPI SCLK</a> output pin</td>
            </tr>
            <tr>
               <td class="pinlabel">XLAT output:</td>
               <td>
                  <span class="pinselect" id="tlc_xlat"
                    data-cfg="TLC5940.XLAT" data-gpiotype="dig-out extern"
                    data-desc="TLC5940 XLAT" data-default="PTC10">
                  </span>
               </td>
            </tr>
            <tr>
               <td class="pinlabel">BLANK output:</td>
               <td>
                  <span class="pinselect" id="tlc_blank"
                    data-cfg="TLC5940.BLANK" data-gpiotype="dig-out extern"
                    data-desc="TLC5940 BLANK" data-default="PTC7">
                  </span>
               </td>
            </tr>
            <tr>
               <td class="pinlabel">GSCLK output:</td>
               <td>
                  <span class="pinselect" id="tlc_gsclk"
                    data-cfg="TLC5940.GSCLK" data-gpiotype="pwm tpm extern"
                    data-desc="TLC5940 GSCLK" data-default="PTA1">
                  </span>
               </td>
               <td>Requires a <a href="#" class="pwmHelp">PWM-capable output pin</a></td>
            </tr>
         </table>
      </div>
   </div>

   <script>
$("#tlc_nchips").change(function(ev)
{
    // show or hide the section as needed
    var active = +$(this).val() != 0;
    slideToggle($("#tlcPins"), active, loadingConfig ? 0 : 250, false);

    // Adjust the output ports, unless we're loading a config.  Don't
    // make any changes when loading, since we simply want to restore
    // the exact output port list in the config in this case.
    if (!loadingConfig)
        adjustOutputPorts(3);
});
   </script>

   <!-- TLC59116 setup --------------------------------------------------->
   <hr>
   <div class="section" data-name="TLC59116">
      <img src="tlc59116.png" class="sectionIcon">
      <b>TLC59116 (external PWM controller chip) setup</b>
      <a class="shower" href="#">What's this?</a>
      <div class="hider">
            The TLC59116 is an integrated circuit chip that you can connect
            to the KL25Z to add extra outputs for more feedback devices (lights,
            solenoids, motors, etc).  TLC59116 outputs have full PWM (Pulse
            Width Modulation) capabilities, allowing the software to control
            the brightness of an attached light or the speed of a motor.
         <p>
            These chips let you go beyond the KL25Z's limited PWM capabilities.
            The KL25Z only has 10 PWM channels of its own, which isn't enough
            for most virtual pinball machines.  Each TLC59114 chip provides 16 PWM
            outputs, and you can connect up to 14 of the chips.  Only three GPIO
            pins are required no matter how many of the chips are attached.
         </p>
         <p>
            The TLC59116 is a successor to the TLC5940 (see above) with a more
            modern design.  It's only available in a surface-mount (SMD) package,
            which makes it a little harder to work with than the traditional DIP
            form factor of the TLC5940NT.  This chip is <b>not</b> interchangeable
            with the TLC5940, even though it has a similar function, since it
            has a different physical pin layout and a different software interface.
         </p>
      </div>

      <div>
         <div id="tlc59116Disabled" style="margin-left: 4em;">
            Disabled - <a href="#">Show Settings</a>
         </div>
         <div id="tlc59116Settings">
            <div>
               <b>Attached chips by address:</b> <a class="shower" href="#">Explain</a>
               <div class="hider">
                  Each TLC59116 has its own unique address, set via the A3 A2 A1 A0 pins
                  on the chip: a pin wired to + voltage is a "1" and a pin wired to GND
                  is a "0".  Select the addresses of the chips attached to your system
                  according to how you wired the address pins.  Addresses 8 and 11
                  aren't shown because they're reserved for special purposes.
                  To disable support for this chip type entirely, un-check all of the
                  addresses to indicate that no chips are present.
               </div>
            </div>
            <div id="tlc59116_chipsEnabled">
               <div>
                  <label><input type="checkbox" data-address="0"> 0 (0000)</label>
                  <label><input type="checkbox" data-address="1"> 1 (0001)</label>
                  <label><input type="checkbox" data-address="2"> 2 (0010)</label>
                  <label><input type="checkbox" data-address="3"> 3 (0011)</label>
                  <label><input type="checkbox" data-address="4"> 4 (0100)</label>
               </div>
               <div>
                  <label><input type="checkbox" data-address="5"> 5 (0101)</label>
                  <label><input type="checkbox" data-address="6"> 6 (0110)</label>
                  <label><input type="checkbox" data-address="7"> 7 (0111)</label>
                  <label><input type="checkbox" data-address="9"> 9 (1001)</label>
                  <label><input type="checkbox" data-address="10"> 10 (1010)</label>
               </div>
               <div>
                  <label><input type="checkbox" data-address="12"> 12 (1100)</label>
                  <label><input type="checkbox" data-address="13"> 13 (1101)</label>
                  <label><input type="checkbox" data-address="14"> 14 (1110)</label>
                  <label><input type="checkbox" data-address="15"> 15 (1111)</label>
               </div>
            </div>

            <div>
               <b>GPIO pin assignments:</b>
            </div>
            <table id="tlc59116Pins" class="inputs" style="display: block;">
               <tr>
                  <td class="pinlabel" style="width: 12ex;">SDA:</td>
                  <td>
                     <span class="pinselect" id="tlc59116_sda"
                        data-cfg="TLC59116.SDA" data-gpiotype="dig-out extern"
                       data-desc="TLC59116 SDA" data-default="PTC6">
                     </span>
                  </td>
               </tr>
               <tr>
                  <td class="pinlabel">SCL:</td>
                  <td>
                     <span class="pinselect" id="tlc59116_scl"
                        data-cfg="TLC59116.SCL" data-gpiotype="dig-out extern"
                       data-desc="TLC59116 SCL" data-default="PTC5">
                     </span>
                  </td>
               </tr>
               <tr>
                  <td class="pinlabel">RESET:</td>
                  <td>
                     <span class="pinselect" id="tlc59116_reset"
                        data-cfg="TLC59116.RESET" data-gpiotype="dig-out extern"
                       data-desc="TLC59116 RESET" data-default="PTC10">
                     </span>
                  </td>
               </tr>
            </table>
         </div>
      </div>
   </div>

   <script>
var tlc59116ChangeCheck, tlc59116Hider;
$("#tlc59116Disabled a").click(function(ev) {
    $("#tlc59116Disabled").hide();
    slideToggle("#tlc59116Settings", true, 250, false);
    ev.preventDefault();
});
$("#tlc59116_chipsEnabled input").change(function(ev)
{
    // queue a count change check
    if (!tlc59116ChangeCheck)
    {
        var lc = loadingConfig;
        tlc59116ChangeCheck = setTimeout(function()
        {
            // the timeout has fired
            tlc59116ChangeCheck = undefined;

            // count up the enabled chips
            var n = $("#tlc59116_chipsEnabled input:checked").length;

            // hide the settings if nothing's selected
            if (n == 0)
            {
                // remove any previous pending timeout
                if (tlc59116Hider)
                    clearTimeout(tlc59116Hider);

                // If we're loading the config, do this immediately; otherwise
                // wait a few seconds in case they're going to check another
                // item immediately to replace the un-checked item
                tlc59116Hider = setTimeout(function()
                {
                    // if everything's still un-checked, hide the settings
                    tlc59116Hider = undefined;
                    if ($("#tlc59116_chipsEnabled input:checked").length == 0)
                    {
                        slideToggle($("#tlc59116Settings"), false, lc ? 0 : 250, false);
                        $("#tlc59116Disabled").show();
                    }
                }, lc ? 0 : 7500);
            }

            // Adjust the output ports, unless we're loading a config.  Don't
            // make any changes when loading, since we simply want to restore
            // the exact output port list in the config in this case.
            if (!lc)
                adjustOutputPorts(6);
        }, 1);
    }
});
   </script>

   <!-- 74HC595 setup --------------------------------------------------->
   <hr>
   <div class="section" data-name="74HC595">
      <img src="74hc595.png" class="sectionIcon">
      <b>74HC595 (external digital out chip) setup</b>
      <a class="shower" href="#">What's this?</a>
      <div class="hider">
         The 74HC595 is an integrated circuit chip that can be connected
         to the KL25Z to add more digital outputs for feedback devices like
         solenoids and replay knockers.  "Digital" means that the outputs
         are strictly on/off: the software can't modulate intensity or brightness.
         Digital outputs are ideal for feedback devices that inherently need only
         on/off control, such as solenoids.

         <p>
            The Pinscape "Chime Board" uses this
            chip to add outputs for replay knockers and chime units.  You can also
            add these chips with your own custom wiring; the circuitry is described
            in the Build Guide.  The settings below let you configure the data
            connections between the KL25Z and the 74HC595's.
         </p>
      </div>

      <div class="expBoardAlt">
         The 74HC595 configuration is automatically set up for your chime boards.
      </div>
      <div class="expBoardPin">
         <table class="inputs">
            <tr>
               <!-- the fixed width is a hack to get the two table column sets to line up -->
               <td style="width: 32ex;">Number of 74HC595 chips:</td>
               <td>
                  <input type="text" size=4 id="hc595_nchips">
               </td>
            </tr>
         </table>
         <table id="hcPins" class="inputs" style="display: block;">
            <tr>
               <!-- the fixed width is a hack to get the two table column sets to line up -->
               <td td style="width: 32ex;" class="pinlabel">SI (serial data) output:</td>
               <td>
                  <span class="pinselect" id="hc595_si"
                    data-cfg="HC595.SIN" data-gpiotype="dig-out extern"
                    data-desc="74HC595 SI" data-default="PTA5">
                  </span>
               </td>
            </tr>
            <tr>
               <td class="pinlabel">SCLK (serial clock) output:</td>
               <td>
                  <span class="pinselect" id="hc595_si"
                    data-cfg="HC595.SCLK" data-gpiotype="dig-out extern"
                    data-desc="74HC595 SCLK" data-default="PTA4">
                  </span>
               </td>
            </tr>
            <tr>
               <td class="pinlabel">LATCH output:</td>
               <td>
                  <span class="pinselect" id="hc595_latch"
                    data-cfg="HC595.LATCH" data-gpiotype="dig-out extern"
                    data-desc="74HC595 LATCH" data-default="PTA12">
                  </span>
               </td>
            </tr>
            <tr>
               <td class="pinlabel">ENA output:</td>
               <td>
                  <span class="pinselect" id="hc595_ena"
                    data-cfg="HC595.ENA" data-gpiotype="dig-out extern"
                    data-desc="74HC595 ENA" data-default="PTD4">
                  </span>
               </td>
            </tr>
         </table>
      </div>
   </div>

   <script>
$("#hc595_nchips").change(function(ev)
{
    // show or hide our pin setup section as appropriate
    var active = +$(this).val() != 0;
    slideToggle($("#hcPins"), active, loadingConfig ? 0 : 250, false);

    // Add or remove output ports for the 74HC595 chips (type 4).  Skip
    // this when loading a config, since we want to simply restore the
    // exact output list from the saved config in this case.
    if (!loadingConfig)
        adjustOutputPorts(4);
});
   </script>

   <!-- Night Mode ------------------------------------------------------>
   <hr>
   <div class="section" data-name="Night Mode">
      <a name="nightmode"></a>
      <img src="nightModeSection.png" class="sectionIcon">
      <b>Pinscape After Dark.</b>  You can set up a button or switch to
      activate <b>Night Mode</b>, which disables the feedback device outputs
      that you designate as noise-makers.  This lets you play during late-night
      hours without disturbing your party-pooper housemates and neighbors.
      <a href="#" class="shower">Details</a>

      <div class="hider">
         <ul>
            <li>Select an <a href="#buttonSection">input button</a> to turn
            Night Mode on and off.  Wire this like any other button.
            
            <li>You'll probably want to configure the button you select
            for "No PC Input" in the <a href="#buttonSection">button setup</a>,
            but you can have it send a keystroke if that's useful to you for
            some reason.
            
            <li>If you don't want to wire a physical button for this, just
            set the button number to 0 (zero).  You can still control Night
            Mode with the NightMode.exe program on the PC (it's in your
            Pinscape Setup Tool folder).

            <li>You can also optionally select an output port to serve as an
            indicator light, so that you can tell when night mode is turned on.
            If you don't need an indicator, just set this to 0.  If you do assign
            a port, you should leave it unassigned in your DOF port layout.
         </ul>
      </div>

      <div id="nightModeOptions" style="margin: 1em 4em;">
         <table class="inputs">
            <tr>
               <td>
                  Button input number:
               </td>
               <td>
                  <input id="nightModeButtonNo" size="4" style="margin: 0px 1em;">
                  <span style="padding-left: 2em; font-style: italic;">0 = no input button assigned</span>
               </td>
            </tr>
            <tr id="nightModeButtonShift">
               <td></td>
               <td>
                  <label><input type="checkbox"> Use shifted button</label> (see <a href="#buttonSection">Button Setup</a>)
               </td>
            </tr>
            <tr>
               <td>
                  Button type:
               </td>
               <td>
                  <table class="radio" style="display: inline-block; vertical-align: middle; margin: 1em 0px;">
                     <tr id="nightModeButtonTypeRow">
                        <td>
                           <label>
                              <img src="pushButton.png"><br>
                              <input type="radio" name="nightModeButtonType" value="1">
                              Momentary button
                              <br>(Toggles mode when pushed)
                           </label>
                        </td>
                        <td>
                           <label>
                              <img src="toggleSwitch.png"><br>
                              <input type="radio" name="nightModeButtonType" value="2">
                              On/off switch
                              <br>&nbsp;
                           </label>
                        </td>
                     </tr>
                  </table>
               </td>
            </tr>
            <tr>
               <td>
                  Indicator lamp output port:
               </td>
               <td>
                  <input id="nightModeOutputNo" size="4" style="margin: 0px 1em;">
                  <span style="padding-left: 2em; font-style: italic;">0 = no indicator output</span>
               </td>
            </tr>
         </table>
      </div>
      
   </div>

   <script>

// on changing the button number, update the icon display in the button setup section
$("#nightModeButtonShift input").change(function() { updateNightModeButton(); });
$("#nightModeButtonNo").change(function() { updateNightModeButton(); });
function updateNightModeButton()
{
    var n = +$("#nightModeButtonNo").val();
    $("#buttonTab .buttonCol").removeClass("nightMode");
    if (n)
    {
        var shifted = $("#shiftButton").val() != 0 && $("#nightModeButtonShift input").prop("checked");
        $("#buttonRow" + n + " .buttonCol." + (shifted ? "shifted" : "primary")).addClass("nightMode");
        ButtonTabUpdate.touch($("#buttonRow" + n));
    }
}

$("#nightModeButtonTypeRow input").change(function() {
    showHideNightModeButtonShift();
    updateNightModeButton();
});
$("#nightModeOutputNo").change(function()
{
    var n = +$(this).val();
    $("#outputTab .nightModeRemark").remove();
    if (n != 0) {
        $("#outputTab tr .outPortRemarks").eq(n-1).append(
            "<span class=\"nightModeRemark\" title=\"This is the Night Mode indicator lamp port\">"
            + "<a href=\"#nightmode\">"
            + "<img src=\"nightModeSmall.png\">"
            + "</a>"
            + "</span>");
    }
});

function showHideNightModeButtonShift()
{
    // the night mode button can only be on a shifted button if the shift
    // button is enabled AND the night mode button is in toggle mode
    var toggleMode = ($("#nightModeOptions input:radio[name=nightModeButtonType]:checked").val() == 1);
    $("#nightModeButtonShift").toggle($("#shiftButton").val() != 0 && toggleMode);

    // un-check the shift button if it's no longer valid
    if (!toggleMode)
        $("#nightModeButtonShift input").prop("checked", false).change();
}
      
   </script>


   <!-- Output controller setup ----------------------------------------->
   <hr>
   <div class="section" data-name="Output Ports">
      <a name="outputSection"></a>
      <img src="outputSection.png" class="sectionIcon">
      <b>Feedback device outputs.</b>  Pinball software on the PC can control
      output devices connected to the KL25Z to create special effects during play,
      such as tactile feedback and lighting displays.  The PC software uses the
      <b>port numbers</b> in the list below to address the outputs.  Use these
      port numbers when you set up your <a class="dofconfigtool">DOF configuration</a>.
      For each port, you can select the physical output pin that the port is wired to.

      <div>
         <a href="#" id="btnOutputTest" class="button">Test Outputs</a>
      </div>

      <div>
         <table id="outputTab">
            <tr>
               <th></th>
               <th>Port No.</th>
               <th>Type</th>
               <th>Location</th>
               <th>Pin</th>
               <th>Port</th>
               <td></th>  <!-- pin warnings -->
               <th></th>  <!-- pin remarks -->
               <th>Options [<a href="#" class="outPortOptionsHelp">?</a>]</th>
               <th>Description</th>
         </table>
      </div>

   </div>

   <script>

// show the button tester
$("#btnOutputTest").click(function(ev)
{
    ev.preventDefault();
    var cfgMem = normalizeConfig(configFromUI());
    var cfgDev = normalizeConfig(config);
    if (!valEq(cfgMem.outputs, cfgDev.outputs))
    {
        if (!window.external.YesNoDialog(
            "You've made changes to the output port settings that you haven't "
            + "programmed into the KL25Z yet. The tester window will reflect "
            + "the current device settings, not your new unsaved changes. "
            + "If you want to test your new settings, click \"Program KL25Z\" "
            + "before proceeding to the tester window."
            + "\r\n\r\n"
            + "Do you want to open the tester anyway?"))
            return;
    }

    // show the dialog
    window.external.ShowOutputTester(CPUID);
});


// Set up the output port table
$(function() {
    var rows = [];
    for (var i = 1 ; i <= MaxOutputs ; ++i)
    {
        // In each row:
        //   - dispPinType is a derived display name describing the pin type
        //   - dispPinName is a derived display name describing the pin name
        //   - pinval is the internal pin value.  For GPIO pins, this uses the
        //     standard PTxn notation.  For external chip pins, it's simply
        //     the port number, numbering from 0 for the first chip's first
        //     output.
        //   - pintype is the internal pin type, per the USB config messages
        //     (0=disabled, 1=PWM, etc)
        rows.push("<tr id=\"outPortRow" + i + "\" class=\"outPortRow\" data-idx=\"" + i + "\" "
                  +  "data-desc=\"Output Port " + i + "\">"
                  +   "<td class=\"rowControls\">"
                  +      "<span class=\"addRow\" title=\"Insert a new output port here\"></span>"
                  +      "<span class=\"delRow\" title=\"Delete this output port\"></span>"
                  +      "<span class=\"moveRow\" title=\"Move this output port\"></span>"

// select - disable for now: still working out the details, but might add later
//                +      "<span class=\"selectRow\" title=\"Select this output port (use SHIFT or CTRL "
//                +           "to select multiple ports to move or delete)\"></span>"

                  +   "</td>"
                  +   "<td class=\"pinlabel\">" + i + "</td>"
                  +   "<td><span class=\"dispPinType\"></span></td>"
                  +   "<td class=\"dispPinLoc\"></td>"
                  +   "<td class=\"dispPinHeader\"></td>"
                  +   "<td class=\"outPortPin\">"
                  +      "<input class=\"dispPinName\" type=\"text\" size=\"12\" readonly>"
                  +      "<input class=\"pintype\" type=\"hidden\">"
                  +      "<input class=\"pinval\" type=\"hidden\">"
                  +   "</td>"
                  +   "<td>"
                  +      "<span class=\"pinwarn\"><img src=\"pinwarn.png\"></span>"
                  +   "</td>"
                  +   "<td class=\"outPortRemarks\"></td>"
                  +   "<td class=\"outPortOptions\">"
                  +      "<input class=\"pinflags\" type=\"hidden\">"
                  +      "<img src=\"NoisyOff.png\" class=\"outPortNoisy\" data-mask=\"2\" "
                  +         "title=\"Noisy device: disable this port when Night Mode is engaged\">"
                  +      "<img src=\"GammaOff.png\" class=\"outPortGamma\" data-mask=\"4\" "
                  +         "title=\"Use gamma correction on this port (suitable for lamps and LEDs)\">"
                  +      "<img src=\"ActiveLowOff.png\" class=\"outPortLow\" data-mask=\"1\" "
                  +         "title=\"Active low port: port connects to ground (0V) when ON\">"
                  +   "</td>"
                  +   "<td>"
                  +      "<input class=\"outPortDesc\" type=\"text\" size=\"20\">"
                  +   "</td>"
                  + "</tr>");
    }

    // add a last row with just a "+" control to add a row at the end
    rows.push("<tr class=\"outPortRow\" data-idx=\"end\" id=\"lastOutPortRow\">"
              +   "<td class=\"rowControls\">"
              +      "<span class=\"addRow\" title=\"Add a new output port\"></span>"
              +   "</td>"
              +   "<td></td>"
              +   "<td></td>"
              +   "<td></td>"
              + "</tr>");

    // insert the rows
    $("#outputTab").append(rows);

    // add change handlers for the pin type and value
    var typeNames = ["Disabled", "PWM", "Digital", "PWM", "Digital", "Virtual", "PWM"];
    $(".outPortRow .pintype, .outPortRow .pinval").change(function()
    {
        // get the row (the .outPortRow parent)
        var row = $(this).parents(".outPortRow");

        // get the internal pin type value and corresponding display name
        var typ = row.find(".pintype");
        var typval = boundsCheck(+typ.val(), typeNames);
        var typeDisp = typeNames[typval];
        
        // get the internal pin value
        var pin = row.find(".pinval").val();

        // presume the row pin type will empty
        row.data("pintype", "");

        // update the displayed pin name
        var pinDisp = "";
        var locDisp = "";
        var hdrDisp = "";
        var opts = 0xff;
        switch(typval)
        {
        case 1: // PWM Out (GPIO)
            locDisp = "KL25Z";
            hdrDisp =  pinToJumper(pin);
            pinDisp = pin;
            row.data("pintype", "pwm");
            break;
    
        case 2: // Digital Out (GPIO)
            locDisp = "KL25Z";
            hdrDisp = pinToJumper(pin);
            pinDisp = pin;
            row.data("gpiotype", "dig-out");
            opts &= ~4;  // alpha isn't applicable to digital outs
            break;

        case 3: // TLC5940
            locDisp = "TLC5940 #" + (Math.floor(pin/16)+1);
            hdrDisp = [28, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15][pin % 16];
            pinDisp = "Out " + (pin % 16);
            opts &= ~1;        // active low isn't applicable to TLC5940 outputs
            break;

        case 4: // 7HC595
            locDisp = "74HC595 #" + (Math.floor(pin/8)+1);
            hdrDisp = [15, 1, 2, 3, 4, 5, 6, 7][pin % 8];
            pinDisp = "Out " + (pin % 8);
            opts &= ~(1 | 4);  // active low and gamma aren't applicable to 74HC595 outputs
                               // (gamma is disabled because these are inherently digital outs)
            break;

        case 5: // Virtual
            locDisp = "None";
            hdrDisp = "";
            pinDisp = "";
            opts &= ~(1 | 2 | 4);  // gamma, active low, noisy aren't applicable to virtual outputs
            break;

        case 6: // TLC59116
            locDisp = "TLC59116 @" + ((pin >> 4) & 0x0F);
            hdrDisp = [6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23][pin & 0x0F];
            pinDisp = "Out " + (pin & 0x0F);
            opts &= ~1;        // active low isn't applicable to TLC59116 outputs
            break;
        }

        // if there's an expansion board alias, apply it
        var alias = outPortAlias[typval + "." + pin];
        if (alias)
        {
            // set the alias name
            alias = alias.split("|");
            pinDisp = alias[0];
            typeDisp = alias[1];
            locDisp = alias[2];
            hdrDisp = alias[3];
        }

        // set the name and type strings
        row.find(".dispPinLoc").text(locDisp);
        row.find(".dispPinName").val(pinDisp);
        row.find(".dispPinHeader").text(hdrDisp);
        row.find(".dispPinType").text(typeDisp);

        // enable/disable option checkboxes
        row.find(".outPortOptions img").each(function() {
            var img = $(this);
            var mask = img.data("mask");
            var vis = !!(mask & opts);
            img.toggle(vis);
            if (!vis)
                img.attr("src", img.attr("src").replace(/On|Off/, "Off"));
        });
    });

    // change handler for the port options internal data field
    $("#outputTab .outPortRow .pinflags").change(function() {
        var self = $(this);
        var flags = +self.val();
        self.parent().find("img").each(function() {
            var img = $(this);
            var state = (flags & img.data("mask")) != 0 ? "On" : "Off";
            img.attr("src", img.attr("src").replace(/(On|Off)/, state));
        });
    });

    // change handlers for the port options icons
    $("#outputTab .outPortRow .outPortOptions img").click(function(ev) {
        var img = $(this);
        var mask = +img.data("mask");
        var flagfield = img.parents(".outPortOptions").children(".pinflags");
        flagfield.val(+flagfield.val() ^ mask).change();
    });

    // insert a row
    $("#outputTab .addRow").click(function(ev) {
        ev.stopPropagation();
        insertOutputs($(this).parents(".outPortRow"), 1);
    });

    // delete a row
    $("#outputTab .delRow").click(function(ev)
    {
        // ask for confirmation, and delete the row if confirmed
        ev.stopPropagation();
        if (window.external.YesNoDialog(
            "Are you sure you want to delete this output port?"))
            deleteOutputs($(this).parents(".outPortRow"), 1);
    });

    // select a row
    $("#outputTab .selectRow").click(function(ev)
    {
        var self = $(this);
        var row = self.parents(".outPortRow");
        if (ev.shiftKey)
        {
            // shift key - extend selection to include all rows from here to
            // first and last selected rows
            var allsel = row.parent().children(".selected");
            var first = allsel.first(), firstidx = first.data("idx");
            var last = allsel.last(), lastidx = last.data("idx");
            var idx = +row.data("idx");

            // if the first selected row is before us, extend from first to here
            if (firstidx && +firstidx < idx)
                row.parent().children().slice(+firstidx, idx).addClass("selected");

            // if the last selected row is after us, extend from here to last
            if (lastidx && +lastidx > idx)
                row.parent().children().slice(idx, +lastidx).addClass("selected");

            // in any case, definitely select this row
            row.addClass("selected");
        }
        else if (ev.ctrlKey)
        {
            // toggle this row only
            row.toggleClass("selected");
        }
        else
        {
            // toggle this row and deselect all other rows
            var sel = row.hasClass("selected");
            $("#outputTab .outPortRow").removeClass("selected");
            row.toggleClass("selected", !sel);
        }
        return false;
    }).mousedown(function(ev) {
        // prevent text selection when clicking in this control
        ev.preventDefault();
    });

    // move a row
    $("#outputTab .moveRow").mousedown(function(ev)
    {
        // get the row and table
        var row = $(this).parents(".outPortRow");
        var tab = $("#outputTab");

        // set up a copy of the row to show during the move, wrapped in a
        // position:absolute div so that we can have it track the mouse
        var mover = $("<div class=\"rowMover\"></div>");
        $("body").append(mover);
        mover.append("<td><span class=\"moveIcon\"></span></td>");
        mover.append(row.children().slice(1).clone());
        var left = tab.offset().left;

        // copy widths and text alignments
        for (var dst = mover.children().first(), src = row.children().first(), i = 0 ;
             src.length ;
             src = src.next(), dst = dst.next(), ++i)
        {
            // copy the width, padding, and alignment
            dst.css("width", src.outerWidth() + "px");
            dst.css(src.css(["padding-left", "padding-right", "text-align"]));

            // ... except for the first column, where we force right alignment, since
            // we substitute our own "moving" icon in place of the normal row controls
            if (i == 0)
                dst.css("text-align", "right"); // add if "select row" icon is present: .css("padding-right", "22px");
        }

        var td = $(row).children("td").eq(1);
        var ofs = row.offset();
        mover.css({
            "left": left + "px",
            "top": td.offset().top + "px"
        });

        var strut = $(
            "<tr data-idx=\"strut\">"
            +   "<td style=\"height:" + mover.outerHeight() + "px;\">"
            +   "</td>"
            + "</tr>");
        strut.insertBefore(row);

        // hide the original row while dragging it
        row.css("display", "none");

        // monitor entering and leaving rows as the mouse moves to show
        // where the drop will go
        var target = $();
        $("#outputTab .outPortRow").on("mousemove.outputRowMover", function(ev)
        {
            // ignore any events in the row being dragged
            if (this == row[0]) return;

            // Figure which side of the row we're on.  If we're in the top half,
            // move the dragged row before the target row; otherwise move it after
            // the target row.  Exception: we can't go past the last row.
            var self = $(this);
            var ofs = self.offset();
            var newTarget = (ev.pageY < ofs.top + self.outerHeight()/2)
                            || self.data("idx") == "end" ? self : self.next();

            // skip the fake "strut" row and the original row
            while (newTarget[0] == row[0] || newTarget.data("idx") == "strut")
                newTarget = newTarget.next();

            if (newTarget[0] != target[0])
            {
                // remove any previous target highlighting and highlight the new target row
                target = newTarget;
                strut.insertBefore(target);
                var top = strut.offset().top;

                // move the on-screen drag row to track the mouse
                mover.css({"left": left + "px", "top": top + "px"});
            }
        });

        // trigger an immediate enter on the next row if it's visible
        if (row.next().css("display") != "none")
            row.next().mouseover();
        else
            $("#outputTab .outPortRow").last().mouseover();

        var mousex, mousey;
        $(":root").on("mousemove.outputRowMover", function(ev) {
            mousex = ev.pageX;
            mousey = ev.pageY;
        });
        var scrollTimer = setInterval(function() {
            var doc = $("html,body");
            var sy = doc.scrollTop();
            var ht = window.innerHeight - $("#nav").outerHeight();
            var adj = 16;
            if (mousey < sy + adj) {
                doc.scrollTop(sy - 16);
                mousey = 0;
            }
            else if (mousey > sy + ht - adj) {
                mousey = 100000;
                doc.scrollTop(sy + 16);
            }
        }, 100);

        // monitor mouse-button-up anywhere on the document to end the drag
        $(":root").on("mouseup.outputRowMover", function(ev)
        {
            // remove all target highlighting
            strut.remove();

            // remove the on-screen drag row
            mover.remove();

            // restore visibility to the original row
            row.css("display", "");

            // move the row
            if (target.length)
                moveOutputs(row, target, 1);

            // remove the drag monitor events
            $(":root, #outputTab .outPortRow").off(".outputRowMover");

            // remove the scroll timer
            clearInterval(scrollTimer);
        });

        ev.preventDefault();
        ev.stopPropagation();
        return false;
    });
});



// Adjust the output ports for a change in peripheral chips.  This is
// for peripheral chips that provide output ports (TLC5940, TLC59116,
// 74HC595).  We'll adjust the output array by adding new ports if chips
// have been added, or removing existing ports for chips that are no
// longer present.
//
// If 'pintype' is provided, we'll only apply changes for that type.
// The type is the USB port setup message type: 3=TLC5940, 4=74HC595,
// 6=TLC59116.  If 'pintype' is omitted, we'll update all types.
var adjustOutputPorts = (function()
{
    // Set up an internal table of the factory ports, so that we can
    // find the flags for a given factory port
    var factoryOutputs = { };
    $.each(expansionBoardFactoryConfig.output, function(k, v) {
        factoryOutputs[v.port.type + "." + v.port.pin] = v;
    });

    // list of pending updates
    var pending;

    // main handler - queue a deferred update
    return function(pintype)
    {
        // If we don't already have a pending operation, queue one up.
        // Set it to run in a couple of seconds, to allow for grouping
        // multiple UI changes.
        if (!pending) {
            pending = { };
            setTimeout(go, 1000);
        }

        // Add this pintype to the pending list.  If no pintype was
        // provided, add them all.
        if (pintype)
            pending[pintype] = true;
        else
            pending[3] = pending[4] = true;
    };

    // perform pending updates
    function go()
    {
        // mark for deletion ports for a given chip that are no longer accessible 
        function markDelPorts(pintype, keep)
        {
            // mark for deletion each row that refers to a non-existent port on this chip
            var ports = { };
            for (var row = $("#outputTab .outPortRow").first() ; row.data("idx") != "end" ; row = row.next())
            {
                // if this row is for a non-existent port, delete it
                var del = false;
                if (row.find(".pintype").val() == pintype)
                {
                    // note the existing port
                    var portno = +row.find(".pinval").val();
                    ports[portno] = true;
                    
                    // delete it if it's no longer present
                    if (!keep(portno))
                        row.data("delete", true);
                }
            }
        
            // return the port list
            return ports;
        }
        
        // insert new ports as needed
        function insPorts(ports, pintype, nports, flags, indexToPortNo)
        {
            // if no port number mapping function was provided, the port number
            // simply maps 1:1 to the index
            if (!indexToPortNo) 
                indexToPortNo = function(n) { return n; };

            // Insert ports that aren't already present
            for (var i = 0 ; i < nports ; ++i)
            {
                // get the port number at this index
                var portno = indexToPortNo(i);

                // insert an output row in the UI if it's not already there
                if (!ports[portno])
                    newPortList.push({pintype: pintype, pinval: portno, pinflags: flags});
            }
        }

        // get the number of each chip
        var ntlc = +$("#tlc_nchips").val();
        var nhc = +$("#hc595_nchips").val();

        // The TLC59116 chips are enabled individually by address.  Get
        // a list of the checked boxes for enabled chips.
        var ck59116 = $("#tlc59116_chipsEnabled input:checked");

        // Build a list of the enabled chips by address, and all of the
        // ports on the enabled chips by encoded address:pin value.
        var chips59116 = [], ports59116 = { };
        ck59116.each(function()
        {
            // get the chip address from the checkbox
            var addr = +$(this).data("address");

            // add the chip address to the list of enabled chips
            chips59116.push(addr);

            // Add all of the pins to the list of enabled pins.  The
            // pins are encoded with the chip address in the high four
            // bits and the pin number in the low four bits.
            for (var i = 0, addrMask = addr << 4 ; i < 16 ; ++i)
                ports59116[addrMask | i] = true; 
        });
        var n59116 = ck59116.length;
        
        // delete outputs for each chip that are no longer needed
        var tlcPorts = pending[3] ? markDelPorts(3, function(n) { return n < ntlc*16; }) : null;
        var hcPorts = pending[4] ? markDelPorts(4, function(n) { return n < nhc*8; }) : null;
        var tlc59116Ports = pending[6] ? markDelPorts(6, function(n) { return ports59116[n]; }) : null;
        
        // apply deletions
        deleteOutputs();
        
        // HACK: If the expansion board configuration is selected, mark
        // any new 74HC595 ports as "noisy".  The expansion boards use
        // these ports only on the chime boards, and these boards are
        // specialized for driving solenoids, and solenoids are pretty
        // much only used in virtual pinball machines for tactile feedback
        // devices that make noise... therefore it's safe to assume that
        // these outputs will be noisy.  It would be nicer to have an
        // abstract and extensible way of handling default flags for new
        // ports, but so far this is the only situation where we need any
        // flags at all, and as long as that's true it's simpler to just
        // treat it as the special case it is.
        var hcFlags = 0;
        if ($("input:radio[name=hardwareType]:checked").val() == 1)
            hcFlags = 0x02;  // noisy

        // generate the list of new ports we need
        var newPortList = [];
        if (pending[3]) insPorts(tlcPorts, 3, ntlc*16, 0);
        if (pending[4]) insPorts(hcPorts, 4, nhc*8, hcFlags);
        if (pending[6]) insPorts(tlc59116Ports, 6, n59116*16, 0, function(n)
        {
            // construct the pin address: the high four bits are the chip
            // address for the n/16th chip, and the low four bits are the
            // port number n%16
            return (chips59116[n >> 4] << 4) | (n & 0x0F);
        });

        // insert the batch of new outputs into the table
        if (!insertOutputs($("#lastOutPortRow"), newPortList))
            alert("You've reached the maximum number of output ports. There aren't "
                  + "enough slots to add all of the ports for the new device(s) you "
                  + "just added, so none have been added.  You might still be able "
                  + "to add some of the new ports manually, and you can also reassign "
                  + "any unused ports on other devices to the new device(s).");

        // adjust the active/inactive status for the peripheral chip connections
        adjustPeripheralPins(pending[3], pending[4], pending[6]);

        // update pin warnings
        updatePinWarnings();

        // we no longer have work pending
        pending = undefined;
    }
})();

function adjustPeripheralPins(tlc5940, hc595, tlc59116)
{
    // activate or deactivate the TLC5940 pins, if desired
    if (tlc5940)
        $("#tlcPins .pinselect").data("active", $("#tlc_nchips").val() != 0);

    // likewise the 74HC595 pins
    if (hc595)
        $("#hcPins .pinselect").data("active", $("#hc595_nchips").val() != 0);

    // and the TLC59116 pins
    if (tlc59116)
        $("#tlc59116Pins .pinselect").data("active", $("#tlc59116_chipsEnabled input:checked").length != 0);
}

// Insert/delete output ports
var insertOutputs, deleteOutputs, moveOutputs, appendOutputs;
(function() {

    // Insert one or more output port rows before the given row.  Returns
    // true on success, false if there's not room for the added rows.  We
    // check for room before adding any rows, so no changes are made if
    // the insertion fails.
    insertOutputs = function(before, numOrVals)
    {
        // Determine if the caller provided a number of rows or an array of values
        // to insert.  If no value array was provided, the default is
        // type 5 (virtual).
        var num = 1, val = [];
        var virtual = { pintype: 5 };
        if (typeof numOrVals == "number") {
            num = numOrVals;
        }
        else if ($.isArray(numOrVals)) {
            val = numOrVals;
            num = val.length;
        }
        else if (typeof numOrVals == "object") {
            val = [numOrVals];
        }

        // make sure the last 'num' rows are free
        var rows = $("#outputTab .outPortRow");
        for (var i = 0, cur = rows.last().prev() ; i < num ; ++i, cur = cur.prev())
        {
            // if this row is in use, we don't have room for the insertion
            if (cur.find(".pintype").val() != 0)
                return false;
        }

        // note the insertion point
        var idx = before.data("idx");

        // if we're inserting after the last row, the true insertion point
        // is the first unused row
        if (idx == "end")
        {
            // find the first free row
            before = findFreeRow();
        }
        else
        {
            // Set up pointers for moving rows.  We've already backed up
            // 'cur' by 'num' rows from the end, so it's our source pointer;
            // our destination pointer is the last row (actually the second
            // to last, since the last is the fake row for the "add a row at
            // the end" control).
            var src = cur;
            var dst = rows.last().prev();

            // Move rows until we reach the 'before' row
            for ( ; ; src = src.prev(), dst = dst.prev())
            {
                // if this row is in use, move it
                copyRow(src, dst);
                
                // if we just copied the 'before' row, we're done
                if (src.data("idx") == idx)
                    break;
            }
        }
        
        // populate the new rows
        for (var i = 0 ; i < num ; ++i, before = before.next())
            setRow(before, i < val.length ? val[i] : virtual);
        
        // fix up the table for the insertion
        fixUpTable();

        // success
        return true;
    };

    // Append outputs to the end of the table, up to and including
    // the given row number.  Sets each new output to a virtual port.
    appendOutputs = function(row)
    {
        // go through rows starting at row 1, and set each
        // unused output through the given row to "virtual"
        var rows = $("#outputTab .outPortRow");
        for (var i = 0 ; i < row ; ++i)
        {
            // get the row
            var cur = rows.eq(i);

            // if it's the special last row, we're done
            if (cur.data("idx") == "end")
                break;

            // if the pin type is zero, change this to a virtual row
            if (cur.find(".pintype").val() == 0)
            {
                cur.find(".pintype").val(5).change();
                cur.find(".pinval").val(0);
                cur.find(".pinflags").val(0);
            }
        }

        // fix up for the deletion
        fixUpTable();
    };

    // Delete one or more output rows starting with the given row.
    //
    // If called with no arguments, we'll instead delete all rows
    // with data("delete") in the TR element.  This is much more
    // efficient for deleting a batch of rows, since we only have
    // make one pass through the table.
    deleteOutputs = function(row, num)
    {
        var rows = $("#outputTab .outPortRow");
        var src, dst;

        // check if we're deleting a given block of rows or rows
        // marked with data("delete")
        if (row)
        {
            // deleting a block - note the starting row index
            var delidx = row.data("idx");
            
            // set up pointers to move items down by 'num' rows
            src = rows.eq(delidx - 1 + num);
            dst = rows.eq(delidx - 1);
            
            // move items down
            for ( ; src.data("idx") != "end" && src.find(".pintype").val() != 0 ;
                  src = src.next(), dst = dst.next())
                copyRow(src, dst);
            
            // set the newly unused rows at the end to 'disabled'
            for (var i = 0 ; i < num ; ++i, dst = dst.next())
                setRow(dst, {pintype: 0});

        }
        else
        {
            // Delete all rows marked with data("delete").
            // Scan the rows, stopping when we reach the end or the first unused row.
            src = dst = rows.first();
            for (src = dst = rows.first() ; src.data("idx") != "end" ; src = src.next())
            {
                // if this row isn't marked for deletion, copy it
                if (src.data("delete"))
                {
                    // marked for deletion - don't copy, just remove the marker
                    src.removeData("delete");
                }
                else
                {
                    // this row is to be kept - copy it
                    copyRow(src, dst);
                    dst = dst.next();
                }
            }

            // clear remaining rows
            for ( ; dst.data("idx") != "end" ; dst = dst.next())
                setRow(dst, {pintype: 0});
        }
        
        // fix up for the deletion
        fixUpTable();
    }

    // Move one or more output rows
    moveOutputs = function(fromRow, toRow, num)
    {
        // figure the 'from' index
        var fromIdx = fromRow.data("idx") - 1;

        // figure the 'to' index - if moving to the end, use the first free row
        var toIdx = toRow.data("idx");
        if (toIdx == "end")
            toIdx = findFreeRow().data("idx");
        toIdx -= 1;

        // If we're inserting at the same point, or the insertion point
        // overlaps the deleted area, there's nothing to do
        if (toIdx >= fromIdx && toIdx < fromIdx + num)
            return;

        // make an internal copy of the rows we're moving
        var vals = [];
        var rows = $("#outputTab .outPortRow");
        var cur = rows.eq(fromIdx);
        for (var i = 0 ; i < num ; ++i, cur = cur.next())
        {
            vals.push({
                pintype:  cur.find(".pintype").val(),
                pinval:   cur.find(".pinval").val(),
                pinflags: cur.find(".pinflags").val()
            });
        }

        // delete the rows being moved
        deleteOutputs(fromRow, num);

        // Figure the insertion point.  If this is higher than the
        // 'from' point, adjust it for the deletion we just did.
        if (toIdx > fromIdx)
            toIdx -= num;

        // insert the rows
        insertOutputs(rows.eq(toIdx), vals);
    }
        
    function copyRow(src, dst)
    {
        // copy the row only if the src and dst rows are distinct
        if (src.data("idx") != dst.data("idx"))
        {
            // copy the pin type, pin value, and flags
            dst.find(".pintype").val(src.find(".pintype").val());
            dst.find(".pinval").val(src.find(".pinval").val()).change();
            dst.find(".pinflags").val(src.find(".pinflags").val()).change();

            // fix up any special fields that reference the affected rows
            function update(fld, disable)
            {
                // if we just overwrite the referenced row, disable the reference
                var i = fld.val();
                if (i == dst.data("idx"))
                    disable();
                else if (i == src.data("idx"))
                    fld.val(dst.data("idx")).change();
            }
            update($("#zbPort"), function() {
                $("#zbPort").val(0);
                $("#zbEnabled").prop("checked", false).change();
            });
        }
    }

    function setRow(dst, val)
    {
        dst.find(".pintype").val(val.pintype || 0);
        dst.find(".pinval").val(val.pinval || 0).change();
        dst.find(".pinflags").val(val.pinflags || 0).change();
    }

    // Find the first free row.  This is the first row of type 'disabled'.
    function findFreeRow()
    {
        // filter for disabled rows, then return the first one
        return $("#outputTab .outPortRow").filter(function() {
            return $(this).find(".pintype").val() == 0;
        }).first();
    }

    // fix up the table for an insertion (+1) or deletion (-1)
    function fixUpTable()
    {
        // reset pin warnings
        updatePinWarnings();

        // adjust the table size
        sizeOutputsTable();
    }
})();

// Adjust the display size of the table so that we only show the active
// outputs.  This hides outputs from the first disabled one onward.
function sizeOutputsTable()
{
    // start with items visible
    var disp = "";

    // visit each row
    $("#outputTab .outPortRow").each(function() {
        // If this is the special last row with the "add row at end" control,
        // show it only if the previous row was hidden - once all real rows
        // are shown, we can't add more rows.
        //
        // For all normal rows, if this one is disabled, hide items from here
        // to the end.
        var self = $(this);
        if (self.data("idx") == "end")
            disp = (disp == "none" ? "" : "none");
        else if (self.find(".pintype").val() == 0)
            disp = "none";

        // show or hide this item according to the current status
        self.css("display", disp);
        
        // make sure all hidden rows have pin type 0
        if (disp == "none")
            self.find(".pintype").val(0);
    });

    // show or hide the "+" buttons throughout the table according to whether
    // the last "+" button in the last fake row was available
    $("#outputTab .addRow").css("display", disp);
}

   </script>

<!-- end of main config options section --------------------------------->
</div>

<!-- display raw configuration data for testing purposes -->
<!-- 
<hr>
<div id="rawconfig">
</div>
-->


<!-- navigation footer -------------------------------------------------->
<div id="navproxy"></div>
<div id="nav">
   <div>
      <div class="left">
         <a class="iconButton" href="top.htm" id="mainMenuButton" title="Return to the main menu"><img src="homeIcon.png"></a>
         <select id="goToSection">
            <option value="X">Go to...</option>
         </select>
      </div>
      <a class="button" href="#" id="programButton" title="Program these new settings into the KL25Z">Program KL25Z</a>
      <a class="button" href="#" id="revertButton" title="Discard changes and revert to current device settings">Revert</a>
      <div class="right">
         <a class="iconButton" href="#" id="fileOpsButton" title="Save/restore settings to/from a disk file"><img src="saveIcon.png"></a>
         <div id="fileOpsMenu" class="popupMenu" style="bottom: 1em; right: 1ex;">
            <div title="Save these in-memory settings to a file" id="fileSaveButton">Save to file</div>
            <div title="Load new in-memory settings from a file" id="fileLoadButton">Load file</div>
            <hr>
            <div title="Print this page" id="printButton">Print...</div>
         </div>
      </div>
   </div>
</div>


<script>

$(function() {
    var lst = [], i = 0;
    $("div.section").each(function() {
        ++i;
        var anchor = "TopSection" + i;
        $(this).prev().before("<a name=\"" + anchor + "\"></a>");
        lst.push("<option value=\"#" + anchor + "\">" + $(this).data("name") + "</option>");
    });
    $("#goToSection").append(lst.join()).change(function(ev) {
        var val = $(this).val();
        if (val != "X") {
            window.navigate(val);
            $(this).val("X");
        }
    });
});

$("#fileOpsButton").click(function(ev) {
    ev.preventDefault();
    ev.stopPropagation();
    var menu = $("#fileOpsMenu");
    menu.css({"display": "inline-block", "bottom": ($(this).outerHeight()/2)  + "px"});
    $("html,body").on("click.fileOpsButton", function() { hide(); });
    function hide() {
        $("html,body").off(".fileOpsButton");
        menu.css("display", "none");
    }
});

$("#mainMenuButton").click(function(ev) {
    if (uiDirty() && !window.external.DiscardCancelDialog(
        "You've made changes to the configuration that haven't been "
        + "programmed into the device or saved to a backup file. If you "
        + "leave now, you'll abandon this work.  Are you sure you want to "
        + "discard your changes?"))
    {
        ev.preventDefault();
        return false;
    }
});
$("#revertButton").click(function(ev) {
    ev.preventDefault();
    if (window.external.DiscardCancelDialog(
        "This will discard all unsaved changes and return to the settings "
        + "currently stored on the KL25Z. Are you sure you want to proceed?",
        "&Revert|Cancel"))
        configToUI(config, xconfig, ConfigSource.Board);
});
$("#programButton").click(function(ev) {
    ev.preventDefault();
    programKL25Z();
});

$("#fileSaveButton").click(function(ev) {
    ev.preventDefault();

    // save the configuration and show the result message
    var uic = configFromUI();
    var uicx = xconfigFromUI();
    var result = showCallResult(window.external.WriteConfigFile(
        CPUID, "Note: this is an in-memory working configuration", "browse",
        configToUSB(uic).join(";"), JSON.stringify(uicx)));

    // if we were successful, remember this as the last saved configuration,
    // so that we don't bug the user about saving again if they leave without
    // making any further changes
    if (result.status == "ok") {
        fileConfig = uic;
        fileXConfig = uicx;
    }
});

$("#fileLoadButton").click(function(ev) {
    ev.preventDefault();

    // read a config file
    showCallResult(window.external.ReadConfigFile(CPUID, "browse"), {
        "ok": function(result) {
            // got it - make it active
            configToUI(result.config, result.xconfig, ConfigSource.File);
            window.external.ShowAdviceDialog(
                "RestoreSettings",
                "The file settings have been loaded.  Note that the new settings "
                + "are only in memory - nothing has been changed on the KL25Z yet. "
                + "If you want to make these settings active on the device, click "
                + "the \"Program KL25Z\" button.");

            // Remember this as the last saved configuration.  If the user
            // quits without making any changes, there's no need to bug them
            // about saving, since they can just load this same file again.
            fileConfig = result.config;
            fileXConfig = result.xconfig;
        }
    });
});

$("#printButton").click(function(ev) {
    ev.preventDefault();
    window.external.PrintPage();
});

</script>


<!-- Pin and output selector popup -------------------------------------->
<div class="windowCover">
   <div id="pinSelector">
      <div id="gpioSelector" class="pinSelectorPage">
         <div id="lstKL25ZPins" class="pinlist"></div>
         <div id="kl25zPinImg" class="pinimage">
            <img src="kl25zPins.png">
            <div id="kl25zOnBoardLED"></div>
         </div>
      </div>
      <div id="tlc5940Selector" class="pinSelectorPage" data-pagetype="chip">
         <div class="chipNo header" data-chip="0">Chip 1</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div class="chipIndexer background"></div>
            <div class="chipIndexer foreground"></div>
            <img src="tlc5940Pins.png">
         </div>
      </div>
      <div id="tlc59116Selector" class="pinSelectorPage" data-pagetype="chip">
         <div class="chipNo header" data-chip="0">Chip 1</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div class="chipIndexer background"></div>
            <div class="chipIndexer foreground"></div>
            <img src="tlc59116Pins.png">
         </div>
      </div>
      <div id="hc595Selector" class="pinSelectorPage" data-pagetype="chip">
         <div class="chipNo header" data-chip="0">Chip 1</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div class="chipIndexer background"></div>
            <div class="chipIndexer foreground"></div>
            <img src="74hc595Pins.png">
         </div>
      </div>
      <div id="mainBoardDigitalOutputSelector" class="pinSelectorPage expBoardPinSelector" data-pagetype="board">
         <div class="chipNo header" data-chip="0">JP9</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <img src="mainBoardPins.png">
         </div>
      </div>
      <div id="mainBoardPWMOutputSelector" class="pinSelectorPage expBoardPinSelector" data-pwm="true" data-pagetype="board">
         <div class="chipNo header" data-chip="0">Flashers</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <img src="mainBoardPins.png">
         </div>
      </div>
      <div id="mainBoardInputSelector" class="pinSelectorPage expBoardPinSelector" data-pagetype="board">
         <div class="chipNo header" data-chip="0">N/C</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <img src="mainBoardPins.png">
         </div>
      </div>
      <div id="powerBoardOutputSelector" class="pinSelectorPage expBoardPinSelector" data-pagetype="board">
         <div class="chipNo header" data-chip="0">Board 1</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div class="chipIndexer background"></div>
            <div class="chipIndexer foreground"></div>
            <img src="powerBoardPins.png">
         </div>
      </div>
      <div id="chimeBoardOutputSelector" class="pinSelectorPage expBoardPinSelector" data-pagetype="board">
         <div class="chipNo header" data-chip="0">Board 1</div>
         <div class="pinlist"></div>
         <div class="pinimage">
            <div class="chipIndexer background"></div>
            <div class="chipIndexer foreground"></div>
            <img src="chimeBoardPins.png">
         </div>
      </div>
      <div id="virtualOutputSelector" class="pinSelectorPage">
         <div>
            A "virtual" output is a software port that isn't connected to
            a physical output.  This can be used as a placeholder in your
            DOF setup, or for a special function, such as the ZB Launch Ball
            control port.
         </div>
         <div>
            <div class="iconWithTitle button available" data-pin="NC "id="btnMakeVirtualPort">
               <img src="virtualOutSmall.png">
               <br>Virtual
            </div>
            <div class="iconWithTitle button available" data-pin="NC" id="btnMakeZBPort">
               <img src="zbLaunch32.png">
               <br>ZB Launch Port
            </div>
         </div>
      </div>
      <div id="pinTypeSelector">
         <div id="pinTypePwmOut" data-page="gpioSelector" data-filter="pwm" data-pintype="1">
            <img src="pwmout.png"><br>
            GPIO<br>
            PWM Out
         </div>
         <div id="pinTypeDigOut" data-page="gpioSelector" data-filter="dig-out" data-pintype="2">
            <img src="digitalout.png"><br>
            GPIO<br>
            Digital Out
         </div>
         <div id="pinTypeSpiMosi" data-page="gpioSelector" data-filter="spi-mosi">
            <img src="spiout.png"><br>
            SPI (MOSI)
         </div>
         <div id="pinTypeSpiSclk" data-page="gpioSelector" data-filter="spi-sclk">
            <img src="spiout.png"><br>
            SPI (SCLK)
         </div>
         <div id="pinTypeAnalogIn" data-page="gpioSelector" data-filter="adc">
            <img src="analogin.png"><br>
            Analog In
         </div>
         <div id="pinTypeDigIn" data-page="gpioSelector" data-filter="dig-in">
            <img src="digitalin.png"><br>
            Digital In
         </div>
         <div id="pinTypeInterruptIn" data-page="gpioSelector" data-filter="interrupt-in">
            <img src="interruptin.png"><br>
            Interrupt In
         </div>
         <div id="pinType5940Out" data-page="tlc5940Selector" data-pintype="3">
            <img src="tlc5940out.png"><br>
            TLC5940 Out
         </div>
         <div id="pinType59116Out" data-page="tlc59116Selector" data-pintype="6">
            <img src="tlc59116out.png"><br>
            TLC59116 Out
         </div>
         <div id="pinType595Out" data-page="hc595Selector" data-pintype="4">
            <img src="74hc595out.png"><br>
            74HC595 Out
         </div>
         <div id="pinTypeMainBoardPWMOut" data-page="mainBoardPWMOutputSelector" data-pintype="1">
            <img src="mainBoardOut.png"><br>
            Main Board<br>PWM Out
         </div>
         <div id="pinTypeMainBoardDigitalOut" data-page="mainBoardDigitalOutputSelector" data-pintype="2">
            <img src="mainBoardOut.png"><br>
            Main Board<br>Digital Out
         </div>
         <div id="pinTypeMainBoardIn" data-page="mainBoardInputSelector">
            <img src="mainBoardIn.png"><br>
            Main Board
         </div>
         <div id="pinTypePowerBoardOut" data-page="powerBoardOutputSelector">
            <img src="powerBoardOut.png"><br>
            Power Board
         </div>
         <div id="pinTypeChimeBoardOut" data-page="chimeBoardOutputSelector">
            <img src="chimeBoardOut.png"><br>
            Chime Board
         </div>
         <div id="pinTypeVirtOut" data-page="virtualOutputSelector" data-pintype="5">
            <img src="virtualout.png"><br>
            Virtual Out
         </div>
      </div>
   </div>
</div>



<!-- IR command selector popup ------------------------------------------>
<div class="windowCover">
   <div id="IRCommandSelector">
      <div>
         <div>
            <div id="IRCommandList">
            </div>
         </div>
      </div>
   </div>
</div>


<!-- key selector popup ------------------------------------------------->
<div class="windowCover">
   <div id="keySelector">
      <div>
         <div>
            <div id="oskeyboard">
            </div>
            <div id="osunused">
               <div>
                  Select this option if you don't want the button to send
                  any input to the PC when pressed.
               </div>
               <div id="unusedBtn" class="iconWithTitle">
                  <img src="noKey.png">
                  <br>No PC Input
               </div>
            </div>
            <!-- 
            <div id="osspecial">
               <div>
                  Select special functions for the key, separate from
                  any PC input.
               </div>
               <div id="nightModeBtn" class="iconWithTitle"
                 title="Use this button to turn Night Mode on and off">
                  <img src="nightModeSmall.png">
                  <br>Night Mode
               </div>
            </div>
            -->
            <div id="osjoystick">
               <div class="topfill">
                  Joystick Buttons
               </div>
               <div class="jsBtnBox">
               </div>
            </div>
         </div>
         <div id="keytype">
            <img id="keytypeJS" data-page="#osjoystick" title="Joystick Buttons" src="joystickicon.png">
            <img id="keytypeKB" data-page="#oskeyboard" title="Keyboard Keys" src="keyboardicon.png">
            <img id="keytypeUnused" data-page="#osunused" title="No PC Input" src="noKey.png">
            <!-- <img id="keytypeSpecial" data-page="#osspecial" title="Special Function" src="specialicon.png"> -->
         </div>
      </div>
   </div>
</div>


<!-- main scripts ------------------------------------------------------->

<script>

// CPUID for the device - obtained from the URL parameters
var CPUID;

// DeviceInfo object for the current device
var deviceInfo;

// Current device source configuration.  This is the last configuration
// we loaded from the device.
var config = { };

// Current external configuration.  This is the last xconfig loaded.
// The xconfig is stored in the local PC file system, not on the device.
// It contains settings that aren't needed at run-time on the device
// and would take up too much memory to justify storing in the device
// flash, such as description strings for the stored IR commands and
// the output ports.
var xconfig = { };

// Current saved file configuration.  This is the last configuration
// we saved to a file or loaded from a file.
var fileConfig = { };
var fileXConfig = { };

// Program the current UI settings into the KL25Z
function programKL25Z()
{
    // check for pin assignment conflicts
    var w = getPinWarnings();
    if (w.length && !window.external.YesNoDialog(
        "The following items have conflicting pin assignments:\r\n\r\n"
        + $.map(w, function(ele) { return ele.data("desc"); }).join("; ")
        + "\r\n\r\n"
        + "The controller might not work correctly if you program it with "
        + "these conflicts unresolved.  Are you sure you wish to proceed?"))
        return;

    // now warn about overwriting the settings
    if (!window.external.YesNoDialog(
        "This will program the KL25Z with the new settings you've selected. "
        + "The previous settings will be permanently overwritten. Are you "
        + "sure you wish to proceed?"))
        return;

    // get the current UI configuration, and convert it to USB format
    var usb = configToUSB(configFromUI()).join(";");

    // get the current UI external config, and convert to JSON format
    var cx = JSON.stringify(xconfigFromUI());

    // save a backup copy first
    showCallResult(window.external.WriteConfigFile(
        CPUID, "Note: this is an in-memory working configuration",
        "backup", usb, cx),
        { "ok": function() { } }
    );

    // send the configuration to the KL25Z and display the result
    var res = showCallResult(window.external.PutDeviceXConfig(CPUID, cx), {
        "ok": function() {
            var res = showCallResult(window.external.PutDeviceConfig(CPUID, usb));
            if (res.status == "ok")
                waitForReboot(CPUID);
        }
    });
}

// On closing the window, the C# container calls this custom method.
// We can return the string "cancel" to stop the event.
function OnCloseWindow()
{
    if (uiDirty() && !window.external.DiscardCancelDialog(
        "You've made changes to the configuration that haven't been "
        + "programmed into the device or saved to a backup file. "
        + "Quitting now will abandon this work.  Do you really want "
        + "to discard these changes?"))
        return "cancel";
}

// Check for changes between the UI and device configuration
function uiDirty()
{
    // get the current UI configuration, normalized for comparison purposes
    var uic = normalizeConfig(configFromUI());
    var uixc = normalizeXConfig(xconfigFromUI());

    // if it matches the device configuration or the last configuration
    // saved or loaded from a file, it's not dirty
    return !(valEq(uic, normalizeConfig(config)) || valEq(uic, normalizeConfig(fileConfig)))
        || !(valEq(uixc, normalizeXConfig(xconfig)) || valEq(uic, normalizeXConfig(fileXConfig)));
}

// Compare two values, doing a deep comparison of properties of objects
function valEq(a, b)
{
    // NaN == NaN requires a special test
    if (isNaN(a) && isNaN(b) && typeof a == "number" && typeof b == "number")
        return true;
    
    // if they're identical primitives, they're equal
    if (a === b)
        return true;
    
    // compare certain non-primitive object types by string value
    if ((typeof a == "function" && typeof b == "function")
        || (a instanceof Date && b instanceof Date)
        || (a instanceof RegExp && b instanceof RegExp)
        || (a instanceof String && b instanceof String)
        || (a instanceof Number && b instanceof Number))
    {
        return a.toString() === b.toString();
    }

    // if they're arrays, check them recursively
    if ($.isArray(a) && $.isArray(b))
    {
        // if the arrays aren't of equal length, they differ
        var l = a.length;
        if (b.length != l) {
            //alert("a.length != b.length"); // [debug]
            return false;
        }

        // the lengths match; compare each element
        for (var i = 0 ; i < l ; ++i)
        {
            if (!valEq(a[i], b[i])) {
                //alert("a[" + i + "] != b[" + i + "]"); // [debug]
                return false;
            }
        }
    }
    
    // if they're objects, check them recursively
    if (typeof a == "object" && typeof b == "object")
    {
        // check that all properties of a are in b
        for (var p in a) {
            if (!(p in b)) {
                //alert("p not in b: " + p); // [debug]
                return false;
            }
        }

        // all a.p are in b; now check that all b.p equal a.p
        for (var p in b) {
            if (!(p in a) || !valEq(a[p], b[p])) {
                //alert((p in a) ? "vals differ: " + p : "p not in a: " + p); // [debug]
                return false;
            }
        }

        // no differences found
        return true;
    }
    
    // consider anything else unequal
    return false;
}

// page initialization
$(function() {

    // note the browser scrollbar width
    var sbwid = getScrollBarWidth();

    // set up DOF Config Tool links
    $("a.dofconfigtool")
        .attr("href", "http://configtool.vpuniverse.com/")
        .attr("target", "_blank");

    // Initialize the pin selector dialog
    pinSelectorSetup();

    // initialize the config functions
    configFunctionSetup();

    // set up number input "spinner" controls
    $("#numMainBoards,#numPowerBoards,#numChimeBoards").spinner({min: 0, max: 8});
    $("#txtRebootTime").spinner({min: 1, max: 255});
    $("#zbPort").spinner({min: 1, max: 128});
    $("#tlc_nchips").spinner({min: 0, max: 8});
    $("#hc595_nchips").spinner({min: 0, max: 8});
    $("#nightModeOutputNo").spinner({min: 0, max: 128});
    $("#shiftButton, #nightModeButtonNo").spinner({min: 0, max: 128});
    $("#accelAutoCenterTime").spinner({min: 1, max: 60});
    $("#tvDelay").spinner({min: 1, max: 60});

    // set spinner change listeners
    $("#numMainBoards, #numPowerBoards, #numChimeBoards, #zbPort, #tlc_nchips, "
      + "#hc595_nchips, #nightModeButtonNo, #nightModeOutputNo, #shiftButton").on(
        "spinstop", function() { $(this).change(); });

    // Retrieve the device ID from the URL.  The ID= parameter encodes
    // the KL25Z CPU ID, which we use as the primary key to identify
    // the device through the C# callback API.  This is effectively a
    // GUID for the device - it's permanently fixed in the device (in
    // ROM set at the factory), and it's guaranteed to be unique among
    // all Freescale devices.
    if (/[?&]ID=([\da-f\-]+)/i.test(window.location.href))
    {
        // set the CPU ID
        CPUID = RegExp.$1;
        $("#CPUID").text(CPUID);

        // get the device info
        function formatCommas(s) { return s.toString().replace(/(\d)(\d\d\d)$/, "$1,$2"); }
        function formatByteSize(s)
        {
            if (s < 1024) return formatCommas(s);
            if (s < 10*1024) return (s/1024).toFixed(1).toString() + "K bytes";
            return Math.round(s/1024) + "K bytes";
        }
        deviceInfo = eval(window.external.GetDeviceInfo(CPUID)) || { FreeHeapBytes: 0 };
        if (deviceInfo.FreeHeapBytes) {
            $("#usedHeapBytes").text(formatByteSize(16*1024 - deviceInfo.FreeHeapBytes));
            $("#freeHeapBytes").text(formatCommas(deviceInfo.FreeHeapBytes));
            $("#heapInfo").show();
        }

        // show the appropriate sections for the new accelerometer features
        $("#newAccelFeatures").toggle(!!deviceInfo.AccelFeatures);
        $("#noNewAccelFeatures").toggle(!deviceInfo.AccelFeatures);

        // loop until we get the configuration or the user cancels
        for (;;)
        {
            // retrieve the current device configuration
            var c = window.external.GetDeviceConfig(CPUID);
            var xc = window.external.GetDeviceXConfig(CPUID);

            // check if we got a result
            var errmsg = null;
            if (c)
            {
                // parse the config data
                config = eval(c);

                // if there's no error code, we have valid config data
                if (!(errmsg = config.error))
                    break;

                // wrap the error in parens for display
                errmsg = " (" + errmsg + ")";
            }

            // failed - ask if they want to try again
            if (!window.external.RetryCancelDialog(
                "An error occurred loading the device settings" + errmsg
                + ". Do you want to try again?"))
            {
                // cancel - set a timeout to navigate back to the main menu
                setTimeout(function() { window.navigate("top.htm"); }, 1);

                // no need to do any more page initialization, as we're not staying
                return;
            }
        }
        
        // parse the xconfig data
        xconfig = JSON.parse(xc);

        // display the raw configuration in the debugging section, if present
        $("#rawconfig").text(c);

        // load the config into the UI
        configToUI(config, xconfig, ConfigSource.Board);

        // show the appropriate sections for the IR features
        $("#irRemotePins, #irCommands").toggle(!!config.IRRemote);
        $("#noIrRemotePins").toggle(!config.IRRemote);

        // if the shift button isn't supported, hide the shift button sections
        if (!("shiftButton" in config)) {
            $("#shiftButton").val(0).change();
            $("#shiftButtonSetup, #buttonTab .shiftCol").hide();
        }

        // remove the UI blocker for loading
        $("#loadingOverlay").parent().hide();
    }

    function pinSelectorSetup()
    {
        // get the dialog
        var pindlg = $("#pinSelector");

        // Set up button objects on top of the KL25Z popup image.  This
        // allows selecting pins by pointing to them on the picture.
        var btndiv = $("#kl25zPinImg");
        var xpad = parseInt($("#kl25zPinImg img").css("padding-left"));
        var ypad = parseInt($("#kl25zPinImg img").css("padding-top"));
        $.each(kl25z_headers, function(k, v) {
            forEachPin(v, function(pin, n, x, y) {
                // find the gpioPin entry for the pin
                var g = (gpioPinsByName[pin] || { });
                var jumper = g.internalShortName || k + "-" + n;
                var hover = pin + " (" + jumper + ")";
                
                // Build the pin button.  Note the 8-pixel adjustment to the top and left
                // position: this is because the coordinates in the header descriptor are
                // for the CENTER of the pin on the image.  Our button divs are 16px wide,
                // so we center them by subtracting 8px from each coordinate.
                var posname = k + "-" + n;
                btndiv.append(
                    "<div class=\"pinButton\" "
                    + "data-pin=\"" + pin + "\" "
                    + "data-hovername=\"" + hover + "\" "
                    + "title=\"" + pin + (posname != "N/A" ? " (" + posname + ")\" " : "")
                    + "style=\"left: " + (x + xpad - 8) + "px; top: " + (y + ypad - 8) + "px;\">"
                    + "</div>");

                // set the header reference in the GPIO pin entry
                if (g)
                    g.pin = { name: posname, x: x, y: y };
            })
        });

        // Build the KL25Z pin selection list
        var pinlst = $("#lstKL25ZPins");
        var options = [];
        options.push("<div data-pin=\"Not Connected\">Not Connected</div>");
        for (var i = 0 ; i < gpioPins.length ; ++i)
        {
            var g = gpioPins[i];
            var hovername = g && (g.internalShortName || g.pin && g.pin.name);
            hovername = hovername && "data-hovername=\"" + hovername + "\"";

            options.push(
                "<div data-pin=\"" + g.name + "\" " + hovername + "\">"
                + g.name + "</div>");
        }
        pinlst.html(options);

        // move the on-board LED display according to the padding
        var obl = $("#kl25zOnBoardLED");
        obl.css("left", (parseInt(obl.css("left")) + xpad) + "px")
            .css("top", (parseInt(obl.css("top")) + ypad) + "px");

        // add event handlers the KL25Z GPIO pin list elements and image buttons
        addPinEvents(pinlst, $("#kl25zPinImg"), $("#kl25zPinImg .pinButton, #lstKL25ZPins > div"));

        // Add hover and click handlers to pin list items or gpio pins.
        // 'list' is a jquery set with the container for the pin listbox list
        // 'picdiv' is a jquery set with the graphical pin container.
        // 'items' is a jquery set with the list items and/or pins to
        //    set up with event handlers.
        function addPinEvents(list, picdiv, items)
        {
            // add hover handlers to the list items
            items.off("mouseenter mouseleave click").hover(
                function() {
                    // remove 'hover' status from all pins and list items
                    list.children().removeClass("hover");
                    picdiv.children(".pinButton").removeClass("hover");

                    // sync the list and pin pad image if the pin is available
                    var self = $(this);
                    if (self.hasClass("available"))
                    {
                        // get this pin name
                        var pin = self.data("pin");
                        var finder = function() { return $(this).data("pin") == pin; }
                        
                        // set hover state on the matching list item and pin button
                        picdiv.children().filter(finder).addClass("hover");
                        var listele = list.children().filter(finder);
                        listele.addClass("hover");

                        // if this is one of the on-board LED pins, turn on the LED
                        // display to the appropriate color while hovering
                        var g = gpioPinsByName[pin];
                        if (g && g.onBoardLED) {
                            $("#kl25zOnBoardLED").css(
                                "background-position", "0px " + (-g.onBoardLED*40) + "px");
                        }
                        
                        // If the event is from an image button, scroll the list item
                        // into view after a brief delay.  The delay is to avoid making
                        // the list jump around when the mouse sweeps over the pin image
                        // on its way somewhere else - we only scroll the list when the
                        // mouse is at least briefly stationary over a pin.
                        if (self.hasClass("pinButton") && self.hasClass("available"))
                        {
                            // set a sequence number to compare when the timeout expires
                            var seqno = 1 + (self.data("hoverseq") || 0);
                            self.data("hoverseq", seqno);
                            
                            // Set a timeout for the delay.  When it expires, it we're
                            // still hovering over the same item and the sequence number
                            // is the same, do the scrolling.  If we're not still hovering,
                            // it means that the mouse has left since we started the timer,
                            // so don't do the scrolling after all.  If the sequence number
                            // has changed, it means that the mouse has left and come back,
                            // in which case the mouse hasn't been stationary for the whole
                            // interval and hence we don't want to do the scrolling.
                            setTimeout(function() {
                                if (self.hasClass("hover") && self.data("hoverseq") == seqno)
                                    scrollIntoView(listele, 100, { top: list.prev(".header").outerHeight() });
                            }, 250);
                        }
                    }
                },
                function() {
                    // get the pin name
                    var pin = $(this).data("pin");
                    var finder = function() { return $(this).data("pin") == pin; };

                    // turn off the on-board LED if it was on
                    var g = gpioPinsByName[pin];
                    if (g && g.onBoardLED)
                        $("#kl25zOnBoardLED").css("background-position", "0px 0px");

                    // remove hover state from the list item and image button
                    picdiv.children().filter(finder).removeClass("hover");
                    list.children().filter(finder).removeClass("hover");
                }

            ).click(function() {
                // on click, select the item and dismiss the dialog
                pinselect($(this), false, true);
            });
        }

        // click the "Mark Virtual" button on the virtual output type page
        $("#btnMakeVirtualPort").click(function(ev) {
            ev.preventDefault();
            pinselect($(this), false, true);
        });

        // click the "Make ZB port" button on the virtual output type page
        $("#btnMakeZBPort").click(function(ev) {
            ev.preventDefault();
            $("#zbEnabled").prop("checked", true).change();
            $("#zbPort").val(curpin.parents(".outPortRow").data("idx")).change();
            pinselect($(this), false, true);
        });

        // table of pin adjustor functions for the various pages
        var chipPinPageAdjustor = { };

        // generate a list a..b (for chip indexers)
        function ordinals(a, b)
        {
            for (var l = [], i = a ; i <= b ; l.push(i++)) ;
            return l;
        }

        // set up the TLC5940 selection list and image buttons
        initChipPinPageAdjustor(
            "tlc5940Selector", "3",
            function() { return ordinals(0, $("#tlc_nchips").val() - 1); },
            16, "Chip 1", 1);
        buildChipPinButtons($("#tlc5940Selector"), tlc5940_pins, "3", 10, 16);
        
        // Build the 74HC595 selection list and image buttons
        initChipPinPageAdjustor(
            "hc595Selector", "4",
            function() { return ordinals(0, $("#hc595_nchips").val() - 1); },
            8, "Chip 1", 1);
        buildChipPinButtons($("#hc595Selector"), hc595_pins, "4", 20, 20);

        // build the TLC59116 selection list and image buttons
        initChipPinPageAdjustor(
            "tlc59116Selector", "6",
            function() {
                return $("#tlc59116_chipsEnabled input:checked")
                    .map(function() { return $(this).data("address"); })
                    .get();
            }, 16, "Chip 0 ($4b)", 0);
        buildChipPinButtons($("#tlc59116Selector"), tlc59116_pins, "6", 10, 16);

        // Get an adjustor function for a chip pin list.  Call the function
        // on opening the dialog page to populate the list with new pins
        // as needed.
        function initChipPinPageAdjustor(pageName, pintype, chipListFunc, pinsPerChip, groupHeader, labelBase)
        {
            // set up the adjustor function, and store it in the table so
            // that showChipPinPage() can automatically call it
            chipPinPageAdjustor[pageName] = function()
            {
                // get the new chip list
                var chipList = chipListFunc();

                // populate new chip pages
                var page = $("#" + pageName);
                buildChipPinList(page, pintype, chipList, pinsPerChip, groupHeader, labelBase);
                
                // hide chips and pins that aren't currently available
                page.find(".chipNo:not(.header), .chipPin").each(function() {
                    var self = $(this);
                    self.toggle(chipList.indexOf(+self.data("chip")) >= 0);
                });
            };
        }

        // Build the pin image buttons for a chip layout
        function buildChipPinButtons(page, pins, pintype, wid, ht)
        {
            // get the image padding
            var picdiv = page.find(".pinimage");
            var img = picdiv.find("img");
            var xpad = parseInt(img.css("padding-left"));
            var ypad = parseInt(img.css("padding-top"));

            // add each pin
            forEachPin(pins, function(pin, n, x, y)
            {
                // only the OUTn pins are available as outputs
                var available = /^OUT(\d+)$/i.test(pin);
                var pinno = (available ? RegExp.$1 : "");
                
                // add the button
                picdiv.append(
                    "<div class=\"pinButton " + (available ? "available" : "") + "\" "
                    + (available ?
                       "data-pin=\"" + pinno + "\" data-basepin=\"" + pinno + "\" "
                       + "data-pintype=\"" + pintype + "\" data-hovername=\"" + pin + "\" "  :
                       "")
                    + "title=\"" + pin + "\" "
                    + "style=\"left: " + (x + xpad - wid/2) + "px; top: " + (y + ypad - ht/2) + "px;\">"
                    + "</div>");
            });

            // add hover and click handlers to the image buttons
            addPinEvents(page.find(".pinlist"), picdiv, picdiv.find(".pinButton"));
        }

        // Build one of the chip pin lists (TLC5940, 74HC595, TLC59116)
        function buildChipPinList(page, pintype, chipList, pinsPerChip, groupHeader, labelBase)
        {
            // Build a section for each copy of the chip.  Internally, the
            // pins are numbered consecutively across chips starting at 0 for
            // the first pin on the first chip.
            buildGroupedPinList(
                page,
                [{ groups: chipList, pins: pinsPerChip,
                   header: groupHeader, pinname: "OUT0", pintype: pintype }
                ]);

            // build the chip indexer
            buildChipIndexer(page, chipList, pinsPerChip, labelBase);
        }

        // Build a chip/board indexer for an output selector page that can have
        // multiple copies of the chip/board.  
        function buildChipIndexer(page, chipList, pinsPerChip, labelBase)
        {
            // build the list of chip index buttons
            var idxlst = [];
            for (var i = 0 ; i < chipList.length ; ++i)
            {
                idxlst.push(
                    "<div data-idx=\"" + chipList[i] + "\">"
                    + (chipList[i] + labelBase)
                    + "</div>");
            }
                                       
            // Build the chip index buttons.  This allows selecting among
            // multiple copies of the chip in the graphical pin layout view.
            var picdiv = page.find(".pinimage");
            picdiv.find(".chipIndexer.foreground").html(idxlst);
            
            // Add click handlers for the indexer buttons
            picdiv.find(".chipIndexer.foreground div").click(function(ev) {
                switchChip(page, $(this).data("idx"), pinsPerChip);
            });
        }
                
        // Build a grouped pin list.
        //
        // 'page' is the selector page element.
        //
        // 'sections' is a list of pin sections descriptor objects:
        //
        //     .groups = list of index values for chip/board groups
        //     .pins = number of pins in each copy of the section
        //     .header = function(copyIndex) returning header name string
        //     .pinname = function(pinIndex, copyIndex) returning pin name string
        //     .pinid = function(pinIndex, copyIndex) returning the data-pin value
        //     .pintype = default pin type code for the pins in this group, used if
        //         the .pinid value doesn't have a type prefix
        //     .hovername = function(pinName, pinIndex, copyIndex) returning the hover
        //         name for the list item; pinName is the name returned by .pinname
        //
        // groups is a list of index values for chips and boards that can have
        // multiple copies.  For example, we can have several TLC5940 chips in the
        // system, in which case 'groups' is a list of the chip index values.  For
        // daisy-chained chips or boards, this is simply the ordinal list starting
        // at 0, as in [0, 1, 2, 3] for a four-chip system.  For addressable chips
        // (e.g., TLC59116), this is a list of the address values.
        //
        // header, pinname, and pinid can be simple strings instead of functions.
        // In this case, '0' and '1' are replaced with the 0-based or 1-based index
        // for (respectively) the item (copy number in the case of the header, pin
        // number in the case of the pin name or ID).  The special syntax '$b' is
        // replaced by a binary version of the 0-based index value; '$4b' means
        // that the result should be left-padded with zeroes to four characters
        // (e.g., '$4b' with input value 3 produces '0011').
        //
        // If pinid isn't specified, the default is the current *overall* pin
        // number, starting at 0 for the first pin on the first chip/board, and
        // incrementing once per pin, continuously across chips/boards.  E.g.,
        // if there are 8 pins per chip, the first chip's pins are numbered 0-7,
        // the second 8-15, etc.
        //
        // The pinid value can be specified with or without an output type prefix.
        // If provided, the type prefix follows our normal convention: USB type code
        // + "." + pin name.  E.g., GPIO Digital Out PTC8 is "2.PTC8".  If the type
        // isn't provided, we simply use the type code from the page for all pins.
        function buildGroupedPinList(page, sections)
        {
            // get the container
            var list = page.find(".pinlist");

            // run through the sections to add
            $.each(sections, function(sectionIdx, section)
            {
                // Get the header function.  If it's specified as a string, set up
                // a function that replaces 0 or 1 in the string with the copy index.
                var header = section.header;
                if (typeof header == "string") {
                    header = function(itemIndex) {
                        return section.header.replace(/[01]|\$\d+b/gi, function(m) {
                            if (/\$(\d+)b/i.test(m)) {
                                m = itemIndex.toString(2);
                                return "00000000000000000000000000000000".substr(0, +RegExp.$1 - m.length) + m;
                            }
                            else
                                return (+m) + itemIndex;
                        });
                    };
                }

                // Get the pin name function, providing a string substitution function
                // if needed.
                var pinname = section.pinname;
                if (typeof pinname == "string") {
                    pinname = function(pinIndex, itemIndex) {
                        return section.pinname.replace(/[01]/, function(m) { return (+m) + pinIndex; });
                    };
                }

                // Get the pin ID function, providing a substitution function
                var pin = 0;
                var pinid = section.pinid;
                if (typeof pinid == "undefined") {
                    pinid = function(pinIndex, itemIndex) { return pin; };
                }
                else if (typeof pinid == "string") {
                    pinid = function(pinIndex, itemIndex) {
                        return section.pinid.replace(/[01]/, function(m) { return (+m) + pinIndex; });
                    };
                }

                // make a list of the sections already populated
                var existing =
                    list.find(".chipNo")
                    .filter(function() { return $(this).data("sectionindex") == sectionIdx; });
                var existingIdx =
                    existing.map(function() { return $(this).data("chip"); })
                    .get();

                // run through the chips/boards in this section
                for (var i = 0, pin = 0, groups = section.groups ; i < groups.length ; ++i)
                {
                    // start with an empty insertion list for this chip/board
                    var html = [];

                    // get this item's chip index/address
                    var addr = groups[i];

                    // figure the starting pin number on this chip, assuming that
                    // pins are numbered sequentially across chips
                    pin = addr * section.pins;

                    // if this chip/board is already populated, skip it
                    if (existingIdx.indexOf(addr) >= 0)
                        continue;
                
                    // add the section header
                    html.push("<div class=\"chipNo\" "
                              + "data-sectionindex=\"" + sectionIdx + "\" "
                              + "data-chip=\"" + addr + "\">"
                              + header(addr)
                              + "</div>");

                    // add each pin in the section
                    for (var j = 0 ; j < section.pins ; ++j, ++pin)
                    {
                        // Get the pin ID
                        var curPinId = pinid(j, addr);

                        // get the hover name, if any
                        var hover = section.hovername && section.hovername(curPinId, j, addr);

                        // If the pin ID has a type prefix ("number."), pull it out
                        // for a data-pintype attribute
                        var curPinType = section.pintype;
                        if (/^(\d+)\.(.*)$/.test(curPinId)) {
                            curPinType = RegExp.$1;
                            curPinId = RegExp.$2;
                        }

                        // generate the list entry
                         html.push("<div class=\"chipPin available\" "
                                  +   "data-pin=\"" + curPinId + "\" "
                                  +   "data-pintype=\"$1\" ".formatOrEmpty(curPinType)
                                  +   "data-hovername=\"$1 \" ".formatOrEmpty(hover)
                                  +   "data-chip=\"" + addr + "\">"
                                  +   pinname(j, addr)
                                  + "</div>");
                    }

                    // find the lowest existing section after this section
                    var nxt = existing.filter(function() { return +$(this).data("chip") > addr; }).last();
                    if (nxt.length)
                        nxt.before(html);
                    else
                        list.append(html);
                }
            });
                
            // initialize scrolling headers
            initScrollHeader(list, list.find(".chipNo"));
            
            // Attach hover and click handlers to the pin list items
            var picdiv = page.find(".pinimage");
            addPinEvents(list, picdiv, list.find(".chipPin"));
        }

        // figure the hover name for a main board pin list item
        function mainBoardHoverName(pin)
        {
            // if there's an out port alias, return the jumper entry
            var alias = expOutPortAlias[pin];
            return alias ? alias.split("|")[3] : undefined;
        }

        // Build the main board digital output list
        buildGroupedPinList($("#mainBoardDigitalOutputSelector"), [
            { groups: [0], pins: 1, header: "Knocker",
              pinname: function(pin) { return ["Knocker"][pin]; },
              pinid: function(pin) { return ["2.PTC8"][pin] },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 4, header: "Extender", pinname: "Extender 1",
              pinid: function (pin) { return ["2.PTC4", "2.PTC3", "2.PTC0", "2.PTA2"][pin]; },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 6, header: "Plunger",
              pinname: function(pin) { return ["Plunger 1", "Plunger 2", "Plunger 3", "Plunger 4", "Cal Button", "Cal LED"][pin]; },
              pinid: function(pin) { return ["PTB0", "PTE20", "PTE21", "PTE22", "PTE29", "PTE23"][pin]; },
              hovername: mainBoardHoverName
            },
        ]);
        buildBoardPinButtons($("#mainBoardDigitalOutputSelector"), mainBoard_headers, true);
            
        // Build the main board PWM output list
        buildGroupedPinList($("#mainBoardPWMOutputSelector"), [
            { groups: [0], pins: 15, header: "Flashers",
              pinname: function(pin) { return (Math.floor(pin/3)+1) + "RGB".substr(pin % 3, 1) },
              pinid: function(pin) { return "3." + pin; },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 1, header: "Strobe",
              pinname: function(pin) { return ["Strobe"][pin]; },
              pinid: function(pin) { return ["3.15"][pin] },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 16, header: "RGB Flippers",
              pinname: function(pin) { return (pin < 15 ? (Math.floor(pin/3)+1) + "RGB".substr(pin %3, 1) : "6"); },
              pinid: function(pin) { return "3." + (16 + pin); },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 3, header: "Extender",  // extender port JP12 - only pins 1, 2, and 4 are PWM capable
              pinname: function(pin) { return "Extender " + [1, 2, 4][pin]; },
              pinid: function (pin) { return ["1.PTC4", "1.PTC3", "1.PTA2"][pin]; },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 6, header: "Plunger",
              pinname: function(pin) { return ["Plunger 1", "Plunger 2", "Plunger 3", "Plunger 4", "Cal Button", "Cal LED"][pin]; },
              pinid: function(pin) { return ["PTB0", "PTE20", "PTE21", "PTE22", "PTE29", "PTE23"][pin]; },
              hovername: mainBoardHoverName
            },
        ]);
        buildBoardPinButtons($("#mainBoardPWMOutputSelector"), mainBoard_headers, true);
            
        // Build the main board input list
        buildGroupedPinList($("#mainBoardInputSelector"), [
            { groups: [0], pins: 1, header: "N/C", pinname: "Not Conn", pinid: "Not Connected",
              hovername: function() { return "Not Connected"; }
            },
            { groups: [0], pins: 24, header: "Buttons", pinname: "Button 1",
              pinid: function(pin) { return expansionBoardFactoryConfig.buttons[pin+1].pin; },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 4, header: "Extender", pinname: "Extender 1",
              pinid: function(pin) { return ["PTC4", "PTC3", "PTC0", "PTA2"][pin]; },
              hovername: mainBoardHoverName
            },
            { groups: [0], pins: 5, header: "Plunger",
              pinname: function(pin) { return ["Plunger 1", "Plunger 2", "Plunger 3", "Plunger 4", "Cal Button"][pin]; },
              pinid: function(pin) { return ["PTB0", "PTE20", "PTE21", "PTE22", "PTE29"][pin]; },
              hovername: mainBoardHoverName
            },
        ]);
        buildBoardPinButtons($("#mainBoardInputSelector"), mainBoard_headers, true);

        // Build the power board pin list
        buildBoardPinButtons($("#powerBoardOutputSelector"), powerBoard_headers, false);
        initBoardPinPageAdjustor(
            "powerBoardOutputSelector", $("#numPowerBoards"), "3.", 32, 32);

        // Build the chime board pin list when we add or remove board
        buildBoardPinButtons($("#chimeBoardOutputSelector"), chimeBoard_headers, false);
        initBoardPinPageAdjustor(
            "chimeBoardOutputSelector", $("#numChimeBoards"), "4.", 8, 0);

        // Initialize the page adjustor for one of the output boards
        function initBoardPinPageAdjustor(
            pageName, numBoardsField, typePrefix, outputsPerBoard, startingOutput)
        {
            // we haven't built any of these yet
            var numBoards = 0;

            // set up the adjustor function, and store it in the table so
            // that showChipPinPage() can automatically call it
            chipPinPageAdjustor[pageName] = function()
            {
                // if the number of chips is different from last time, update it
                var newNumBoards = +numBoardsField.val();
                if (newNumBoards != numBoards)
                {
                    // add new pins as needed
                    var page = $("#" + pageName);
                    buildGroupedPinList(page, [{
                        groups: ordinals(0, newNumBoards-1),
                        pins: outputsPerBoard, header: "Board 1", pinname: "Output 1",
                        pinid: function(pin, board) {
                            return typePrefix + (board*outputsPerBoard + startingOutput + pin);
                        },
                        hovername: function(pinName, pinNo) { 
                            return "JP" + (Math.floor(pinNo/16)+5) + "-" + ((pinNo%16)+1);
                        }
                    }]);
                    
                    // hide boards and pins that aren't currently available
                    page.find(".chipNo, .chipPin").each(function() {
                        var self = $(this);
                        self.toggle(+self.data("chip") < newNumBoards);
                    });

                    // rebuild the board indexer
                    buildChipIndexer(page, ordinals(0, newNumBoards - 1), outputsPerBoard, 1);
                }

                // remember the new chip count
                numBoards = newNumBoards;
            };
        }

        // Build the pin buttons for an expansion board pin selector.
        //
        // Header pins can be specified as GPIO port names or our usual
        // "n.m" output port codes (e.g., "3.7" for TLC5940 output port 7).
        // GPIO ports are untyped because they take their type from the
        // page context.  All other outputs must be typed.
        //
        // For a repeatable board, such as the power board or chime board,
        // the port number specified in a typed output will serve as the
        // base port number.  On second and subsequent instances of the
        // board, we'll bump up the actual port numbers by the number of
        // such ports on the board.
        //
        // If filterToList is true, we'll only make buttons available if
        // they appear in the page's list.
        function buildBoardPinButtons(page, headers, filterToList)
        {
            // get the image padding
            var picdiv = page.find(".pinimage");
            var img = picdiv.find("img");
            var xpad = parseInt(img.css("padding-left"));
            var ypad = parseInt(img.css("padding-top"));

            // if filtering to the list, build a table of the pins in list
            var listPins = { };
            if (filterToList) {
                page.find(".pinlist .chipPin").each(function()
                {
                    var self = $(this);
                    var t = self.data("pintype");
                    var p = self.data("pin");
                    listPins[(t && t != 1 && t != 2 ? t + "." + p : p)] = true;
                });
            }

            // add each pin
            $.each(headers, function(jpName, header) {
                forEachPin(header, function(pin, n, x, y)
                {
                    // Our headers are populated with all pin names, but
                    // we can only assign pins tied to GPIO ports (PTxx names)
                    // or peripheral outputs (3.xx = TLC5940 output, 4.xx =
                    // 74HC595 output, 6.xx = TLC59116 output).
                    var dataPin = "", available = " available";
                    if (/^PT[A-E]\d+$/i.test(pin)) {
                        dataPin = "data-pin=\"" + pin + "\"";
                        var g = (expGpioPortAlias[pin] || "").split("|");
                        dataHover = "data-hovername=\"" + g[0] + " (" + g[1] + ")\"";
                        if (filterToList && !listPins[pin])
                            available = "";
                    }
                    else if (/^([34])\.(\d+)$/.test(pin)) {
                        dataPin = "data-pin=\"" + RegExp.$2 + "\" "
                                  + "data-pintype=\"" + RegExp.$1 + "\" "
                                  + "data-basepin=\"" + RegExp.$2 + "\" ";
                        var g = expOutPortAlias[pin].split("|");
                        dataHover = "data-hovername=\"" + g[0] + " (" + g[1] + ")\"";
                        if (filterToList && !listPins[pin])
                            available = "";
                    }
                    else {
                        available = "";
                    }

                    // add the item
                    picdiv.append(
                        "<div class=\"pinButton" + available + "\" "
                        + dataPin + dataHover
                        + "style=\"left: " + (x + xpad - 6) + "px; top: " + (y + ypad - 6) + "px;\">"
                        + "</div>");
                })
            });

            // add hover and click handlers
            addPinEvents(page.find(".pinlist"), picdiv, picdiv.find(".pinButton"));
        }

        // Initialize a scrolling list with a section header.  The list
        // is structured into sections with header elements, given by
        // the jQuery set 'sections'.  As we scroll through the list, we
        // "pin" the current section's header at the top of the list,
        // so that the current section header is always visible.
        //
        // There's no native way to do this with browser objects, so we
        // use some special effects.  To make this work, the list needs
        // a special position:absolute item just *before* the container
        // element.  This is the fixed-in-place header.  It has to be
        // absolutely positioned at the top of the list, and it has to
        // be sized to match the list interior width and header element
        // height.  It should also use the same class as the 'sections'
        // elements so that it looks the same.
        //
        // On each scroll event, we look to see if a section header in
        // the list overlaps the position:absolute fixed header element.
        // If so, we move the header element up so that it looks like
        // the next section header is pushing it off the screen as it
        // scrolls up.  When the next section header is at the very
        // top, we restore the fixed header to its normal pinned
        // position and change its text to match the new current
        // section.
        //
        // The result is that it *looks* like each section header
        // scrolls to the top and then sticks there.  What's really
        // happening is that we have just the one sticky element that
        // we relabel to match the current section.
        //
        // NB: to make the "nudge" effect work, the container has to
        // be wrapped in another container of the same size with
        // overflow:hidden.
        function initScrollHeader(container, sections)
        {
            var hdr = container.prev().filter(".header");
            container.off("scroll.scrollHeader").on("scroll.scrollHeader", function()
            {
                // assume that the first section is current
                var ele = sections.first();

                // scan the section headers to find the first one still in view
                sections.each(function(idx)
                {
                    // get this section header's position and height
                    var self = $(this);
                    var y = self.position().top;
                    var ht = self.outerHeight();

                    // Check to see if it's in view, out of view, or overlapping
                    // the fixed header area.
                    if (y < 0 && idx+1 == sections.length)
                    {
                        // This is the last item, and it's going out of view.  It's
                        // now the fixed header item.
                        hdr.css("top", "").text(self.text());
                    }
                    else if (y > 0 && y < ht)
                    {
                        // It overlaps the fixed header area.  This means that we're
                        // in a transition between sections.  Create the special effect
                        // that makes it look like the next and previous headers are
                        // moving together, by positioning the fixed element so that
                        // it abuts this header above.  This will make it look like
                        // it's scrolling along with the list, even though it's really
                        // the position:absolute foreground element.
                        hdr.css("top", (y-ht) + "px").text(ele.text());
                        return false;
                    }
                    else if (y >= ht)
                    {
                        // This header is completely in view.  Set the fixed header
                        // so that it's at its normal position - this looks like a
                        // regular section header that's sticking at the top of the
                        // list.  Set the fixed header text to the *previous* section
                        // text - the first item in view within the scrolling area
                        // is part of the previous section, since the current section
                        // is the first one that's in view.
                        hdr.css("top", "").text(ele.text());
                        return false;
                    }
                    else
                    {
                        // The current element is completely out of view.  Remember
                        // this as the previous element and keep going.
                        ele = self;
                    }
                });
            });
        }

        // initialize all pin selector controls
        $(".pinselect").data({"active": true, "save": true}).each(function()
        {
            // set up the current value and warning icon spans
            $(this).html("<input class=\"pinval\" readonly>"
                         + "<span class=\"pinwarn\"><img src=\"pinwarn.png\"></span>");

            // add an expansion board alias field, if requested
            if ($(this).hasClass("withExpBoardAlias"))
            {
                // mark the input as an expansion board pin (to be hidden in
                // expansion board mode), and add the alias field
                $(this).children("input").addClass("expBoardPin").after(
                    "<input class=\"expBoardAlt\" readonly>");
            }
        });

        // Handle clicks in GPIO pin selectors.  These selectors all select
        // a GPIO pins with one specific function (PWM out, digital in,
        // ADC in, etc), show we show only the page for that function.  All
        // other page buttons are hidden, since it's not possible to change
        // the pin type for a specific functional assignment.
        $(".pinselect").click(function(ev)
        {
            // remove focus from the field, so that the text cursor isn't
            // flashing while the dialog is visible
            var self = $(this);
            self.children(".pinval").blur();

            // show the pin selector dialog with the KL25Z page
            showPinSelector(self);

            // Show only the appropriate KL25Z page select button.  A .pinselect
            // field is tied to a particular pin type, so we only need to show
            // the one button that's appropriate to the type.  For all .pinselect
            // fields, include a Not Connected option in the pin list.
            var gpiotype = (self.data("gpiotype") + " nc").split(" ");
            $("#pinTypeSelector > div").each(function() {
                var vis = $(this).data("page") == "gpioSelector" && $(this).data("filter") == gpiotype[0];
                $(this).toggle(vis).toggleClass("selected", vis);
                if (vis)
                    selectPage($(this), true, gpiotype);
            });
        });

        // On clicking a button input selector expansion board alias field,
        // show a pin selector.  Show the main expansion board page, and also
        // show the direct KL25Z input selector as an alternative.
        $("#buttonTab input.expBoardAlt").click(function(ev)
        {
            // don't propagate the event to the parent, since it would reopen
            // the dialog in plain KL25Z mode
            ev.preventDefault();
            ev.stopPropagation();
            
            // remove focus from the field, to prevent flashing cursors in the dialog
            var self = $(this);
            self.blur();
            
            // Show the pin selector
            showPinSelector(self.parents(".pinselect"));
            
            // Make the KL25Z digital input page and expansion board input
            // pages visible, and start with the expansion board page active.
            $("#pinTypeSelector > div").each(function() {
                var btn = $(this);
                var pageName = btn.data("page");
                var sel = (pageName == "mainBoardInputSelector");
                var vis = sel;
                if (pageName == "gpioSelector" && btn.data("filter") == "dig-in") {
                    btn.data("curfilter", ["dig-in", "extern", "nc"]);
                    vis = true;
                }
                btn.toggle(vis).toggleClass("selected", sel);
                if (sel)
                    selectPage(btn, true, null);
            });
        });

        // Handle clicks in the output controller pin selectors.  These
        // selectors can choose any type of output pin (PWM out, digital out,
        // virtual out, TLC5940 out, 74HC595 out, TLC59116 out).  In expansion 
        // board mode, we add pages for the expansion boards.
        $("#outputTab .pinlabel, #outputTab .dispPinFunc, "
          + "#outputTab .dispPinType, #outputTab .dispPinLoc,"
          + "#outputTab .dispPinHeader, #outputTab .dispPinName").click(function(ev)
        {
            // remove focus from the field
            var self = $(this);
            var row = self.parents(".outPortRow");
            row.find(".dispPinName").blur();

            // show the dialog
            showPinSelector(row.find(".dispPinName").parent());

            // note the hardware mode (0=standalone, 1=expansion boards)
            var hwType = +$("input:radio[name=hardwareType]:checked").val();

            // get the selected row's pin and type, and the out port alias string
            var pintype = row.find(".pintype").val();
            var pinid = row.find(".pinval").val();
            var alias = (outPortAlias[pintype + "." + pinid] || "").split("|");

            // Show only the page select buttons for output pin types.
            var page;
            var foundSelected = false;
            $("#pinTypeSelector > div").each(function()
            {
                // get this button's dialog page name and the output type
                var pageName = $(this).data("page");
                var outtype = $(this).data("pintype");

                // figure out if this button is visible
                var vis = false;
                switch (pageName)
                {
                case "gpioSelector":
                    // KL2Z GPIO pages - enable for the PWM and Digital Out pins
                    vis = (outtype == 1 || outtype == 2);
                    break;

                case "tlc5940Selector":
                    // TLC5940.  This type is visible in standalone mode if we
                    // have any TLC5940 chips in the current configuration.
                    // In expansion board mode, we do have 5940 outputs, but we
                    // select these through the expansion board pages instead.
                    vis = (hwType == 0 && +$("#tlc_nchips").val() > 0);
                    break;

                case "tlc59116Selector":
                    // TLC59116.  This type is visible in standalone mode if
                    // we have any of these chips.
                    vis = (hwType == 0 && $("#tlc59116_chipsEnabled input:checked").length != 0);
                    break;

                case "hc595Selector":
                    // 74HC595.  Visible in standalone mode if we have any of
                    // these chips.
                    vis = (hwType == 0 && +$("#hc595_nchips").val() > 0);
                    break;

                case "virtualOutputSelector":
                    // Virtual out - always visible
                    vis = true;
                    break;

                case "mainBoardDigitalOutputSelector":
                    // Main expansion board digital outputs.  Enable in expansion
                    // board mode.
                    vis = (hwType == 1);
                    break;

                case "mainBoardPWMOutputSelector":
                    // Main expansion board PWM outputs.  Enable in expansion
                    // board mode.
                    vis = (hwType == 1);
                    break;

                case "powerBoardOutputSelector":
                    // Power board outputs.  Enable in expansion board mode if we
                    // have at least one power board.
                    vis = (hwType == 1 && +$("#numPowerBoards").val() > 0);
                    break;

                case "chimeBoardOutputSelector":
                    // Chime board outputs.  Enable in expansion board mode if we
                    // have at least one chime board.
                    vis = (hwType == 1 && +$("#numChimeBoards").val() > 0);
                    break;
                }

                // Determine if this page is selected.  Use only the first
                // selected page we find.
                var selected = false;
                if (!foundSelected)
                {
                    switch (hwType)
                    {
                    case 0:
                    default:
                        // Standalone mode.  Each page in this mode selects a single
                        // output pin type, so we can match page to pin by type.
                        selected = (outtype == pintype);
                        break;

                    case 1:
                        // Pinscape Expansion Board mode.  In this mode, each page
                        // can show a mix of types, and each type can appear on more
                        // than one page, so we can't match by type.  Instead, use
                        // the port alias - field [4] gives the board type.  If
                        // there's no port alias, fall back on the type-specific page.
                        selected = (alias[4] ? alias[4] == pageName : outtype == pintype);
                        break;
                    }
                }

                // If the page is selected, make it visible even if we wouldn't
                // have otherwise done so.
                if (selected) {
                    vis = true;
                    foundSelected = true;
                }
                
                // if the button is visible, show it
                $(this).toggle(vis);
                if (vis)
                {
                    // show the button's current selection status
                    $(this).toggleClass("selected", selected);

                    // if the button is selected, activate its page
                    if (selected)
                        selectPage($(this), true, null);
                }
            });
        });

        // handle clicks in the pin selector page buttons
        $("#pinTypeSelector > div").click(function() {
            selectPage($(this), false, null);
        });

        function selectPage(button, initial, pinFilter)
        {
            // remember the new active page button
            curpagebtn = button;

            // hide all pages
            $("#pinSelector .pinSelectorPage").css("display", "none");

            // show the selected page
            var pagename = button.data("page");
            var page = $("#" + pagename);
            page.css("display", "");

            // get its pin list
            curpinlst = page.find(".pinlist");

            // we don't have a selection on the new page yet
            curSelItem = null;

            // highlight the appropriate button
            $("#pinTypeSelector > div").removeClass("selected");
            button.addClass("selected");

            // set up the new page
            switch (pagename)
            {
            case "gpioSelector":
                // if the caller specified a filter, remember it
                if (pinFilter)
                    button.data("curfilter", pinFilter);

                // Show the KL25Z pin selector.  Use the caller's filter if provided,
                // otherwise use the button's current filter, otherwise use the
                // button's default filter.
                showKL25ZPinPage(pinFilter || button.data("curfilter") || button.data("filter").split(" "), initial);
                break;

            case "tlc5940Selector":
            case "hc595Selector":
            case "tlc59116Selector":
            case "mainBoardDigitalOutputSelector":
            case "mainBoardPWMOutputSelector":
            case "mainBoardInputSelector":
            case "powerBoardOutputSelector":
            case "chimeBoardOutputSelector":
                // show the chip pin selector
                showChipPinPage(pagename, page, initial, button.data("pintype"));
                break;

            case "virtualOutputSelector":
                showVirtualPage();
                break;
            }

            // If we have a list header, size it to match the list interior width.
            // We couldn't do this earlier because the page is invisible ("display:
            // none") when the dialog isn't open or a different page is active.  We
            // need the list to be visible in order to measure its width.
            var lst = page.find(".pinlist");
            lst.prev().filter(".header").css("width", lst.innerWidth() - sbwid);

            // if opening the dialog, make sure the button is in view
            if (initial)
                scrollIntoView(button, 0);
        }

        // show the virtual page
        function showVirtualPage()
        {
            // select the virtual out button if applicable
            $("#btnMakeVirtualPort").toggleClass(
                "selected", curpin.find(".pintype").val() == 5);

            // select the ZB port button if applicable
            $("#btnMakeZBPort").toggleClass(
                "selected", curpin.parents(".outPortRow").data("idx") == $("#zbPort").val());
        }

        // Show the pin selector dialog.  'opener' is the .pinselect INPUT child
        // that triggered the selection.  'positioner' is the visible element to
        // use as a reference point in positioning the dialog; this defaults to
        // the opener element if omitted.
        function showPinSelector(opener, positioner)
        {
            // use the opener as the default positioner
            positioner = positioner || opener;

            // forget any active gpio page filters from past runs
            pindlg.find(".pinTypeSelector > div").data("curfilter", null);

            // show the dialog
            pindlg.parent().css("display", "block");

            // show just the "virtual" page for sizing purposes
            pindlg.children(".pinSelectorPage").css("display", "none");
            $("#virtualOutputSelector").css("display", "");

            // move it align with the left of the field, centered vertically
            var ofs = positioner.offset();
            var dlght = pindlg.outerHeight() + 5;
            var dlgwid = pindlg.outerWidth();
            var winht = window.innerHeight - $("#nav").outerHeight();
            var winwid = window.innerWidth - getScrollBarWidth();
            var scrolly = $("html,body").scrollTop();
            var scrollx = $("html,body").scrollLeft();
            var x = ofs.left;
            var y = ofs.top + positioner.height()/2 - dlght/2;

            // if it goes out of view below, move it up
            if (y + dlght > scrolly + winht)
                y = scrolly + winht - dlght;

            // and if it goes out of view above, move it down
            if (y < scrolly)
                y = scrolly;

            // make sure it doesn't go out of the window to the right or left
            if (x + dlgwid > scrollx + winwid)
                x = scrollx + winwid - dlgwid;
            if (x < scrollx)
                x = scrollx;

            // position it
            pindlg.css({left: x + "px", top: y + "px"});

            // mark the opener's associated label as active
            curpinlbl = opener.parents(":has(.pinlabel)");
            curpinlbl.addClass("openDlgRow");

            // remember the opener
            curpin = opener;

            // add a dialog stack entry while we're open
            dialogStack.push({
                id: "pinDialog",
                keydown: function(ev) {
                    if (curpin && curpinlst)
                    {
                        function go(delta)
                        {
                            // If delta is +/- 10000, scroll by a page - figure the page size.
                            if (delta == -10000 || delta == 10000)
                            {
                                // refigure the delta in terms of elements per page
                                var pg = Math.floor(curpinlst.innerHeight() / curpinlst.children().first().innerHeight());
                                pg = (pg > 2 ? pg - 1 : 1);
                                delta = delta/10000*pg;
                            }

                            // Start at the current selection.  If there isn't one,
                            // select the first item initially.
                            var newsel = curSelItem;
                            if (!newsel)
                            {
                                // find the first item
                                newsel = curpinlst.find("div.available").first();

                                // If this is a down arrow or page down key, just go to
                                // the first item from an initial null selection.  This
                                // is nicer than jumping to the second item or next page
                                // immediately from no selection.
                                if (ev.which == 40 || ev.which == 34 || ev.which == 99) {
                                    pinselect(newsel, false, false);
                                    return;
                                }
                            }

                            // Seek forwards or backwards by the desired number of items;
                            // if we reach the end/beginning of the list, stop at the
                            // first/last element.
                            for ( ; delta < 0 ; ++delta)
                            {
                                newsel = newsel.prevAll(".available").first();
                                if (!newsel.length) {
                                    newsel = curpinlst.find("div.available").first();
                                    break;
                                }
                            }
                            for ( ; delta > 0 ; --delta)
                            {
                                newsel = newsel.nextAll(".available").first();
                                if (!newsel.length) {
                                    newsel = curpinlst.find("div.available").last();
                                    break;
                                }
                            }
                            
                            // select the new pin
                            pinselect(newsel, false, false);
                        }
    
                        // pin dialog is open
                        switch (ev.which)
                        {
                        case 38:
                            // up - select previous item or first item
                            go(-1);
                            ev.preventDefault();
                            return false;
                            
                        case 40:
                            // down - select next item or last item
                            go(1);
                            ev.preventDefault();
                            return false;

                        case 33:   // page up
                        case 105:  // keypad 9/page up
                            go(-10000);
                            ev.preventDefault();
                            return false;

                        case 35:   // end
                        case 97:   // keypad 1/end
                            go(9999);
                            ev.preventDefault();
                            return false;

                        case 36:   // home
                        case 103:  // keypad 7/home
                            go(-9999);
                            ev.preventDefault();
                            return false;

                        case 34:   // page down
                        case 99:   // keypad 3/page down
                            go(10000);
                            ev.preventDefault();
                            return false;
                            
                        case 13:
                        case 10:
                            // return/enter - close the dialog, selecting the current pin
                            pinselect(curSelItem, false, true);
                            return false;
                            
                        case 27:
                            // escape - close the dialog without changing the selection
                            dismissPinDlg();
                            return false;
                        }
                    }
                }
            });
        }

        // Show a KL25Z pin page in the pin selector dialog.
        //
        // 'gpiotype' is a string array giving the type of pin we're
        // selecting.  The first element must be one of the KL25Z GPIO
        // page keywords: dig-in, dig-out, pwm, adc, interrupt-in,
        // spi-mosi, or spi-sclk.
        //
        // Additional elements specify modifiers:
        //
        //   extern -> ONLY include external header pins in the list
        //   nc     -> ALSO include "Not Connected" in the list
        //
        // 'opening' is true if we're opening the dialog, false if we're
        // merely selecting a new page.
        function showKL25ZPinPage(gpiotype, opening)
        {
            // build a list of pin filters according to the pin type
            var pinFilter = function(p, name) { return true; };
            var primary = {
                "dig-in": function(p) { return p; },         // All pins can be used as digital inputs
                "dig-out": function(p) { return p; },        // ... or digital outputs.
                "adc": function(p) { return p && p.adc; },   // Other features are available on a subset of pins
                "pwm": function(p) { return p && p.pwm; },   // with no apparent pattern, so we use attributes to
                "interrupt-in": function(p) { return p && p.interrupt; },    // flag which features each pin supports.
                "spi-mosi": function(p) { return p && p.spi == "MOSI"; },
                "spi-sclk": function(p) { return p && p.spi == "SCLK"; }
            };

            // get the primary filter
            pinFilter = primary[gpiotype[0]];

            // add exclusion modifiers first
            var modifiers = gpiotype.slice(1);
            $.each(modifiers, function(k, v)
            {
                if (v == "extern") {
                    // external pins only - pin must be external AND match primary rule
                    pinFilter = (function(f) {
                        return function(p, name) { return p && !p.internal && f(p, name); };
                    })(pinFilter);
                }
            });

            // add inclusive modifiers last
            $.each(modifiers, function(k, v)
            {
                if (v == "nc") {
                    // NC - matches Not Connected always, or matches other conditions
                    pinFilter = (function(f) {
                        return function(p, name) { return name == "Not Connected" || f(p, name); };
                    })(pinFilter);
                }
            });

            // filter the KL25Z pin list and pin images to make available
            // the subset appropriate for this pin type
            $("#kl25zPinImg .pinButton, #lstKL25ZPins > div").each(function() {
                var name = $(this).data("pin");
                var gp = gpioPinsByName[name];
                $(this).toggleClass("available", !!pinFilter(gp, name));
            });

            // make the current selection active
            var sel = null;
            var val = curpin.find(".pinval").val();
            pinlst.children().each(function() {
                if (pinlistVal($(this)) == val)
                {
                    sel = $(this);
                    return false;
                }
            });

            // select the item
            sel = sel || pinlst.children().first();
            pinselect(sel, opening, false);

            // mark in-use pins in the list and board image
            markPinsInUse($("#lstKL25ZPins > div, #kl25zPinImg .pinButton"), gpiotype[0] == "pwm", "kl25z");
        }

        // Mark in-use pins.  'pins' is a jQuery list of the pins to mark,
        // which can include the text list and the image buttons.
        //
        // 'pwm' is true if this selector page selects PWM pins.  If so,
        // we'll show a distinctive style for pins that aren't directly
        // in use but whose PWM channels are in use by other pins.
        //
        // 'pageType' is one of:
        //   - "kl25Z", for direct KL25Z pin selection pages
        //   - "chip", for peripheral chips - TLC5940, 74HC595, TLC59116
        //   - "board", for expansion boards
        var markPinsInUsePending = 0;
        function markPinsInUse(pins, pwm, pageType)
        {
            // if we don't already have a pending timeout, set one
            if (markPinsInUsePending++ == 0)
                setTimeout(function() { go(); }, 0);
    
            function go()
            {
                // no longer pending
                markPinsInUsePending = 0;
                
                // Build a table of all pins current in use
                var inuse = pinsInUse();

                // note the current selection
                var keyCur = inuseID(curpin);
                var gCur = gpioPinsByName[keyCur] || { };

                // visit each item in the dialog list
                pins.each(function()
                {
                    // get this item and its in-use key
                    var self = $(this);
                    var key = inuseID(self);

                    // presume it won't be in use
                    self.removeClass("inuse pwmInuse").attr("title", "");

                    // if it's a GPIO pin, get its descriptor
                    var g = gpioPinsByName[key] || { };

                    // get the port name and the jumper name/internal name
                    var port = g.name;
                    var jumper = pinToJumper(key);

                    // combine the pin name and conflict or remark text into a hover title
                    function title(txt)
                    {
                        var lst = [];
                        var h = self.data("hovername");
                        if (h) lst.push(h);
                        if (txt) lst.push(txt);
                        return lst.join(" - ");
                    }

                    // if this is the current pin, don't show conflicts - just set the
                    // title to the remarks
                    if (key == keyCur)
                    {
                        self.attr("title", title(g.remarks));
                        self.addClass("current selected");
                        return;
                    }

                    // If desired, check the PWM channel.  If this list/pin item is
                    // associated with a PWM channel other than the current selection's
                    // channel, show the other user(s).  We don't show a conflict with
                    // the current selection's channel because reassigning the pin will
                    // remove the old assignment, which will free up the channel.  We'll
                    // effectively be moving the same channel to a new pin, which won't
                    // create a conflict.
                    var pwmch, pwmiu;
                    var pwmUsers;
                    if (pwm
                        && (pwmch = g.pwm)
                        && pwmch != gCur.pwm
                        && (pwmiu = inuse["pwm." + pwmch]))
                    {
                        // This PWM channel is in use.  Make a note of the other users.
                        pwmUsers = "PWM Channel " + pwmch + " is in use by " + pwmiu.inUseBy();
                    }

                    // Note if this is a GPIO port that's connected to an expansion
                    // board port in the current configuration.  If it is, it'll have
                    // an alias.
                    var alias = pageType == "kl25z" && gpioPortAlias[key];

                    // Check for conflicts, in order of descending priority
                    if (inuse[key])
                    {
                        // in use - add class highlighting and show other users in the title
                        self.addClass("inuse");
                        self.attr("title", title("In use by " + inuse[key].inUseBy()));
                    }
                    else if (pwmUsers)
                    {
                        // the pin isn't claimed, but its PWM channel is already in use
                        self.addClass("pwmInuse");
                        self.attr("title", title(pwmUsers));
                    }
                    else if (alias)
                    {
                        self.addClass("inuse");
                        self.attr("title", title("This pin is used by the expansion board ("
                                                 + alias.split("|")[0]) + ")");
                    }
                    else
                    {
                        // not in use - remove the class highlighting, and set the title to
                        // any general remarks for this pin
                        self.attr("title", title(g.remarks));
                    }
                });
            }
        }

        // Show a chip pin page in the pin selector dialog
        function showChipPinPage(pageName, page, opening, pagePinType)
        {
            // run the pin adjustor function for this page, if any
            (chipPinPageAdjustor[pageName] || function() { })();

            // find the selected item in the list
            var sel = null;
            var lst = page.find(".pinlist");
            var val = curpin.find(".pinval").val();
            var typ = curpin.find(".pintype").val();
            lst.children().each(function()
            {
                // Check for a match to the pin name and type.  The pin
                // type can come from the list item, if it has one, or
                // from the page.
                var self = $(this);
                if (self.data("pin") == val
                    && (self.data("pintype") || pagePinType) == typ)
                {
                    sel = $(this);
                    return false;
                }
            });

            // deselect all pins in the list
            lst.children(".chipPin").removeClass("selected current inuse pwmInuse").attr("title", "");

            // deselect all chips
            page.find(".chipIndexer div").removeClass("selected");

            // select the active pin if there is one, otherwise just select
            // our first chip with no pin selection
            if (sel)
                pinselect(sel, opening, false);
            else
                switchChip(page, 0, 0);

            // mark in-use items
            markPinsInUse(page.find(".chipPin, .pinButton"), page.data("pwm"), page.data("pagetype"));
        }
    
        // Select a new chip on a chip pin selector (TLC5940, 74HC595, TLC59116).
        // This switches among multiple copies of the current chip type.
        function switchChip(page, chipno, pinsPerChip)
        {
            // deselect all pin buttons
            var picdiv = page.find(".pinimage");
            var buttons = picdiv.children(".pinButton");
            buttons.removeClass("selected current inuse").attr("title", "");

            // count the pins in the image if the caller didn't tell us
            if (!pinsPerChip)
                pinsPerChip = buttons.filter(function() { return $(this).data("basepin") !== undefined; }).length;

            // renumber the pins to the range for the currently selected chip
            var firstpin = chipno * pinsPerChip;
            buttons.each(function()
            {
                // if this is an output pin, renumber it
                var self = $(this);
                var basepin = self.data("basepin");
                if (basepin !== undefined)
                {
                    // renumber to the base pin number (the pin index within the chip)
                    // plus the first pin for the selected chip
                    var pin = firstpin + (+basepin);
                    var typ = self.data("pintype");
                    self.data("pin", pin);
                }
            });

            // show the new chip as current
            picdiv.find(".chipIndexer div").removeClass("selected")
                .filter(function() { return $(this).data("idx") == chipno; }).addClass("selected");

            // mark in-use items
            markPinsInUse(page.find(".chipPin, .pinButton"), page.data("pwm"), page.data("pagetype"));
        }

        // Handle focus and keystrokes in a pinselect text field
        $(".pinselect .pinval").focus(function(ev) {
            // on gaining focus, select all text so we lose the flashing cursor
            this.select();
        }).keydown(function(ev) {
            switch (ev.which)
            {
            case 10:
            case 13:
            case 32:
                // open the pin selector popup on enter/return/space
                $(this).parents(".pinselect").click();
                ev.preventDefault();
                return false;
            }
        });

        // clicking on a pin warning icon shows its warning
        $(".pinwarn").click(function() {
            event.stopPropagation();
            alert($(this).attr("title"));
        });

        // field that activated pin selector popup, and its label
        var curpin, curpinlbl;

        // Current selected list item.  This is mostly for the keyboard
        // (arrow key) interface.  This is initially set to the current
        // value of the field that opened the dialog, and we update it
        // when we move the selection via the arrow keys.
        var curSelItem;

        // current selected page button - this is the button div that
        // selected the page (one of the #pinTypeSelector descendants)
        var curpagebtn;

        // current page's pin list
        var curpinlst;

        // dismiss the pin selector dialog
        function dismissPinDlg()
        {
            // hide the dialog
            pindlg.parent().css("display", "none");

            // remove the active highlighting from the label
            if (curpinlbl)
                curpinlbl.removeClass("openDlgRow");

            // set focus back to the field
            $(curpin).children(".pinval").focus();
    
            // clear the dialog tracker variables
            curpin = curpinlbl = curSelItem = curpinlst = null;

            // remove our dialog stack entry
            popDialogStack("pinDialog");
        }

        // get the value for a pinlist item
        function pinlistVal(item)
        {
            return item.data("pin");
        }

        // Default flags to set for certain special pin selections.  We'll
        // set these flags when one of these pins is selected as an output port.
        var specialPinFlags = {
            "1.PTB18": 0x05,    // Red on-board LED, PWM Out: Active Low + Gamma
            "2.PTB18": 0x01,    // Red on-board LED, Digital Out: Active Low
            "1.PTB19": 0x05,    // green on-board LED, PWM Out: Active Low + Gamma
            "2.PTB19": 0x05,    // green on-board LED, Digital Out: Active Low + Gamma
            "1.PTD0":  0x05,    // blue on-board LED, PWM Out: Active Low + Gamma
            "2.PTD0":  0x05     // blue on-board LED, Digital Out: Active Low + Gamma
        };

        // select an item in a pinlist
        function pinselect(item, initial, dismiss)
        {
            // If this is a 'dismiss' action, don't do anything if the pin
            // isn't available.  This prevents losing the selection when
            // clicking on an image pin button that's not currently enabled.
            // We allow these button elements to handle events even when
            // inactive to provide visual feedback when hovering over pin
            // areas, since it's nice to be able to identify a pin this way
            // even when it can't be selected for the current function.
            if (!item.hasClass("available"))
                return;

            // get the page
            var page = $("#" + curpagebtn.data("page"));

            // reset the selected and current state on all pins
            curpinlst.children().removeClass("selected current");
            page.find(".pinButton").removeClass("selected current");
            
            // Only allow selecting available items
            if (!item || !item.hasClass("available"))
                return;

            // get the new selected item's name and pin type
            var name = pinlistVal(item);
            var pintype = item.data("pintype") || curpagebtn.data("pintype");
            var opalias = outPortAlias[pintype + "." + name];

            // check for warnings associated with this GPIO pin (e.g., warnings
            // about re-assigning pins wired to the on-board LED)
            var g = gpioPinsByName[name];
            if (dismiss && g && g.warning)
            {
                if (!window.external.YesNoDialog(
                    g.warning
                    + "\r\n\r\nWould you like to proceed with this pin assignment?"))
                return;
            }

            // If the selection is being made from the KL25Z pin selector
            // directly, and this pin has an expansion board alias in the
            // current hardware configuration, show a warning.
            var alias;
            if (dismiss && page.attr("id") == "gpioSelector" && (alias = gpioPortAlias[name]))
            {
                if (!window.external.YesNoDialog(
                    "You're attempting to assign a pin that's already wired "
                    + "to a specific function on the expansion board ("
                    + alias.split("|")[0] + "). The physical wiring on the "
                    + "board might make other uses impossible even if the "
                    + "associated feature is disabled in the software."
                    + "\r\n\r\n"
                    + "Are you sure you want to proceed with this pin selection?"))
                    return;
            }

            // Warn about the power limits for expansion board pins connected
            // directly to KL25Z GPIO ports
            if (dismiss && !initial && /^(Extender \d|Plunger \d|Cal Button\|)/i.test(opalias))
            {
                window.external.ShowAdviceDialog(
                    "RawOutputPowerLimitWarning",
                    "WARNING!\n\n"
                    + "This pin is connected DIRECTLY to a CPU port on the KL25Z. "
                    + "These pins have EXTREMELY low power handling capacity. "
                    + "NEVER CONNECT ANY LOAD LARGER THAN 4mA TO THIS PIN. "
                    + "The 4mA limit applies whether the pin is used in \"active "
                    + "high\" or \"active low\" mode. Exceeding 4mA in either mode "
                    + "can damage the CPU, which can render the whole KL25Z "
                    + "board inoperable.");
            }

            // dismiss the dialog if desired, otherwise fix up the list display
            // for the new selection
            if (dismiss)
            {
                // set the value in the container field
                if (curpin)
                {
                    // set the pin type and value
                    $(".pintype", curpin).val(pintype);
                    $(".pinval", curpin).val(name).change();

                    // set the pin flags, if appropriate
                    var sf = specialPinFlags[pintype + "." + name] || 0;
                    curpin.parents(".outPortRow").find(".pinflags").val(sf).change();

                    // notify the parent .pinselect object of the change
                    curpin.parents(".pinselect").change();
                }

                // build a new in-use table and update warnings
                updatePinWarnings();

                // dismiss the dialog
                dismissPinDlg();
            }
            else
            {
                // get the list element
                var f = function() { return $(this).data("pin") == name; };
                var lstele = $.contains(curpinlst[0], item[0]) ? item : curpinlst.children().filter(f);

                // switch to the new chip, if there's a chip indexer
                if (page.find(".chipIndexer").length)
                    switchChip(page, lstele.data("chip"));

                // On the initial selection, set the 'current' class.  In all
                // cases, set 'selected'.
                var cl = "selected";
                if (initial)
                    cl += " current";

                // add the classes to the newly selected item
                lstele.addClass(cl);
                page.find(".pinButton").filter(f).addClass(cl);
                
                // scroll the list element into view
                scrollIntoView(lstele, 1, { top: curpinlst.prev(".header").outerHeight() });

                // remember it as the new item
                curSelItem = item;
            }
        }

        // any click in the window cover area dismisses the dialog, but not
        // in the dialog itself (stop propagation to prevent that)
        pindlg.click(function(ev) { ev.stopPropagation(); });
        pindlg.parent().click(function() { dismissPinDlg(); });
    }
});

// Open dialog stack.  Each element is an object defining global
// event interceptors.  Our document-level events handlers will
// call these in sequence, starting from the LAST element of the
// list (which corresponds to the topmost open dialog).  If a
// handler returns false, it cancels further processing of the
// key - it won't "bubble" to other dialogs or to the document
// handler.
//
//    .keydown(ev) -> keydown interceptor
//
var dialogStack = [];

// remove the topmost dialog stack matching the given ID
function popDialogStack(id)
{
    for (var i = dialogStack.length - 1 ; i >= 0 ; --i)
    {
        if (dialogStack[i].id == id)
        {
            // this is the match - remove this element
            dialogStack = $.grep(dialogStack, function(ele, idx) { return idx != i });
            return;
        }
    }
}

// Global keyboard handler
$(document).keydown(function(ev)
{
    // Run it past any dialogs in the stack first
    for (var i = dialogStack.length - 1 ; i >= 0 ; --i)
    {
        // call this handler - if it returns false, stop processing
        if (dialogStack[i].keydown(ev) === false)
            return false;
    }

    // if it's an arrow key, and focus isn't in a text-like INPUT
    // control, scroll the page
    if (ev.which == 38 || ev.which == 40)
    {
        // check for focus
        var ele = document.activeElement;
        if (!ele || $(ele).filter("input[type=text], select").length == 0)
        {
            // it's not in a text field or a select box - scroll the page
            $("html,body").stop(false, true).animate(
                { "scrollTop": $("html,body").scrollTop() + (ev.which == 38 ? -64 : 64) }, 100);
        }
    }
});

// Normalize a configuration.  This sets certain unused fields to
// default values to make comparisons more uniform.  We return a
// new configuration object - the original isn't modified.
function normalizeConfig(config)
{
    // if it's empty, return nothing
    if (!config)
        return { };

    // create a new copy of the object, so that we leave the
    // original unmodified
    config = JSON.parse(JSON.stringify(config));
    
    // remove the array counts for buttons and outputs
    if (config.buttons)
        delete config.buttons.count;
    if (config.outputs)
        delete config.outputs.count;

    // set "Not Connected" values for unused plunger sensor fields
    if (!config.plungerPins)
        config.plungerPins = { };
    switch (config.plungerType)
    {
    case 0:
        // No sensor - set all pins to "NC"
        config.plungerPins.a = "NC";
        config.plungerPins.b = "NC";
        config.plungerPins.c = "NC";
        config.plungerPins.d = "NC";
        break;
        
    case 1:
    case 3:
    case 8:
        // TSL1410R / TSL1412R, serial mode - pin 'd' is unused
        config.plungerPins.d = "NC";
        break;

    case 5:
        // Potentiometer - pins b, c, and d are unused
        config.plungerPins.b = "NC";
        config.plungerPins.c = "NC";
        config.plungerPins.d = "NC";
        break;

    case 6:
        // Quadrature sensors (e.g. AEDR-8300) - pins c and d are unused
        config.plungerPins.c = "NC";
        config.plungerPins.d = "NC";
        break;

    case 9:
        // VL6180X time-of-flight distance sensor - pin d is unused
        config.plungerPins.d = "NC";
        break;
    }

    // if the TV-ON feature is disabled, clear all fields
    if (config.TVon && config.TVon.enabled !== undefined) {
        if (!config.TVon.enabled) {
            config.TVon.statusPin = "NC";
            config.TVon.latchPin = "NC";
            config.TVon.relayPin = "NC";
            config.TVon.delay = 700;
        }

        // this is a pseudo-field, so remove it from the config
        delete config.TVon.enabled;
    }

    // if there's no IR hardware, ignore any code assignments
    var s;
    if ((s = config.IRRemote)
        && s.sensorPin == "NC"
        && s.ledPin == "NC")
    {
        // clear all codes by setting the protocol to 0
        if (s = config.IRCode1) {
            $.each(s, function(key, val) {
                if (/\d+/.test(key)) {
                    val.flags = 0;
                    val.keytype = 0;
                    val.keycode = 0;
                    var s1;
                    if ((s1 = config.IRCode2) && s1[key]) {
                        s1[key].protocol = 0;
                        s1[key].codeLo = 0;
                    }
                    if ((s1 = config.IRCode3) && s1[key]) {
                        s1[key].codeHi = 0;
                    }
                }
            });
        }
    }

    // zero all fields for unused IR codes, as indicated by protocol == 0
    if (s = config.IRCode2) {
        $.each(s, function(key, val) {
            if (/\d+/.test(key) && val && val.protocol == 0) {
                val.codeLo = 0;
                var s1;
                if ((s1 = config.IRCode1) && s1[key]) {
                    s1[key].flags = 0;
                    s1[key].keytype = 0;
                    s1[key].keycode = 0;
                }
                if ((s1 = config.IRCode3) && s1[key]) {
                    s1[key].codeHi = 0;
                }
            }
        });
    }

    // if the TLC5940 feature is disabled, clear all fields
    if (config.TLC5940) {
        if (config.TLC5940.nchips == 0) {
            config.TLC5940.SIN = "NC";
            config.TLC5940.SCLK = "NC";
            config.TLC5940.XLAT = "NC";
            config.TLC5940.BLANK = "NC";
            config.TLC5940.GSCLK = "NC";
        }
    }

    // if the 74HC595 feature is disabled, clear all fields
    if (config.HC595) {
        if (config.HC595.nchips == 0) {
            config.HC595.SIN = "NC";
            config.HC595.SCLK = "NC";
            config.HC595.LATCH = "NC";
            config.HC595.ENA = "NC";
        }
    }

    // if the TLC59116 feature is disabled, clear all fields
    if (config.TLC59116) {
        if (config.TLC59116.chipMask == 0) {
            config.TLC59116.SDA = "NC";
            config.TLC59116.SCL = "NC";
            config.TLC59116.RESET = "NC";
        }
    }

    // we don't provide access to several of the plunger variables - these
    // are set through the plunger viewer instead
    delete config.plungerCal;
    delete config.plungerJitterFilter;
    delete config.plungerBarCode;

    // if in standalone mode, clear all expansion board fields
    if (config.expansionBoards) {
        if (config.expansionBoards.type == 0) {
            config.expansionBoards.version = 0;
            config.expansionBoards.ext0 = 0;
            config.expansionBoards.ext1 = 0;
            config.expansionBoards.ext2 = 0;
        }
    }

    // if ZB Launch Ball is disabled, clear fields
    if (config.ZBLaunchBall) {
        if (config.ZBLaunchBall.port == 0) {
            config.ZBLaunchBall.keytype = 0;
            config.ZBLaunchBall.keycode = 0;
            config.ZBLaunchBall.pushDistance = 0;
        }
    }

    // string-ize all output port IDs
    $.each(config.outputs, function(k, v) {
        if (v.port && typeof v.port.pin != "string")
            v.port.pin = "" + v.port.pin;
    });

    // string-ize all numbers for consistent comparisons
    function numToString(val)
    {
        if (typeof val === "number")
            val = "" + val;
        if (typeof val === "object")
            $.each(val, function(k, v) { val[k] = numToString(v); });
        return val;
    }
    numToString(config);

    // if there's no night mode button, the button flags don't matter
    if (config.nightMode && config.nightMode.button == 0)
        config.nightMode.flags &= ~0x03;

    // return the updated config object
    return config;
}

// Normalize an external config (xconfig)
function normalizeXConfig(xc)
{
    // if it's empty, return nothing
    if (!xc)
        return { };

    // create a new copy of the object, so that we leave the
    // original unmodified
    xc = JSON.parse(JSON.stringify(xc));

    // populate the outputs and IRCommand lists, if missing
    populate("outputs", MaxOutputs, {desc: ""});
    populate("IRCommand", $("#irCommandTab .irCommandRow").length, {desc: ""});

    // populate a section with a given key with numbered elements up to
    // the limit, and remove any excess elements
    function populate(key, n, defEle)
    {
        // if the section doesn't exist, add it
        var group = xc[key];
        if (!group)
            group = xc[key] = { };

        // remove excess elements
        var delList = [];
        $.each(group, function(k, v) { var ik = +k; if (ik == 0 || ik > n) delList.push(k); });
        $.each(delList, function(k, v) { delete group[v]; });

        // add missing elements
        for (var i = 1 ; i <= n ; ++i) {
            var ki = i.toString();
            if (!(ki in group))
                group[ki] = defEle;
        }
    }

    // return the updated config object
    return xc;
}


// When configuration loading is in progress, we set this to the config
// template object being loaded.  Change handlers can use this for
// special dependency handling needed during loading.
var loadingConfig;

// Load a configuration into and/or from the UI.
//
// configFromUI() returns a new config object built from the current
//    UI state.  The config object contains information that's stored
//    in the device flash memory.
//
// xconfigFromUI() returns a new xconfig object built from the current
//    UI state.  The xconfig object contains additional descriptive
//    information about the configuration that isn't needed at run-time,
//    such as user-entered description strings for the stored IR commands
//    and output ports.
//
// configToUI(config, xconfig) updates the UI state to match the given
//    config and xconfig objects.  'config' is the flash configuration
//    stored on the board; 'xconfig' is the external configuration stored
//    locally on the PC.  The external config stores additional data
//    that's not needed for runtime operation on the board and takes up
//    a lot of space, such as descriptive strings for the output ports
//    and stored IR commands.
//
var configFromUI, xconfigFromUI, configToUI;
function configFunctionSetup()
{
    // Create a new configuration data object from the current UI state
    configFromUI = function()
    {
        // run through the control mappings
        var newconfig = fromUI(fields);

        // For compatibility with older firmware versions, remove settings
        // that don't exist in older firmware.
        if (config)
        {
            if (!getprop(config, "shiftButton"))
                delete newconfig.shiftButton;
            if (!getprop(config, "xbuttons"))
                delete newconfig.xbuttons;
            if (!getprop(config, "IRRemote"))
            {
                delete newconfig.IRRemote;
                delete newconfig.IRCode1;
                delete newconfig.IRCode2;
                delete newconfig.IRCode3;
            }
        }

        // return the new configuration object
        return newconfig;
    }

    // Create a new xconfig object from the UI state
    xconfigFromUI = function()
    {
        // read the current UI data from the external fields (xfields) list
        return fromUI(xfields);
    }

    // Update the UI state to reflect the contents of the given configuration object.
    // 'source' is a ConfigSource element giving the source of the configuration data.
    configToUI = function(config, xconfig, source)
    {
        // set the global loading flag
        loadingConfig = config;
    
        // If loading a board configuration, size the tables whose
        // sizes are fixed in the firmware version.
        if (source == ConfigSource.Board)
        {
            // size the button table
            sizeButtonTable(config);

            // size the IR command table
            if (sizeIRCommandTab(config))
            {
                // add field descriptors for the IR command rows
                $("#irCommandTab .irCommandRow").each(function()
                {
                    // get the row
                    var tr = $(this);
                    var idx = tr.data("irrow");

                    // Add the IR command code for the row.  The config stores
                    // the command in three parts: protocol, flags, and a 64-bit
                    // code word.  Combine these for display as hex integers in
                    // the format Protocol.Flags.CodeWord.
                    var code = tr.children(".irCode");
                    fields.push({ prop: "IRCode1." + idx + ".flags", ctl: code.children(".irFlags"), type: tText, datatype: dNumber });
                    fields.push({ prop: "IRCode2." + idx + ".protocol", ctl: code.children(".irProtocol"), type: tText, datatype: dNumber });
                    fields.push({ prop: "IRCode2." + idx + ".codeLo", ctl: code.children(".irCodeLo"), type: tText, datatype: dNumber });
                    fields.push({ prop: "IRCode3." + idx + ".codeHi", ctl: code.children(".irCodeHi"), type: tText, datatype: dNumber });
                    xfields.push({ prop: "IRCommand." + idx + ".desc", ctl: tr.find(".irDesc"), type: tText, datatype: dText });

                    // add the key mapping for the row
                    var km = tr.find(".keymapping");
                    var prop = "IRCode1." + idx;
                    fields.push({ prop: prop + ".keytype", ctl: km.children(".keytype"), type: tText, datatype: dNumber });
                    fields.push({ prop: prop + ".keycode", ctl: km.children(".keycode"), type: tText, datatype: dNumber });
                });
            }
        }

        // populate controls from the config and xconfig objects
        toUI(config, fields);
        toUI(xconfig, xfields);

        // update peripheral pin connection active status
        adjustPeripheralPins(true, true, true);
        
        // update pin warnings
        updatePinWarnings();

        // adjust the display size of the outputs table
        sizeOutputsTable();

        // we're no longer loading a configuration
        loadingConfig = false;
    }

    // read the UI controls and convert to a javascript hash
    // using the given field descriptor list
    function fromUI(fieldList)
    {
        // create a new empty config object
        var newconfig = { }

        // populate it from the field map
        for (var i = 0 ; i < fieldList.length ; ++i)
        {
            // get this field descriptor and its UI control
            var f = fieldList[i];
            var ctl = $(f.ctl);

            // retrieve the value, according to the control type
            var v = f.type.fromUI(ctl);

            // apply any declared data conversions on the value
            if (f.datatype)
                v = f.datatype.fromUI(v);

            // if there's a value-from-UI translator, run it
            if (f.fromUI)
                v = f.fromUI(v);

            // apply the filter, if any
            if (f.filter)
                v = f.filter(v);

            // if we ended up with a valid value, add it to the config
            if (typeof v != "undefined")
                setprop(newconfig, f.prop, v);
        }

        // return the result
        return newconfig;
    }

    // populate the UI controls from the given javascript hash
    // using the given field descriptor list
    function toUI(configObj, fieldList)
    {
        // run through the control mappings
        for (var i = 0 ; i < fieldList.length ; ++i)
        {
            // get this field descriptor and the config property
            var f = fieldList[i];
            var v = getprop(configObj, f.prop);

            // if we got a property, store it
            if (typeof v != "undefined")
            {
                // get the UI control
                var ctl = $(f.ctl);

                // if there's a declared datatype conversion, apply it
                if (f.datatype)
                    v = f.datatype.toUI(v);

                // if there's a property-to-UI conversion function, call it
                if (f.toUI)
                    v = f.toUI(v);

                // store the value in the control
                f.type.toUI(ctl, v);
            }
            else if (f.undefToUI)
                f.undefToUI();
        }
    }

    // control types
    var tText = {
        toUI:   function(ctl, val) { ctl.val(val).change(); },
        fromUI: function(ctl) { return ctl.val(); }
    };
    var tSelect = tText;
    var tCheckbox = {
        toUI:   function(ctl, val) { ctl.prop("checked", !!val).change(); },
        fromUI: function(ctl) { return ctl.prop("checked") ? 1 : 0; }
    };
    var tRadio = {
        toUI:   function(ctl, val) { ctl.val([val]).change(); },
        fromUI: function(ctl) { return $(ctl).filter(":checked").val(); }
    };
    var tPin = {
        toUI:   function(ctl, val) { ctl.val(val == "NC" ? "Not Connected" : val).change(); },
        fromUI: function(ctl) {
            var val = ctl.val();
            return (val == "Not Connected" ? "NC" : val);
        }
    };
    var tNone = {
        toUI:  function(ctl, val) { return undefined; },
        fromUI: function(ctl) { return undefined; }
    };

    // datatypes
    var dText = {
        toUI:   function(v) { return v; },
        fromUI: function(v) { return v; }
    };
    var dNumber = {
        toUI:   function(v) { return parseInt(v); },
        fromUI: function(v) { return parseInt(v); }
    };
    function dNumberScale(factor) {
        return {
            toUI:   function(v) { return parseInt(v)/factor; },
            fromUI: function(v) { return parseFloat(v)*factor; }
        };
    }

    // Mappings between controls and config variables
    var fields = [
        { prop: "USBID", ctl: "#popUsbID", type: tText,
          toUI: function(v) { var v = hex4(v.vendor) + hex4(v.product); ensureUsbId(v); return v; },
          fromUI: function(v) { return { vendor: parseInt(v.substr(0, 4), 16), product: parseInt(v.substr(4), 16) }; }
        },
        { prop: "pinscapeID", ctl: "#popPinscapeID", type: tSelect, datatype: dNumber },
        { prop: "joystickEnabled", ctl: "#ckJoystick", type: tCheckbox },
        { prop: "disconnectRebootTime", ctl: "#ckRebootEnable", type: tCheckbox,
          toUI: function(v) { return +v != 0; },
          fromUI: function(v) { return undefined; }
        },
        { prop: "disconnectRebootTime", ctl: "#txtRebootTime", type: tText, datatype: dNumber,
          fromUI: function(v) { return $("#ckRebootEnable").prop("checked") ? v : 0; }
        },
        { prop: "accelerometer.orientation", ctl: "input:radio[name=accelOrientation]", type: tRadio, datatype: dNumber },
        { prop: "accelerometer.dynamicRange", ctl: "input:radio[name=accelRange]", type: tRadio, datatype: dNumber },
        { prop: "accelerometer.autoCenterMode", ctl: "#accelAutoCenterTime", type: tText, datatype: dNumber,
          fromUI: function(v) {
              // radio button value=1 is the custom time; value=0 and value=255 are 'default' and 'manual'
              var r = $("#autoCenterRadioButtons input:radio[name=autoCenterMode]:checked").val();
              return (r == 1 ? $("#accelAutoCenterTime").val() : r);
          },
          toUI: function(v) {
              $("#autoCenterRadioButtons input:radio[name=autoCenterMode]").val([v == 0 || v == 255 ? v : 1]).change();
              return v >= 1 && v <= 60 ? v : 5;
          }
        },

        { prop: "plungerType", ctl: "#plungerType", type: tSelect, datatype: dNumber },
        { prop: "calButtonPins.enabled", ctl: "", type: tText, datatype: dNumber,
          fromUI: function(v) {
              return ($("#calBtnEna").prop("checked") ? 0x01 : 0x00)
                  + ($("#calLEDEna").prop("checked") ? 0x02 : 0x00);
          },
          toUI: function(v) {
              $("#calBtnEna").prop("checked", (v & 0x01) != 0).change();
              $("#calLEDEna").prop("checked", (v & 0x02) != 0).change();
              return undefined;
          }
        },

        { prop: "ZBLaunchBall.pushDistance", ctl: "#zbDistance", type: tText, datatype: dNumberScale(1000) },
        { prop: "ZBLaunchBall.port", ctl: "#zbEnabled", type: tCheckbox,
          toUI: function(v) { return +v != 0; },
          fromUI: function(v) { return undefined; }
        },
        { prop: "ZBLaunchBall.port", ctl: "#zbPort", type: tText, datatype: dNumber },
        { prop: "ZBLaunchBall.keytype", ctl: "#keymapZB .keytype", type: tText, datatype: dNumber },
        { prop: "ZBLaunchBall.keycode", ctl: "#keymapZB .keycode", type: tText, datatype: dNumber },

        { prop: "plungerAutoZero.flags", ctl: "#plungerAutoZeroEnabled", type: tCheckbox,
          toUI: function(v) { return (v & 0x01) != 0; },
          fromUI: function(v) { return $("#plungerAutoZeroEnabled").prop("checked") ? 0x01 : 0x00; }
        },
        { prop: "plungerAutoZero.time", ctl: "#plungerAutoZeroTime", type: tText, datatype: dNumber },

        { prop: "TVon.delay", ctl: "#tvDelay", type: tText, datatype: dNumberScale(100) },

        { prop: "nightMode.button", ctl: "#nightModeButtonNo", type: tText, datatype: dNumber },
        { prop: "nightMode.output", ctl: "#nightModeOutputNo", type: tText, datatype: dNumber },
        { prop: "nightMode.flags", ctl: "", type: tRadio, datatype: dNumber,
          toUI: function(v) {
              // set the switch type: if flag bit 0x01 is set, it's switch mode (2), otherwise momentary toggle mode (1)
              $("input:radio[name=nightModeButtonType]").val([(v & 0x01) ? 2 : 1]).change();

              // set the shift status: if flag bit 0x02 is set, it's the shifted button, otherwise the primary button;
              // but this only applies in toggle mode, so bit 0x01 must not be set
              $("#nightModeButtonShift input").prop("checked", (v & 0x03) == 0x02);
              return undefined;
          },
          fromUI: function(v) {
              var v = 0;
              if ($("input:radio[name=nightModeButtonType]:checked").val() == 2) v |= 0x01;  // switch mode (2) -> flag 0x01
              if (!(v & 0x01) && $("#nightModeButtonShift input").prop("checked")) v |= 0x02; // shift button -> flag 0x02
              return v;
          }
        },
                  
        { prop: "expansionBoards.type", ctl: "input:radio[name=hardwareType]", type: tRadio, datatype: dNumber },
        { prop: "expansionBoards.version", ctl: "#expBoardVersion", type: tText },
        { prop: "expansionBoards.ext0", ctl: "#numMainBoards", type: tText, datatype: dNumber,
          fromUI: function(v) { return $("input:radio[name=hardwareType]:checked").val() == "1" ? v : undefined; }
        },
        { prop: "expansionBoards.ext1", ctl: "#numPowerBoards", type: tText, datatype: dNumber,
          fromUI: function(v) { return $("input:radio[name=hardwareType]:checked").val() == "1" ? v : undefined; }
        },
        { prop: "expansionBoards.ext2", ctl: "#numChimeBoards", type: tText, datatype: dNumber,
          fromUI: function(v) { return $("input:radio[name=hardwareType]:checked").val() == "1" ? v : undefined; }
        },
        { prop: "TLC5940.nchips", ctl: "#tlc_nchips", type: tText, datatype: dNumber },
        { prop: "HC595.nchips", ctl: "#hc595_nchips", type: tText, datatype: dNumber },

        { prop: "shiftButton.index", ctl: "#shiftButton", type: tText, datatype: dNumber },
        { prop: "shiftButton.mode", ctl: "input:radio[name=shiftButtonMode]", type: tRadio, datatype: dNumber },

        { prop: "TLC59116.chipMask", type: tNone,
          toUI: function(v) {
              $("#tlc59116_chipsEnabled input").each(function() {
                  $(this).prop("checked", (v & (1 << $(this).data("address"))) != 0).change(); });
              return undefined;
          },
          undefToUI: function(v) { $("#tlc59116_chipsEnabled input").first().change(); },
          fromUI: function(v) {
              var mask = 0;
              $("#tlc59116_chipsEnabled input:checked").each(function() {
                  mask |= 1 << $(this).data("address"); });
              return mask;
          }
        }
        
    ];

    // Mappings between controls and xconfig variables
    var xfields = [ ];

    // add field descriptors for all of the pin selectors
    $(".pinselect").each(function()
    {
        // get the configuration property name
        var self = $(this);
        var prop = self.data("cfg");

        // add a field definition for it
        fields.push({
            prop: prop,
            ctl: self.children(".pinval"),
            type: tPin,
            filter: function(v) { return self.data("save") ? v : undefined; },
            undefToUI: function(v) { this.ctl.val("Not Connected"); }
        });
    });

    // add field descriptors for the button table key mappings
    $("#buttonTab .keymapping").each(function()
    {
        var self = $(this);
        var idx = self.data("idx");
        var xidx = self.data("xidx");
        var prop = idx ? "buttons." + idx : xidx ? "xbuttons." + xidx : null;
        if (prop)
        {
            var filter = function(v) { return self.data("outOfService") ? undefined : v; };
            fields.push({ prop: prop + ".keytype", ctl: self.children(".keytype"), type: tText, datatype: dNumber, filter: filter });
            fields.push({ prop: prop + ".keycode", ctl: self.children(".keycode"), type: tText, datatype: dNumber, filter: filter });
            if (idx)
                fields.push({ prop: prop + ".flags", ctl: self.children("input.keyflags"), type: tText, datatype: dNumber, filter: filter });
            self.parents("td").find(".IRCommand").each(function() {
                fields.push({ prop: prop + ".IRCommand", ctl: $(this), type: tText, datatype: dNumber, filter: filter });
            });
        }
    });

    // add field descriptors for the output port mappings
    $("#outputTab .outPortRow").each(function()
    {
        var self = $(this);
        var idx = self.data("idx");
        if (idx && idx != "end")
        {
            var prop = "outputs." + idx;
            fields.push({ prop: prop + ".port.type", ctl: self.find(".pintype"), type: tText, datatype: dNumber });
            fields.push({ prop: prop + ".port.pin", ctl: self.find(".pinval"), type: tText });
            fields.push({ prop: prop + ".flags", ctl: self.find(".pinflags"), type: tText, datatype: dNumber });
            xfields.push({ prop: prop + ".desc", ctl: self.find(".outPortDesc"), type: tText, datatype: dText });
        }
    });

    // Get a property by path, if present
    function getprop(obj, prop, defval)
    {
        // if we don't have an object, stop here
        if (!obj)
            return obj;

        // traverse the dot-separated property list
        prop = prop.split(".");
        while (prop.length)
        {
            // descend only if the next property is present
            var p = prop.shift();
            if (p in obj)
                obj = obj[p];
            else
                return defval;
        }

        // return the final evaluated object
        return obj;
    }

    // Does a property exist?
    function hasprop(obj, prop)
    {
        // if there's no object, the property doesn't exist
        if (!obj)
            return false;

        // traverse the dot-separated property list
        prop = prop.split(".");
        while (prop.length)
        {
            // descend only if the next property is present
            var p = prop.shift();
            if (p in obj)
                obj = obj[p];
            else
                return false;
        }

        // if we made it to the end of the list, the property exists
        return true;
    }
    
    // Set a property by path, creating intermediate
    // container objects as necessary.
    function setprop(obj, prop, val)
    {
        // traverse the dot-separated property list
        prop = prop.split(".");
        while (prop.length > 1)
        {
            // if the next property isn't present, create an empty object for it
            var p = prop.shift();
            if (!(p in obj))
                obj[p] = { };

            // traverse into the subobject
            obj = obj[p];
        }

        // set the final property
        obj[prop[0]] = val;
    }
}

// Convert a configuration set from UI format to USB format.

function configToUSB(uicfg)
{
    // Get the config var format descriptors.  This tells us how to format
    // the variables for the USB messages.
    var vardescs = window.external.GetConfigVarDescs().split("|");

    // Format each variable into a USB byte list
    var usb = [];
    $.each(vardescs, function(i, desc)
    {
        // Each variable descriptor uses this format:
        //   <varnum> <varname> <desc>
        // Split into the three parts.
        desc = desc.split(" ");
        var varid = desc[0];
        var varname = desc[1];
        var format = desc[2];

        // The <value> can be a substitution type, or an object.
        // The substitution types are of the form $X, where X is a
        // one-letter type code.  Object types use javascript object
        // syntax.  First, turn the type codes into strings, then
        // parse the descriptor into a javascript string or object.
        function parse(format, val)
        {
            if (/\{/.test(format))
            {
                // object format
                $.each(format.substr(1, format.length-2).split(","), function(k, v)
                {
                    // each field is a "property:value" - split at the ":" and
                    // process the field
                    v = v.split(":");
                    parse(v[1], val[v[0]]);
                });
            }
            else
            {
                // scalar value - check which type we have
                switch (format)
                {
                case "$B":      // byte - integer value to USB byte
                    bytes.push(parseInt(val || 0));
                    break;

                case "$W":      // word - integer value to USB two bytes little-endian 
                    var ii = parseInt(val || 0);
                    bytes.push(ii & 0xff);
                    bytes.push((ii >> 8) & 0xff);
                    break;

                case "$D":      // dword - integer value to USB four bytes little-endian
                    var ii = parseInt(val || 0);
                    bytes.push(ii & 0xff);
                    bytes.push((ii >> 8) & 0xff);
                    bytes.push((ii >> 16) & 0xff);
                    bytes.push((ii >> 24) & 0xff);
                    break;
    
                case "$P":      // port number - port name in "PTxx" format to USB byte
                    bytes.push(parseGPIOName(val));
                    break;

                case "$o":      // output port: object with {type:, pin:} fields to USB type byte + pin byte
                    // add the type byte
                    bytes.push(parseInt(val.type));
    
                    // interpret the pin name
                    switch (val.type)
                    {
                    case 1:
                    case 2:
                        // GPIO pins - the pin is a GPIO name
                        bytes.push(parseGPIOName(val.pin));
                        break;

                    case 3:
                    case 4:
                    case 6:
                        // TLC5940, 74HC595, TLC59116 ports - the pin is a 
                        // port number
                        bytes.push(parseInt(val.pin));
                        break;

                    default:
                        // pin is unused in all other types
                        bytes.push(0);
                        break;
                    }
                    break;
                }
            }

            function parseGPIOName(val)
            {
                if (/PT([A-E])(\d+)/i.test(val))
                {
                    var port = RegExp.$1.charCodeAt(0) - 65;
                    var pin = parseInt(RegExp.$2);
                    return (port << 5) | (pin & 0x1F);
                }
                else if (typeof val == "undefined" || val == "NC")
                {
                    // not connected
                    return 255;
                }
                else
                {
                    // anything else is invalid - use NC, but flag it internally by adding 256
                    // (the extra 256 will be masked out when we transmit the bytes via USB)
                    return 255 + 256;
                }
            }
        }

        // get the current UI settings for the current variable
        var uival = uicfg[varname];

        // check for an array variable
        if (typeof uival != "undefined")
        {
            if (/\d+\[\]/.test(varid))
            {
                // array - start at index 1 and continue until we run out of entries
                var arr = uicfg[varname];
                for (var j = 1 ; j in arr ; ++j)
                {
                    // the USB data starts with the variable ID and array index 
                    var bytes = [parseInt(varid), j];
                    parse(format, arr[j]);
                    usb.push(bytes.join(" "));
                }
            }
            else
            {
                // scalar variable - the USB data starts with the variable ID
                var bytes = [parseInt(varid)];
                parse(format, uival);
                usb.push(bytes.join(" "));
            }
        }
    });

    // return the usb list
    return usb;
}

// build a comma-separated list
function serialComma(lst, conjunction)
{
    if (lst.length < 1)
        return "";
    else if (lst.length == 1)
        return lst[0];
    else if (lst.length == 2)
        return lst[0] + " " + conjunction + " " + lst[1];
    else
        return lst.slice(0, -1).join(", ") + ", " + conjunction + " " + lst[lst.length-1];
}

// build a table of in-use pins
function pinsInUse()
{
    // generate a description of the list of users of an in-use pin
    var users = function() {
        return serialComma($.map(this.fields, function(ele) { return ele.data("desc"); }), "and");
    };

    function add(ele, v)
    {
        // create an entry for this name, if it's empty
        var t = inuse[v];
        if (!t)
            inuse[v] = t = {
                name: v,
                gpio: gpioPinsByName[v],
                inUseBy: users,
                fields: []
            };
        
        // add this pin's description to the list
        t.fields.push(ele);
    }

    // run through the .pinselect fields, and enroll each active one
    var inuse = { };
    $(".pinselect").each(function()
    {
        // only consider active items
        var self = $(this);
        if (self.data("active"))
        {
            // get the pin by name; proceed if we're connected to a pin
            var v = self.children(".pinval").val();
            if (v != "Not Connected" && gpioPinsByName[v])
            {
                // add an entry for the pin name
                add(self, v);

                // if this is a PWM pin, also add an entry for PWM channel
                if (/\b(pwm)\b/.test(self.data("gpiotype")))
                    add(self, "pwm." + gpioPinsByName[v].pwm);

                // if it's a PWM pin that needs independent period control,
                // add an entry for the whole TPM unit
                if (/\b(tpm)\b/.test(self.data("gpiotype")))
                    add(self, "tpm." + pwmToTpm(gpioPinsByName[v].pwm));

                // if it has a SPI function, add an entry for that
                if (/\b(spi-)/.test(self.data("gpiotype")))
                    add(self, "spi." + gpioPinsByName[v].spi);
            }
        }
    });

    // add the output ports
    $("#outputTab .outPortRow").each(function()
    {
        // only consider GPIO pins
        var self = $(this);
        var v = self.find(".pinval").val();
        var typ = +self.find(".pintype").val();
        switch (typ)
        {
        case 1: // PWM GPIO
        case 2: // Digital Out GPIO
            // get the pin by name; proceed if we're connected
            if (v != "NC" && gpioPinsByName[v])
            {
                // add an entry for the pin name
                add(self, v);

                // if it's used as a PWM pin, add an entry for the PWM channel
                if (typ == 1 && gpioPinsByName[v].pwm)
                    add(self, "pwm." + gpioPinsByName[v].pwm);
            }
            break;

        case 3: // TLC5940
            add(self, "tlc5940." + v);
            break;

        case 4: // 74HC595
            add(self, "hc595." + v);
            break;

        case 6: // TLC59116
            add(self, "tlc59116." + v);
            break;
        }
    });

    // return the table
    return inuse;
}

// create the in-use table ID for a pin selection
function inuseID(ele)
{
    // If the element has a "pin" data field, use that, along with
    // the "pintype" field if present.  Don't use a prefix for GPIO
    // port types (output types 1 and 2).
    var pinval = ele.data("pin");
    var pintype = ele.data("pintype");

    // If there's no "pin" data element, use the .pinval and .pintype fields
    if (pinval === undefined) {
        pinval = ele.find(".pinval").val();
        pintype = ele.find(".pintype").val();
    }
    
    // If the element has a .pintype field, apply the prefix for the type.
    // These fields apply to output rows, so the type ID corresponds to the
    // output type byte in the USB output port setup messages:
    // 
    //   type 3 -> TLC5940  -> prefix "tlc5940."
    //   type 4 -> 74HC595  -> prefix "hc595."
    //   type 6 -> TLC59116 -> prefix "tlc59116."
    //
    var pfx = { 3: "tlc5940.", 4: "hc595.", 6: "tlc59116." }[pintype] || "";

    // return the prefix plus the pin name
    return pfx + pinval;
}

// Update pin warnings.  This updates all of the visible warning icons
// attached to .pinselect and .outPortRow pin selector fields.
function updatePinWarnings()
{
    genPinWarnings(function(item, msg) {
        var warn = item.find(".pinwarn");
        if (msg) {
            warn.addClass("active");
            warn.attr("title", msg);
        }
        else {
            warn.removeClass("active");
        }
    });
}

// Determine if there are any warnings.  Returns a list of the .pinselect
// and .outPortRow items with warnings.
function getPinWarnings()
{
    var lst = [];
    genPinWarnings(function(item, msg) {
        if (msg)
            lst.push(item);
    });
    return lst;
}

// General pin warning handler.  We run through the .pinselect fields
// and .outPortRow items, checking each one to see if it has a conflict.
// For each conflict, we call the callback function:
//
//   cb(item, warningMessage)
//
// For items without conflicts, we call the callback with no message.
//
function genPinWarnings(cb)
{
    // get the in-use table
    var inuse = pinsInUse();

    // run through the pin selectors and update warnings
    $(".pinselect, #outputTab .outPortRow").each(function()
    {
        // check to see if this item has multiple users
        var self = $(this);
        var pin = inuseID(self);
        var pintype = self.find(".pintype").val();
        var gpiotype = self.data("gpiotype");
        var pwm = (/\b(pwm)\b/.test(gpiotype) || pintype == "1") && nullobj(gpioPinsByName[pin]).pwm;
        var tpm = /\b(tpm)\b/.test(gpiotype) && pwmToTpm(nullobj(gpioPinsByName[pin]).pwm);
        var spi = /b(spi-)/.test(gpiotype) && nullobj(gpioPinsByName[pin]).spi;
        var warn = self.find(".pinwarn");
        if (self.hasClass("pinselect") && !self.data("active"))
        {
            // it's inactive, so it can't be in conflict
            cb(self, undefined);
        }
        else if (inuse[pin] && inuse[pin].fields.length > 1)
        {
            // this one is in use multiple times - activate the warning
            cb(self, "This pin is assigned to multiple functions ("
               + inuse[pin].inUseBy() + ")");
        }
        else if (pwm && inuse["pwm." + pwm] && inuse["pwm." + pwm].fields.length > 1)
        {
            // the PWM channel is overcommitted
            cb(self, "This pin's PWM channel is used more than once "
               + "(PWM channel " + pwm + ", used by " + inuse["pwm." + pwm].inUseBy()
               + "). The PWM channel assigned to a pin can't be changed "
               + "(it's hard-wired within the CPU), so only one of "
               + pwmChannels[pwm].orList() + " may be used concurrently "
               + "as PWM outputs.  The other pins can still be used for other "
               + "purposes, as long as they're not assigned as PWM outputs.");
        }
        else if (tpm && inuse["tpm." + tpm] && inuse["tpm." + tpm].fields.length > 1)
        {
            cb(self, "This pin's PWM channel's TPM controller unit (PWM channel "
               + pwm + ", TPM unit " + tpm + " is used by more than one function "
               + "that requires control over the PWM frequency (" + inuse["tpm." + tpm].inUseBy()
               + ").  Only one of the following pins may be used concurrently "
               + "for any of those functions: " + tpmUnits[tpm].orList() + ". You must "
               + "switch one of those functions to a PWM-capable pin with a different "
               + "TPM unit number.  This is a hardware limitation of the KL25Z; PWM "
               + "frequency is controlled through the TPM unit, which contains a group "
               + "of channels, rather than the individual channels, so functions "
               + "that require independent frequency control must be assigned to "
               + "channels that are on separate TPM units.");
        }
        else if (spi && inuse["spi." + spi] && inuse["spi." + spi].fields.length > 1)
        {
            // the SPI controller is overcommitted
            cb(self, "This pin's SPI controller function is used more than once "
               + "(" + spi + ", used by " + inuse["spi." + spi].inUseBy()
               + "). Each SPI function can only be assigned to one pin.");
        }
        else
        {
            // turn off this one's warning
            cb(self, undefined);
        }
    });
}


// treat a return key in a text field as a commit
$("input[type='text']").keydown(function(event) {
    if (event.which == 13)
        $(this).change();
});

// update highlighting on selection change in a radio button table
$("table.radio input:radio").change(function() {
    $("td", $(this).parents("table.radio")).each(function() {
        $(this).toggleClass("selected", $("input:radio", $(this)).prop("checked"));
    });
});

function hex4(val)
{
    return ("0000" + (+val).toString(16).toUpperCase()).substr(-4);
}

$(function() {
    // On text field changes, remember the old value on each change.
    // Note that event binding order is important - this is bound last so
    // that it runs after other handlers have a chance to use the old value.
    $("input:text").change(function() {
        $(this).data("oldVal", $(this).val());
    });

    // initialize everyone's oldVal to their initial value
    $("input:text").each(function() {
        $(this).data("oldVal", $(this).val()); });
    
});

// show PWM port help
$("a.pwmHelp").click(function(ev) {
    window.external.ShowHelp("HelpPWM.htm");
    ev.preventDefault();
});

// show SPI port help
$("a.spiHelp").click(function(ev) {
    window.external.ShowHelp("HelpSPI.htm");
    ev.preventDefault();
});

// show output port flag help
$("a.outPortOptionsHelp").click(function(ev) {
    window.external.ShowHelp("HelpOutPortOptions.htm");
    ev.preventDefault();
});

// show button assignment help
$("a.btnHelp").click(function(ev) {
    window.external.ShowHelp("HelpKeyAssignments.htm");
    ev.preventDefault();
});

</script>

</body>
</html>
